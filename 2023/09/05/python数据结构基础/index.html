<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"atffang.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="2023-04-03日上传，2023-04-05日第三次更新。 报了个蓝桥杯的python赛道，却没怎么复习……稍微整理了一些数据结构（python实现）的知识点，赛前看一下。">
<meta property="og:type" content="article">
<meta property="og:title" content="python数据结构基础">
<meta property="og:url" content="https://atffang.github.io/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Tianyao&#39; s BLOG">
<meta property="og:description" content="2023-04-03日上传，2023-04-05日第三次更新。 报了个蓝桥杯的python赛道，却没怎么复习……稍微整理了一些数据结构（python实现）的知识点，赛前看一下。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://atffang.github.io/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%86%92%E6%B3%A1.gif">
<meta property="og:image" content="https://atffang.github.io/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E9%80%89%E6%8B%A9.gif">
<meta property="og:image" content="https://atffang.github.io/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E6%8F%92%E5%85%A5.gif">
<meta property="og:image" content="https://atffang.github.io/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%B8%8C%E5%B0%94.gif">
<meta property="og:image" content="https://atffang.github.io/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%BD%92%E5%B9%B6.gif">
<meta property="og:image" content="https://atffang.github.io/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%BF%AB%E9%80%9F.gif">
<meta property="og:image" content="https://atffang.github.io/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%89%8D%E5%BA%8F.gif">
<meta property="og:image" content="https://atffang.github.io/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E4%B8%AD%E5%BA%8F.gif">
<meta property="og:image" content="https://atffang.github.io/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%90%8E%E5%BA%8F.gif">
<meta property="og:image" content="https://atffang.github.io/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%93%88%E5%A4%AB%E6%9B%BC.gif">
<meta property="og:image" content="https://atffang.github.io/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.gif">
<meta property="article:published_time" content="2023-09-05T12:49:50.000Z">
<meta property="article:modified_time" content="2023-09-13T07:04:40.000Z">
<meta property="article:author" content="Fang Tianyao">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://atffang.github.io/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%86%92%E6%B3%A1.gif">

<link rel="canonical" href="https://atffang.github.io/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>python数据结构基础 | Tianyao' s BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Tianyao' s BLOG" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Tianyao' s BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Tianyao</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://atffang.github.io/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Fang Tianyao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tianyao' s BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          python数据结构基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-05 20:49:50" itemprop="dateCreated datePublished" datetime="2023-09-05T20:49:50+08:00">2023-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-13 15:04:40" itemprop="dateModified" datetime="2023-09-13T15:04:40+08:00">2023-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/" itemprop="url" rel="index"><span itemprop="name">编程学习-Python</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>24k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>44 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>2023-04-03日上传，2023-04-05日第三次更新。<br />
报了个蓝桥杯的python赛道，却没怎么复习……稍微整理了一些数据结构（python实现）的知识点，赛前看一下。</p>
<span id="more"></span>
<p><strong>可以先看看第六章python基础</strong>（我记性太差了）</p>
<p>以下有的代码是书上抄的，有的代码是我自己写的，有的代码是gpt生成的，均为经过编译器编译，准确性未知，主要看个思路！</p>
<p>以及：如果网页版看的不爽，您可以点击下载<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/ATFfang/publicWarehouse/main/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80.md">markdown</a>（只是里面没有动图）。请注意：务必下载时，选择文件类型为全部文件，<a target="_blank" rel="noopener" href="http://xn--siqsrg0kktvclai81k.md">文件后缀改为.md</a>（<a target="_blank" rel="noopener" href="http://xn--Chrome-np7im42b3rqsmy8rarf797sbvfm9cz38ab87d.md">Chrome下载时显示的后缀确实是.md</a>，但这是因为他把后面的.txt折叠了……麻烦删掉）</p>
<h3 id="1-基础数据结构"><a class="markdownIt-Anchor" href="#1-基础数据结构"></a> 1. 基础数据结构</h3>
<h4 id="11-栈"><a class="markdownIt-Anchor" href="#11-栈"></a> 1.1 栈</h4>
<p>python栈实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__self</span>(<span class="params">self</span>):</span><br><span class="line">		self.items=[]</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> self.items==[]</span><br><span class="line">	<span class="comment">#入栈</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self,item</span>):</span><br><span class="line">		self.items.append(item)</span><br><span class="line">	<span class="comment">#`pop()` 函数用于删除列表中指定索引位置（默认为最后一个元素）的元素</span></span><br><span class="line">	<span class="comment">#出栈</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> self.items.pop();</span><br><span class="line">	<span class="comment">#取值</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> self.items[<span class="built_in">len</span>(items)-<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">len</span>(self.items)</span><br></pre></td></tr></table></figure>
<p>用途：匹配括号，将十进制转化为二进制，前序、中序、后序表达式以及其之间的转换。</p>
<h4 id="12-a队列"><a class="markdownIt-Anchor" href="#12-a队列"></a> 1.2 a.队列</h4>
<p>python队列的实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">		self.items=[]</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> self.items==[]</span><br><span class="line">	<span class="comment">#入队</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">enqueue</span>(<span class="params">self,item</span>):</span><br><span class="line">		<span class="keyword">return</span> self.items.insert(<span class="number">0</span>,item)</span><br><span class="line">	<span class="comment">#出队</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">dequeue</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> self.items.pop();</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">len</span>(self.items)</span><br></pre></td></tr></table></figure>
<p>队列的例子：模拟传土豆，模拟打印任务</p>
<h4 id="12-b双端队列"><a class="markdownIt-Anchor" href="#12-b双端队列"></a> 1.2 b.双端队列</h4>
<p>双端队列是与队列类似的有序集合。与队列不同的是，双端队列在哪一端添加元素都没有任何限制，移除也是同理。<br />
双端队列的实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Deque</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">		self.items=[]</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> self.items==[]</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">addFront</span>(<span class="params">self,item</span>):</span><br><span class="line">		self.items.append(item)</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">addRear</span>(<span class="params">self,item</span>):</span><br><span class="line">		self.items.insert(<span class="number">0</span>,item)</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">removeFront</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> self.items.pop()</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">removeRear</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> self.items.pop(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">len</span>(self.items)</span><br></pre></td></tr></table></figure>
<p>双端队列的应用：回文检测器<br />
回文检测器：将字符串逐字符加入双端队列，依次进行前后端出队，当前端出队元素和后端出队元素相等时再继续。</p>
<h4 id="13-列表"><a class="markdownIt-Anchor" href="#13-列表"></a> 1.3 列表</h4>
<h5 id="131无序列表链表"><a class="markdownIt-Anchor" href="#131无序列表链表"></a> 1.3.1无序列表：链表</h5>
<p>node节点是构建链表的基本数据结构。每一个节点至少保有：数据变量；指向下一个节点的应用。下面是一个node类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,initdata</span>):</span><br><span class="line">		self.data=initdata</span><br><span class="line">		self.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">getData</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> self.data</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">getNext</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> self.<span class="built_in">next</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">setData</span>(<span class="params">self,newdata</span>):</span><br><span class="line">		self.data=newdata</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">setNext</span>(<span class="params">self,newnext</span>):</span><br><span class="line">		self.<span class="built_in">next</span>=newnext</span><br></pre></td></tr></table></figure>
<p>通过节点，可以构建无序列表类UnorderedList类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnorderedList</span>:</span><br><span class="line">	<span class="comment">#在初始化时，只需要一个head节点：</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">		self.head=<span class="literal">None</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> self.head==<span class="literal">None</span></span><br><span class="line">	<span class="comment">#在head前添加一个节点，并将这个节点设置为head，此时head不再为None，即链表不再为空</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self,item</span>):</span><br><span class="line">		temp=Node(item)</span><br><span class="line">		temp.setNext(self.head)</span><br><span class="line">		self.head=temp</span><br><span class="line">	<span class="comment">#通过遍历获取链表长度</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">length</span>(<span class="params">self</span>):</span><br><span class="line">		current=self.head</span><br><span class="line">		cont=<span class="number">0</span></span><br><span class="line">		<span class="keyword">while</span>(current!=<span class="literal">None</span>):</span><br><span class="line">			cont+=<span class="number">1</span></span><br><span class="line">			current=current.getNext()</span><br><span class="line">		<span class="keyword">return</span> cont</span><br><span class="line">	<span class="comment">#遍历寻找元素是否在链表内</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self,item</span>):</span><br><span class="line">		current=self.head</span><br><span class="line">		found=false</span><br><span class="line">		<span class="keyword">while</span>(current!=<span class="literal">None</span> <span class="keyword">and</span> found==false):</span><br><span class="line">			<span class="keyword">if</span>(current.data==item):</span><br><span class="line">				found=true</span><br><span class="line">				<span class="keyword">return</span> found</span><br><span class="line">			<span class="keyword">else</span>:	</span><br><span class="line">				current=current.getNext()</span><br><span class="line">		<span class="keyword">return</span> found</span><br><span class="line">	<span class="comment">#通过遍历删除值</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self,item</span>):</span><br><span class="line">		current=self.head</span><br><span class="line">		previous=<span class="literal">None</span></span><br><span class="line">		found=<span class="literal">False</span></span><br><span class="line">		<span class="keyword">while</span> <span class="keyword">not</span> found:</span><br><span class="line">			<span class="keyword">if</span> current.getData()==item:</span><br><span class="line">				found=<span class="literal">True</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				previous=current</span><br><span class="line">				current=current.getNext()</span><br><span class="line">				</span><br><span class="line">		<span class="keyword">if</span> previous==<span class="literal">None</span>:</span><br><span class="line">			self.head=current.getNext()</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			previous.setNext(current.getNext())</span><br></pre></td></tr></table></figure>
<h5 id="132-有序列表"><a class="markdownIt-Anchor" href="#132-有序列表"></a> 1.3.2 有序列表</h5>
<p>有序列表中，元素的相对位置取决于他们的基本特征<br />
有序列表的实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OrderedList</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">		self.head=<span class="literal">None</span></span><br><span class="line">	<span class="comment">#遍历，找到比插入值大的节点，插入到该节点的前面</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self,item</span>):</span><br><span class="line">		current=self.head</span><br><span class="line">		precious=<span class="literal">None</span></span><br><span class="line">		stop=<span class="literal">False</span></span><br><span class="line">		<span class="keyword">while</span> current!=<span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> stop:</span><br><span class="line">			<span class="keyword">if</span> current.getData()&gt;item:</span><br><span class="line">				stop=<span class="literal">True</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				previous=current</span><br><span class="line">				current=current.getNext()</span><br><span class="line">		temp=Node(item)</span><br><span class="line">		<span class="keyword">if</span>(previous=<span class="literal">None</span>):</span><br><span class="line">			self.head=temp</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			temp.setNext(current)</span><br><span class="line">			precious.setNext(temp)</span><br><span class="line">	<span class="comment">#遍历，直到满足：1.找到了；2.遍历到的值已经大于要找的值，退出；</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self,item</span>):</span><br><span class="line">		current=self.head</span><br><span class="line">		found=<span class="literal">False</span></span><br><span class="line">		stop=<span class="literal">False</span></span><br><span class="line">		<span class="keyword">while</span> current!=<span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> found <span class="keyword">and</span> <span class="keyword">not</span> stop:</span><br><span class="line">			<span class="keyword">if</span> current.getData()==item:</span><br><span class="line">				found=<span class="literal">True</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				<span class="keyword">if</span> current.getData()&gt;item:</span><br><span class="line">					stop=<span class="literal">True</span></span><br><span class="line">				<span class="keyword">else</span>:</span><br><span class="line">					current=current.getNext()</span><br><span class="line">		<span class="keyword">return</span> found</span><br></pre></td></tr></table></figure>
<h3 id="2-递归"><a class="markdownIt-Anchor" href="#2-递归"></a> 2. 递归</h3>
<h4 id="21-迷宫搜索"><a class="markdownIt-Anchor" href="#21-迷宫搜索"></a> 2.1 迷宫搜索</h4>
<p>示例：迷宫搜索函数：<br />
下列的实例代码中，接受三个参数：迷宫对象、起始行、起始列<br />
PART_OF_PATH:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">searchForm</span>(<span class="params">maze,startRow,startColumn</span>):</span><br><span class="line">	maze.updatePosition(startRow,startColumn)</span><br><span class="line">	<span class="comment">#检查基本情况</span></span><br><span class="line">	<span class="comment">#1.遇到墙</span></span><br><span class="line">	<span class="keyword">if</span> (maze[startRow][startColumn]==OBSTACLE):</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">	<span class="comment">#2.遇到已经走过的格子</span></span><br><span class="line">	<span class="keyword">if</span> (maze[startRow][startColumn]==TRIED):</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">	<span class="comment">#3.找到出口</span></span><br><span class="line">	<span class="keyword">if</span> maze.isExit([startRow][startColumn]):</span><br><span class="line">		maze.updatePosition(startRow,startColumn,PART_OF_PATH)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">	maze.updatePosition(startRow,startColumn,TRIED)</span><br><span class="line"></span><br><span class="line">	<span class="comment">#否则，依次尝试四个方向走动，对于or，只要有一个正确，后面的就不会执行</span></span><br><span class="line">	found=searchFrom(maze,startRow-<span class="number">1</span>,startColumn)\</span><br><span class="line">		<span class="keyword">or</span> searchFrom(maze,startRow+<span class="number">1</span>,startColumn)\</span><br><span class="line">		<span class="keyword">or</span> searchFrom(maze,startRow,startColumn-<span class="number">1</span>)\</span><br><span class="line">		<span class="keyword">or</span> searchFrom(maze,startRow,startColumn+<span class="number">1</span>)</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">if</span> found:</span><br><span class="line">		maze.uodatePosition(startRow,startColumn,PART_OF_PATH)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		maze.uodatePosition(startRow,startColumn,DEAD_END)</span><br><span class="line">	<span class="keyword">return</span> found</span><br></pre></td></tr></table></figure>
<h4 id="22-汉诺塔"><a class="markdownIt-Anchor" href="#22-汉诺塔"></a> 2.2 汉诺塔</h4>
<p>其他示例：汉诺塔<br />
汉诺塔是一种经典的递归问题，它的原理比较简单：有三根杆子，在其中一根杆子上按照大小顺序放置了若干个圆盘，现在需要把这些圆盘从一根杆子移动到另一根杆子上，移动过程中要保证较大的圆盘必须放在较小的圆盘下面，且每次只能移动一个圆盘。在汉诺塔问题中，我们通常称这三根杆子为 A、B、C 杆。</p>
<p>解决汉诺塔问题的常用方法是递归算法，具体的步骤如下：</p>
<ol>
<li>递归出口：当只有一个圆盘时，直接把它从 A 杆移到 C 杆上，即 return 1。</li>
<li>将 n-1 个圆盘从 A 杆移动到 B 杆上，使用 C 杆作为辅助杆。</li>
<li>将第 n 个圆盘从 A 杆移动到 C 杆上。</li>
<li>将 n-1 个圆盘从 B 杆移动到 C 杆上，使用 A 杆作为辅助杆。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hanoi</span>(<span class="params">n, A, B, C</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Move disk 1 from &#123;&#125; to &#123;&#125;&quot;</span>.<span class="built_in">format</span>(A, C))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        step1 = hanoi(n - <span class="number">1</span>, A, C, B)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Move disk &#123;&#125; from &#123;&#125; to &#123;&#125;&quot;</span>.<span class="built_in">format</span>(n, A, C))</span><br><span class="line">        step2 = hanoi(n - <span class="number">1</span>, B, A, C)</span><br><span class="line">        <span class="keyword">return</span> step1 + <span class="number">1</span> + step2</span><br></pre></td></tr></table></figure>
<h4 id="23-动态规划"><a class="markdownIt-Anchor" href="#23-动态规划"></a> 2.3 动态规划</h4>
<p>示例：动态规划找零问题：</p>
<ul>
<li>问题提出：硬币只有1美分，5美分，10美分和25美分，如何在消耗硬币最少的情况下，找零出37美分？</li>
<li>问题剖析：<br />
1.递归方法，即：<br />
若是每次找出x元的硬币，则剩余找零为（找零-x）元，每次利用函数numCoins寻找四种numCoins（找零-x）中的最小值，构建一颗子节点为4的递归树。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numCoins=<span class="built_in">min</span>(<span class="number">1</span>+numCoins(找零-<span class="number">1</span>),<span class="number">1</span>+numCoins(找零-<span class="number">5</span>),<span class="number">1</span>+numCoins(找零-<span class="number">10</span>),<span class="number">1</span>+numCoins(找零-<span class="number">25</span>))</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>动态规划方法，即：<br />
每个金额的找零方式都由该金额-i的找零方式所决定，其中，i为硬币面值。<br />
譬如，当我们需要知道15分怎么找时，可以求以下方式的最小值：</li>
</ol>
<ul>
<li>一枚一分的硬币+14分所需的最少的硬币（1+6）</li>
<li>一枚5分的硬币+10分所需的最少的硬币（1+1）</li>
<li>一枚10分的硬币+5分所需最少的硬币（1+1）</li>
</ul>
<p>因此，我们从0开始，指导要解的找零值，求出这之间所有值的最小硬币构成。<br />
下面为动态规划的实现，其中，coinValueList为硬币的面值列表，change表示找零金额，minCoins表示从0到change的所有最优解，coinsUsed存储用于找零的硬币。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dpMakeChange</span>(<span class="params">coinValueList,change,minCoins,coinsUsed</span>):</span><br><span class="line">	<span class="comment">#从0遍历到change（python左闭右开！）</span></span><br><span class="line">	<span class="keyword">for</span> cents <span class="keyword">in</span> <span class="built_in">range</span>(change+<span class="number">1</span>):</span><br><span class="line">		<span class="comment">#所用的硬币数</span></span><br><span class="line">		coinCount=cents</span><br><span class="line">		<span class="comment">#记录使用的硬币的面额</span></span><br><span class="line">		newCoin=<span class="number">1</span></span><br><span class="line">		<span class="comment">#遍历所有小于找零值的硬币</span></span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> [c <span class="keyword">for</span> c <span class="keyword">in</span> coinValueList of c&lt;cents]:</span><br><span class="line">			<span class="comment">#如果cents-面额j的最小硬币数+1小于之前求得的硬币数，则替换</span></span><br><span class="line">			<span class="keyword">if</span> minCoins[cents-j]+<span class="number">1</span>&lt;coinCount:</span><br><span class="line">				CoinCount=minCoins[cents-j]+<span class="number">1</span></span><br><span class="line">				newCoin=j</span><br><span class="line">		<span class="comment">#记载入最优解列表中</span></span><br><span class="line">		minCoins[cents]=contCount</span><br><span class="line">		<span class="comment">#记载入使用过的硬币列表中</span></span><br><span class="line">		coinUsed[cents]=newCoin</span><br><span class="line">	<span class="keyword">return</span> minCoins[change]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printCoins</span>(<span class="params">coinsUsed,change</span>):</span><br><span class="line">	coin=change</span><br><span class="line">	<span class="keyword">while</span> coin&gt;<span class="number">0</span>:</span><br><span class="line">		thisCoin=coinsUsed[coin]</span><br><span class="line">		<span class="built_in">print</span>(thisCoin)</span><br><span class="line">		coin=coin-thisCoin		</span><br></pre></td></tr></table></figure>
<p>下面详细介绍一下动态规划：<br />
<strong>动态规划</strong>（Dynamic Programming，简称DP）是一种将复杂问题分解成更小的子问题来解决的优化技术，常用于解决最优化问题。它在求解具有重叠子问题和最优子结构的问题中特别有效。</p>
<p>动态规划的基本思想是将原问题分解成若干个子问题，先求解子问题的最优解，然后通过子问题的最优解得到原问题的最优解。具体来说，动态规划的思路包括以下几个步骤：<br />
（1）划分：按照问题的特征，把问题分为若干阶段。注意：划分后的阶段一定是有序的或者可排序的<br />
（2）确定状态和状态变量：将问题发展到各个阶段时所处的各种不同的客观情况表现出来。状态的选择要满足无后续性<br />
（3）确定决策并写出状态转移方程：状态转移就是根据上一阶段的决策和状态来导出本阶段的状态。根据相邻两个阶段状态之间的联系来确定决策方法和状态转移方程<br />
（4）边界条件：状态转移方程是一个递推式，因此需要找到递推终止的条件</p>
<p>整个求解过程可以用一张最优决策表来描述，最优决策表是一张二维表（行：决策阶段，列：问题的状态）表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</p>
<p>例如：f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)}</p>
<p>下面是一些问题实例，有助于理解动态规划：</p>
<h5 id="231-背包问题"><a class="markdownIt-Anchor" href="#231-背包问题"></a> 2.3.1 背包问题</h5>
<p>对于初学者来说，理解背包问题并不容易，可以先看这个<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1g7411B7SP/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=717d4feb094126b2033be27866e18150">视频</a>，里面有十分详细的讲解。<br />
背包问题是一类经典的优化问题，通常指在给定容量的背包中，如何选择最有价值的物品，使得背包中物品的总价值最大。<br />
具体来说，背包问题有两种形式：0/1背包和完全背包。<br />
0/1背包问题中，物品不可分割，每个物品只有一个，选择放入或不放入，不能将物品分成若干部分装入背包。<br />
完全背包问题中，每个物品可以选择放入多次，即物品是可分割的。</p>
<p>对于这两种问题，一般可以用动态规划的思想进行求解。设背包容量为V，有n个物品，第i个物品的体积为v[i]，价值为w[i]。定义f(i,j)表示在前i个物品中选择不超过j容量的物品的最大价值，则有：</p>
<ol>
<li>对于0/1背包问题：<br />
f(i,j) = max{f(i-1,j), f(i-1,j-v[i])+w[i]}, j &gt;= v[i]<br />
f(i,j) = f(i-1,j), j &lt; v[i]<br />
即：当第i件物品可以加入背包时，可以选择加入或者不加入。如果加入，则总价值为：f(i-1,j)，若不加入，则总价值为：第i件物品的价值+当前容量（总容量-第i件物品的重量）能够存放的最大价值f(i,j) = max{f(i-1,j), f(i-1,j-v[i])+w[i]}, j &gt;= v[i]</li>
</ol>
<p>python实现的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">knapsack</span>(<span class="params">capacity, weights, values, n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    0/1背包问题的解法</span></span><br><span class="line"><span class="string">    :param capacity: 背包的容量</span></span><br><span class="line"><span class="string">    :param weights: 每个物品的重量列表</span></span><br><span class="line"><span class="string">    :param values: 每个物品的价值列表</span></span><br><span class="line"><span class="string">    :param n: 物品数量</span></span><br><span class="line"><span class="string">    :return: 最大价值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 初始化二维数组f，用于存储状态转移方程的结果</span></span><br><span class="line">    f = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(capacity + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, capacity + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 如果当前物品的体积小于等于背包容量，则可以选择装入或者不装入</span></span><br><span class="line">            <span class="keyword">if</span> weights[i-<span class="number">1</span>] &lt;= j:</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i-<span class="number">1</span>][j], f[i-<span class="number">1</span>][j-weights[i-<span class="number">1</span>]]+values[i-<span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 否则只能不装入</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                f[i][j] = f[i-<span class="number">1</span>][j]</span><br><span class="line">    <span class="keyword">return</span> f[n][capacity]</span><br></pre></td></tr></table></figure>
<h5 id="232-台阶问题"><a class="markdownIt-Anchor" href="#232-台阶问题"></a> 2.3.2 台阶问题</h5>
<p>有n级台阶，一个人每次上一级或者两级，问有多少种走完n级台阶的方法。</p>
<p>分析：动态规划的实现的关键在于能不能准确合理的用动态规划表来抽象出 实际问题。在这个问题上，我们让f(n)表示走上n级台阶的方法数。</p>
<p>那么当n为1时，f(n) = 1,n为2时，f(n) =2,就是说当台阶只有一级的时候，方法数是一种，台阶有两级的时候，方法数为2。那么当我们要走上n级台阶，必然是从n-1级台阶迈一步或者是从n-2级台阶迈两步，所以到达n级台阶的方法数必然是到达n-1级台阶的方法数加上到达n-2级台阶的方法数之和。即f(n) = f(n-1)+f(n-2)，我们用dp[n]来表示动态规划表，dp[i],i&gt;0,i&lt;=n,表示到达i级台阶的方法数。</p>
<p>下面是一个python实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param n: an integer</span></span><br><span class="line"><span class="string">    @return: an ineger f(n)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">up</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="comment"># if n == 0:</span></span><br><span class="line">        <span class="comment">#     return 0</span></span><br><span class="line">        L = []</span><br><span class="line">        L.append(<span class="number">1</span>)</span><br><span class="line">        L.append(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">            L.append(L[i - <span class="number">1</span>] + L[i - <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> L[n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="3-搜索与排序"><a class="markdownIt-Anchor" href="#3-搜索与排序"></a> 3. 搜索与排序</h3>
<h4 id="31-搜索"><a class="markdownIt-Anchor" href="#31-搜索"></a> 3.1 搜索</h4>
<p>Python提供了in，通过它可以方便的检查元素是否在列表中：<br />
<code>15 in [1,2,3,4,15]</code></p>
<h5 id="311-顺序搜索"><a class="markdownIt-Anchor" href="#311-顺序搜索"></a> 3.1.1 顺序搜索</h5>
<p>这个就不讲了，大猩猩都会</p>
<h5 id="312-二分搜索"><a class="markdownIt-Anchor" href="#312-二分搜索"></a> 3.1.2 二分搜索</h5>
<p>目标值比中间元素小，则在左半部分继续查找；否则，在右半部分继续查找。重复以上过程，直到找到目标值或者确定目标值不存在为止。<br />
二分搜索算法的时间复杂度为 O(log n)，其中 n 表示数组中元素的个数，因此它比线性搜索算法的时间复杂度 O(n) 更快，特别是对于大规模的数据集。<br />
显然，二分搜索可以使用递归实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_helper</span>(<span class="params">arr, target, left, right</span>): </span><br><span class="line">	<span class="keyword">if</span> left &gt; right: </span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span> </span><br><span class="line">	mid = (left + right) // <span class="number">2</span> </span><br><span class="line">	<span class="keyword">if</span> arr[mid] == target: </span><br><span class="line">		<span class="keyword">return</span> mid </span><br><span class="line">	<span class="keyword">elif</span> arr[mid] &lt; target: </span><br><span class="line">		<span class="keyword">return</span> binary_search_helper(arr, target, mid + <span class="number">1</span>, right) </span><br><span class="line">	<span class="keyword">else</span>: </span><br><span class="line">		<span class="keyword">return</span> binary_search_helper(arr, target, left, mid - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h5 id="313-散列"><a class="markdownIt-Anchor" href="#313-散列"></a> 3.1.3 散列</h5>
<p>（这里我不想写了，下面都是gpt写的）<br />
散列（Hashing）是一种用于快速查找的数据结构，它能够在 O(1) 的时间复杂度内完成查找操作。散列使用散列函数将键映射到存储位置，每个存储位置称为散列表中的一个桶。当需要查找一个键时，可以使用散列函数计算出该键对应的桶的位置，并在该桶中查找是否存在对应的值。</p>
<p>散列函数是散列表的关键，它将键映射到桶的位置。一个好的散列函数应该具有以下特点：</p>
<ol>
<li>散列函数应该能够将不同的键映射到不同的桶，避免不同键的哈希冲突。</li>
<li>散列函数应该尽可能地将键均匀地分布在桶中，避免出现某些桶过载的情况。</li>
<li>散列函数的计算速度应该足够快，否则会影响散列表的性能。</li>
</ol>
<p>散列函数可以使用不同的算法来实现，包括简单的取余法、乘法散列法、多项式散列法、MD5 散列等。</p>
<p>在实际应用中，散列可以用于解决大量数据的查找问题，例如在数据库中查找记录、在哈希表中查找键值对等。但是，散列也有一些缺点，例如：</p>
<ol>
<li>散列函数可能出现哈希冲突，即不同的键映射到了同一个桶中，需要使用冲突解决策略来解决。</li>
<li>散列表的性能取决于散列函数的质量和散列表的装载因子，当装载因子过高时，会影响散列表的性能。</li>
<li>散列表的大小通常是固定的，不能动态扩展，如果散列表的大小不够，需要重新创建一个更大的散列表来解决。</li>
</ol>
<p>下面是一个示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, size</span>):</span><br><span class="line">        self.size = size</span><br><span class="line">        self.table = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash_func</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(key) % self.size</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        index = self.hash_func(key)</span><br><span class="line">        self.table[index].append((key, value))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, key</span>):</span><br><span class="line">        index = self.hash_func(key)</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> self.table[index]:</span><br><span class="line">            <span class="keyword">if</span> k == key:</span><br><span class="line">                <span class="keyword">return</span> v</span><br><span class="line">        <span class="keyword">raise</span> KeyError(key)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, key</span>):</span><br><span class="line">        index = self.hash_func(key)</span><br><span class="line">        <span class="keyword">for</span> i, (k, v) <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.table[index]):</span><br><span class="line">            <span class="keyword">if</span> k == key:</span><br><span class="line">                <span class="keyword">del</span> self.table[index][i]</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">raise</span> KeyError(key)</span><br></pre></td></tr></table></figure>
<p>以上是一个简单的散列表实现，使用 Python 列表作为散列表的存储结构，使用哈希函数将键映射到散列表中的索引位置。当插入一个键值对时，使用哈希函数计算键的索引位置，并将键值对添加到该位置对应的列表中。当查找或删除一个键值对时，同样使用哈希函数计算键的索引位置，并在该位置对应的列表中查找或删除键值对。</p>
<p>这里的哈希函数使用内置函数 hash，它可以将任意 Python 对象转换为整数，并且保证相同的对象具有相同的哈希值。但是，在实际应用中，可以根据具体的应用场景选择不同的哈希函数。</p>
<h4 id="32-排序"><a class="markdownIt-Anchor" href="#32-排序"></a> 3.2 排序</h4>
<p>python提供了内置的排序函数：<br />
<code>list.sort(*, key=None, reverse=False)</code>：该函数用于对列表进行原地排序，它接受 key 函数和 reverse 参数，如果 reverse 参数为 True，则按照降序排序。</p>
<h5 id="321-冒泡排序"><a class="markdownIt-Anchor" href="#321-冒泡排序"></a> 3.2.1 冒泡排序</h5>
<p>冒泡排序（Bubble Sort）是一种简单的排序算法，它重复地走访过要排序的数列，依次比较相邻的两个元素，如果它们的顺序错误就交换它们的位置，直到没有需要交换的元素为止。<br />
这没啥要讲的了</p>
<img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%86%92%E6%B3%A1.gif" class="" title="sucessful">
<h5 id="322-选择排序"><a class="markdownIt-Anchor" href="#322-选择排序"></a> 3.2.2 选择排序</h5>
<p>选择排序（Selection Sort）是一种简单的排序算法，它的基本思想是找到最小元素并将其放置在数组的起始位置，然后继续找到剩余元素中的最小元素并放置在已排序序列的末尾，以此类推，直到所有元素都排好序为止。</p>
<img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E9%80%89%E6%8B%A9.gif" class="" title="sucessful">
<p>具体实现过程如下：</p>
<ol>
<li>遍历整个数组，找到其中最小的元素，并记录其位置。</li>
<li>将最小元素与数组的第一个元素进行交换。</li>
<li>排除已排序的第一个元素，对剩余元素执行步骤 1 和 2，直到所有元素都被排序。</li>
</ol>
<p>下面是一个代码示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">selection_sort</span>(<span class="params">lst</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(lst)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        min_idx = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> lst[j] &lt; lst[min_idx]:</span><br><span class="line">                min_idx = j</span><br><span class="line">        lst[i], lst[min_idx] = lst[min_idx], lst[i]</span><br><span class="line">    <span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure>
<h5 id="323-插入排序"><a class="markdownIt-Anchor" href="#323-插入排序"></a> 3.2.3 插入排序</h5>
<p>一个一个插入到已排序序列中的合适位置，最终完成排序。具体实现过程如下：</p>
<ol>
<li>遍历整个数组，将数组中的第一个元素视为已排序序列。</li>
<li>遍历未排序序列中的元素，将它插入到已排序序列中的合适位置，使得插入后的序列仍然有序。</li>
<li>重复步骤 2 直到所有元素都被插入到已排序序列中。</li>
</ol>
<img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E6%8F%92%E5%85%A5.gif" class="" title="sucessful">
<p>下面是一个代码示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">lst</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(lst)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        key = lst[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> lst[j] &gt; key:</span><br><span class="line">            lst[j + <span class="number">1</span>] = lst[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        lst[j + <span class="number">1</span>] = key</span><br><span class="line">    <span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure>
<h5 id="324-希尔排序"><a class="markdownIt-Anchor" href="#324-希尔排序"></a> 3.2.4 希尔排序</h5>
<p>希尔排序（Shell Sort）是一种改进的插入排序算法，它是通过将整个序列分成若干个子序列来实现排序，每个子序列分别进行插入排序，最终完成整个序列的排序。</p>
<p>希尔排序的基本思想是将待排序序列按照一定的步长进行分组，对每组使用插入排序算法进行排序。然后将步长逐渐缩小，重复进行分组和排序，直到步长为 1。此时，序列已经被分成了若干个有序子序列，最后进行一次插入排序即可完成整个序列的排序。</p>
<img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%B8%8C%E5%B0%94.gif" class="" title="sucessful">
<p>下面是实现的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">shell_sort</span>(<span class="params">lst</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(lst)</span><br><span class="line">    gap = n // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap, n):</span><br><span class="line">            key = lst[i]</span><br><span class="line">            j = i - gap</span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> lst[j] &gt; key:</span><br><span class="line">                lst[j + gap] = lst[j]</span><br><span class="line">                j -= gap</span><br><span class="line">            lst[j + gap] = key</span><br><span class="line">        gap //= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure>
<p>其中，参数 lst 是一个待排序的列表，函数返回一个新的已排序的列表。函数首先将整个序列分成若干个子序列，对每个子序列使用插入排序算法进行排序。然后将步长 gap 逐渐缩小，重复进行分组和排序，直到步长为 1。在每个子序列中，将当前元素存储为关键字 key，并将它与已排序序列中的元素进行比较，找到合适的位置并插入，直到所有元素都被插入到已排序序列中为止。</p>
<h5 id="325-归并排序"><a class="markdownIt-Anchor" href="#325-归并排序"></a> 3.2.5 归并排序</h5>
<p>归并排序（Merge Sort）是一种稳定的排序算法，它采用分治思想将待排序序列分成若干个子序列，每个子序列都是有序的，然后再将这些有序的子序列合并成一个有序序列。</p>
<p>归并排序的基本思想是将待排序序列不断地对半分割，直到每个子序列只有一个元素，然后将相邻的子序列进行合并，形成新的有序子序列，直到最终只剩下一个有序序列为止。合并操作时，需要额外的一个数组来存储已经排序好的元素，最后再将排序好的元素复制回原数组。</p>
<img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%BD%92%E5%B9%B6.gif" class="" title="sucessful">
<p>以下是使用 Python 实现的归并排序代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">lst</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(lst) &gt; <span class="number">1</span>:</span><br><span class="line">        mid = <span class="built_in">len</span>(lst) // <span class="number">2</span></span><br><span class="line">        left_half = lst[:mid]</span><br><span class="line">        right_half = lst[mid:]</span><br><span class="line"></span><br><span class="line">        merge_sort(left_half)</span><br><span class="line">        merge_sort(right_half)</span><br><span class="line"></span><br><span class="line">        i = j = k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left_half) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right_half):</span><br><span class="line">            <span class="keyword">if</span> left_half[i] &lt; right_half[j]:</span><br><span class="line">                lst[k] = left_half[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lst[k] = right_half[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left_half):</span><br><span class="line">            lst[k] = left_half[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(right_half):</span><br><span class="line">            lst[k] = right_half[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure>
<p>其中，参数 lst 是一个待排序的列表，函数返回一个新的已排序的列表。函数首先将待排序序列不断地对半分割，直到每个子序列只有一个元素，然后将相邻的子序列进行合并，形成新的有序子序列，直到最终只剩下一个有序序列为止。在合并操作中，需要额外的一个数组来存储已经排序好的元素，最后再将排序好的元素复制回原数组。</p>
<h5 id="326-快速排序"><a class="markdownIt-Anchor" href="#326-快速排序"></a> 3.2.6 快速排序</h5>
<p>快速排序（Quick Sort）是一种常见的排序算法，它采用分治思想将待排序序列分成两个子序列，一部分小于基准元素，一部分大于基准元素。然后对这两个子序列分别进行递归排序，最终得到一个有序序列。</p>
<p>快速排序的基本思想是选定一个基准元素，然后通过一趟排序将待排序序列分成两部分，使得左边的子序列都小于基准元素，右边的子序列都大于基准元素，然后分别对左右两部分递归地进行快速排序，最终得到一个有序序列。</p>
<img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%BF%AB%E9%80%9F.gif" class="" title="sucessful">
<p>以下是使用 Python 实现的快速排序代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">lst, left, right</span>):</span><br><span class="line">    <span class="keyword">if</span> left &lt; right:</span><br><span class="line">        pivot_index = partition(lst, left, right)</span><br><span class="line">        quick_sort(lst, left, pivot_index - <span class="number">1</span>)</span><br><span class="line">        quick_sort(lst, pivot_index + <span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">lst, left, right</span>):</span><br><span class="line">    pivot = lst[left]</span><br><span class="line">    i, j = left + <span class="number">1</span>, right</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">while</span> i &lt;= j <span class="keyword">and</span> lst[i] &lt; pivot:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j <span class="keyword">and</span> lst[j] &gt;= pivot:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &lt;= j:</span><br><span class="line">            lst[i], lst[j] = lst[j], lst[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    lst[left], lst[j] = lst[j], lst[left]</span><br><span class="line">    <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure>
<p>其中，参数 lst 是一个待排序的列表，参数 left 和 right 是列表的左右边界，函数使用递归的方式实现快速排序。在递归的过程中，首先选定一个基准元素，然后通过 partition 函数将待排序序列分成两部分。partition 函数使用双指针的方式将待排序序列分成两部分，左边部分的元素都小于基准元素，右边部分的元素都大于等于基准元素。最后，将基准元素放在分界点上，返回分界点的位置。然后分别对左右两部分递归地进行快速排序，最终得到一个有序序列。</p>
<h3 id="4-树"><a class="markdownIt-Anchor" href="#4-树"></a> 4. 树</h3>
<p>不多介绍，直接看实现与算法</p>
<h4 id="41-树的实现"><a class="markdownIt-Anchor" href="#41-树的实现"></a> 4.1 树的实现</h4>
<h5 id="411-实现方法1列表之列表"><a class="markdownIt-Anchor" href="#411-实现方法1列表之列表"></a> 4.1.1 实现方法1：列表之列表</h5>
<p>例如，a为根节点，有子节点b，c，节点b又有子节点d（左），则使用列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a,[b,[d,[],[]],[]],[c,[],[]]]</span><br></pre></td></tr></table></figure>
<p>不说了，这方法真的会有人用吗</p>
<h5 id="412-实现方法2节点与引用"><a class="markdownIt-Anchor" href="#412-实现方法2节点与引用"></a> 4.1.2 实现方法2：节点与引用</h5>
<p>基础类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,rootObj</span>):</span><br><span class="line">		self.key=rootObj</span><br><span class="line">		self.leftChild=<span class="literal">None</span></span><br><span class="line">		self.rightChild=<span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>插入左节点（如果已经存在左子节点，插入时要把原先的左子节点降一层，自己到那个位置）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">instertLeft</span>(<span class="params">self,newNode</span>):</span><br><span class="line">	<span class="keyword">if</span>(self.leftChild==<span class="literal">None</span>):</span><br><span class="line">		self.leftChild=BinaryTree(newNode)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		t=BinaryTree(newNode)</span><br><span class="line">		t.leftChild=self.leftChild</span><br><span class="line">		self.leftChild=t</span><br></pre></td></tr></table></figure>
<p>右子节点也一样。<br />
访问函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getRightChild</span>(<span class="params">self</span>):</span><br><span class="line">	<span class="keyword">return</span> self.rightChild</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getLeftChild</span>(<span class="params">self</span>):</span><br><span class="line">	<span class="keyword">return</span> self.LeftChild</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setRootVal</span>(<span class="params">self,obj</span>):</span><br><span class="line">	self.key=obj</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getRootVal</span>(<span class="params">self</span>):</span><br><span class="line">	<span class="keyword">return</span> self.key</span><br></pre></td></tr></table></figure>
<h4 id="42-树的遍历"><a class="markdownIt-Anchor" href="#42-树的遍历"></a> 4.2 树的遍历</h4>
<p>树的遍历方式分为三种：前序遍历、中序遍历、后序遍历</p>
<h5 id="421-前序遍历"><a class="markdownIt-Anchor" href="#421-前序遍历"></a> 4.2.1 前序遍历</h5>
<p>先访问根节点，然后递归地前序遍历左子树，最后递归地前序遍历右子树</p>
<img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%89%8D%E5%BA%8F.gif" class="" title="sucessful">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">tree</span>):</span><br><span class="line">	<span class="keyword">if</span> tree:</span><br><span class="line">		<span class="built_in">print</span>(tree.getRootVal())</span><br><span class="line">		preorder(tree.getLeftChild())</span><br><span class="line">		preorder(tree.getRightChild())</span><br></pre></td></tr></table></figure>
<h5 id="422-中序遍历"><a class="markdownIt-Anchor" href="#422-中序遍历"></a> 4.2.2 中序遍历</h5>
<p>先递归地中序遍历左子树，然后访问根节点，在中序遍历右子树</p>
<img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E4%B8%AD%E5%BA%8F.gif" class="" title="sucessful">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">tree</span>):</span><br><span class="line">	<span class="keyword">if</span> tree:</span><br><span class="line">		inorder(tree.getLeftChild())</span><br><span class="line">		<span class="built_in">print</span>(tree.getRootVal())</span><br><span class="line">		inorder(tree.getRightChild())</span><br></pre></td></tr></table></figure>
<h5 id="423-后序遍历"><a class="markdownIt-Anchor" href="#423-后序遍历"></a> 4.2.3 后序遍历</h5>
<p>先递归地后序遍历右子树，然后递归地后序遍历左子树，最后访问根节点</p>
<img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%90%8E%E5%BA%8F.gif" class="" title="sucessful">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">postorder</span>(<span class="params">tree</span>):</span><br><span class="line">	<span class="keyword">if</span> tree:</span><br><span class="line">		postorder(tree.getLeftChild())</span><br><span class="line">		postorder(tree.getRightChild())</span><br><span class="line">		<span class="built_in">print</span>(tree.getRootVal())</span><br></pre></td></tr></table></figure>
<h4 id="43-利用二叉堆实现优先级队列"><a class="markdownIt-Anchor" href="#43-利用二叉堆实现优先级队列"></a> 4.3 利用二叉堆实现优先级队列</h4>
<p>二叉堆（binary heap）是一种特殊的二叉树数据结构，它可以用数组来实现，并且常用于实现优先队列。</p>
<p>二叉堆分为最大堆和最小堆两种类型。最大堆满足任何一个父节点的键值大于等于它的任何一个子节点的键值；最小堆则满足任何一个父节点的键值小于等于它的任何一个子节点的键值。因此，最大堆的堆顶是堆中的最大元素，最小堆的堆顶是堆中的最小元素。</p>
<p>二叉堆的数组实现中，数组的第一个元素是根节点，数组的下标从1开始（而不是0）。对于第i个节点，它的左子节点在2i的位置，右子节点在2i+1的位置，父节点在i/2的位置（向下取整）。</p>
<p>二叉堆的主要操作包括插入一个元素、删除堆顶元素和查找堆顶元素。插入一个元素需要将元素插入到堆的最后一个位置，然后通过向上逐级比较交换，将新元素移动到合适的位置以维护堆的性质。删除堆顶元素需要将堆顶元素与堆中最后一个元素交换位置，然后删除最后一个元素，并通过向下逐级比较交换，将堆顶元素移动到合适的位置以维护堆的性质。查找堆顶元素只需要返回数组的第一个元素。</p>
<h5 id="431-二叉堆的实现"><a class="markdownIt-Anchor" href="#431-二叉堆的实现"></a> 4.3.1 二叉堆的实现</h5>
<p>在实现二叉堆时，我们通过创建一颗完全二叉树来维持树的平衡。在完全二叉树中，除了最底层，其他每一层的节点都是满的。在对底层，从左往右填充节点。</p>
<p>完全二叉树的特殊之处在于，可以用一个列表来表示它。<br />
完全二叉树节点在列表中的排序为：从上而下，从左往右。<br />
按此排布，对于在列表中位置p的节点来说，其左子节点的位置为2p，右子节点的位置为2p+1（请读者自行推算一遍）</p>
<p>二叉堆的实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">	self.heapList=[<span class="number">0</span>]</span><br><span class="line">	self.currentSize=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>对于一个要求子节点大于父节点的堆来说，插入的最简单、最高效的方法就是将元素追加到列表的末尾，然后和其父节点比较，若小于其父节点，就对换位置。此处代码不再给出，简单来说就是比较插入的第i个和父节点第i//2个对比。</p>
<p>二叉堆还有一个功能，删除最小元素（即根节点），但是删除后，需要对堆进行重建。重建方法为：</p>
<ol>
<li>取出列表中最后一个元素，将其放在根节点的位置</li>
<li>通过与子节点之间的交换，将新的根节点沿着树推到正确的位置</li>
</ol>
<h4 id="44-二叉搜索树"><a class="markdownIt-Anchor" href="#44-二叉搜索树"></a> 4.4 二叉搜索树</h4>
<p>二叉搜索树依赖于这样的性质：小于父节点的键都在左子树中，大于父节点的键则都在右子树中。</p>
<h5 id="441-插入"><a class="markdownIt-Anchor" href="#441-插入"></a> 4.4.1 插入</h5>
<p>根据性质，插入算法为：</p>
<ol>
<li>从根节点开始搜索二叉树，比较新键与当前节点的键，如果新键更小，搜索左子树，如果新键更大，搜索右子树</li>
<li>当没有可供搜索的左/右字节点时，说明找到了正确的位置。</li>
<li>创建一个TreeNode对象，并将其插入到前一步发现的位置上。</li>
</ol>
<p>下面是一个利用递归方法实现的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.root:</span><br><span class="line">            self.root = Node(val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._insert(val, self.root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_insert</span>(<span class="params">self, val, node</span>):</span><br><span class="line">        <span class="keyword">if</span> val &lt; node.val:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left:</span><br><span class="line">                node.left = Node(val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self._insert(val, node.left)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                node.right = Node(val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self._insert(val, node.right)</span><br></pre></td></tr></table></figure>
<h5 id="442-查找"><a class="markdownIt-Anchor" href="#442-查找"></a> 4.4.2 查找</h5>
<p>相似的，查找的方法为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, val</span>):</span><br><span class="line">    node = self.root</span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        <span class="keyword">if</span> node.val == val:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        <span class="keyword">elif</span> val &lt; node.val:</span><br><span class="line">            node = node.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = node.right</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h5 id="443-删除"><a class="markdownIt-Anchor" href="#443-删除"></a> 4.4.3 删除</h5>
<p>删除的情况就相对复杂。</p>
<ol>
<li>要删除的节点是叶子节点，也就是没有左右子节点的节点。在这种情况下，可以直接删除该节点，将其父节点的左子节点或右子节点指向 None。</li>
<li>要删除的节点只有一个子节点，可以将该节点的子节点替换为该节点。</li>
<li>要删除的节点有两个子节点。在这种情况下，可以将该节点的左子树的最大节点或右子树的最小节点替换该节点。（因为左子树的最大节点或右子树的最小节点正好可以填进去）</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span>:</span><br><span class="line">    <span class="comment"># 省略插入方法和查找方法...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, val</span>):</span><br><span class="line">        node, parent = self.search_with_parent(val)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 未找到要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">or</span> <span class="keyword">not</span> node.right:  <span class="comment"># 第一种和第二种情况</span></span><br><span class="line">            child = node.left <span class="keyword">or</span> node.right</span><br><span class="line">            <span class="keyword">if</span> parent:</span><br><span class="line">                <span class="keyword">if</span> node == parent.left:</span><br><span class="line">                    parent.left = child</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    parent.right = child</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.root = child</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 第三种情况</span></span><br><span class="line">            succ = node.right</span><br><span class="line">            <span class="keyword">while</span> succ.left:</span><br><span class="line">                succ = succ.left</span><br><span class="line">            node.val = succ.val</span><br><span class="line">            <span class="keyword">if</span> succ == node.right:</span><br><span class="line">                node.right = succ.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = self.search_with_parent(succ.val)[<span class="number">1</span>]</span><br><span class="line">                p.left = succ.right</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h4 id="45-平衡二叉搜索树"><a class="markdownIt-Anchor" href="#45-平衡二叉搜索树"></a> 4.5 平衡二叉搜索树</h4>
<p>这个真太烦了，我不高兴看了T.T</p>
<h4 id="46-霍夫曼树"><a class="markdownIt-Anchor" href="#46-霍夫曼树"></a> 4.6 霍夫曼树</h4>
<p>霍夫曼树（Huffman Tree）是一种带权路径最短的树，通常用于数据压缩。它的构建过程基于贪心算法，根据数据频率构建一棵无损压缩的树。具体来说，给定一组数据和对应的权值，霍夫曼树的构建过程如下：</p>
<ol>
<li>对所有的数据按照权值从小到大排序，每个数据作为一个单独的节点。</li>
<li>每次从排序后的节点中选取权值最小的两个节点，将它们合并为一个新节点，新节点的权值为两个节点的权值之和，左子节点为权值较小的节点，右子节点为权值较大的节点。</li>
<li>将新节点插入到排序后的节点列表中，并删除原来的两个节点。</li>
<li>重复步骤2和3，直到只剩下一个节点为止，该节点即为霍夫曼树的根节点。</li>
</ol>
<img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%93%88%E5%A4%AB%E6%9B%BC.gif" class="" title="sucessful style&#x3D;display: block; margin: 0 auto; max-width: 50%;">
<p>下面是一个Python实现示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HuffmanNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value, weight</span>):</span><br><span class="line">        self.value = value</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_huffman_tree</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="comment"># 构建叶子节点列表</span></span><br><span class="line">    nodes = [HuffmanNode(val, weight) <span class="keyword">for</span> val, weight <span class="keyword">in</span> data]</span><br><span class="line">    <span class="comment"># 构建霍夫曼树</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(nodes) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># 按权值排序</span></span><br><span class="line">        nodes.sort(key=<span class="keyword">lambda</span> node: node.weight)</span><br><span class="line">        <span class="comment"># 取出权值最小的两个节点</span></span><br><span class="line">        left_node = nodes.pop(<span class="number">0</span>)</span><br><span class="line">        right_node = nodes.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 构建新节点</span></span><br><span class="line">        new_weight = left_node.weight + right_node.weight</span><br><span class="line">        new_node = HuffmanNode(<span class="literal">None</span>, new_weight)</span><br><span class="line">        new_node.left = left_node</span><br><span class="line">        new_node.right = right_node</span><br><span class="line">        <span class="comment"># 将新节点加入节点列表中</span></span><br><span class="line">        nodes.append(new_node)</span><br><span class="line">    <span class="comment"># 返回根节点</span></span><br><span class="line">    <span class="keyword">return</span> nodes[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>在这个实现中，我们先定义了一个<code>HuffmanNode</code>类，表示霍夫曼树中的节点。每个节点包含一个<code>value</code>属性表示节点的值（如果节点是叶子节点，则为原始数据），一个<code>weight</code>属性表示节点的权值，以及左子节点和右子节点。我们还定义了一个<code>build_huffman_tree(data)</code>函数，用于构建霍夫曼树。<code>data</code>参数是一个二元组列表，每个二元组包含一个数据和对应的权值。函数返回霍夫曼树的根节点。</p>
<p>在构建完霍夫曼树后，我们可以通过对树进行遍历来获得每个数据的编码。具体来说，我们可以对树进行先序遍历，在遍历过程中，记录每个叶子节点的编码（0表示向左走，1表示向右走）。最终得到的编码就是霍夫曼编码，可以用于数据压缩。</p>
<p>例如，如果一个数据出现的频率很高，代表着他权值很高，我们可以用一个比较短的编码来表示它，比如说用一个1位的编码表示它。而如果一个数据出现的频率很低，我们可以用一个比较长的编码来表示它，比如说用一个10位的编码表示它。这样，在对数据进行编码后，数据的存储空间就会减少。</p>
<h3 id="5-图"><a class="markdownIt-Anchor" href="#5-图"></a> 5. 图</h3>
<p>下面先回顾一下图中的术语以及定义：</p>
<ol>
<li>顶点（vertex）：也称为节点，表示图中的一个点，通常用一个唯一的标识符来标识。</li>
<li>边（edge）：表示两个顶点之间的连线，可以是有向或无向的，可以有权重或无权重。</li>
<li>权重（weight）：如果边带有数值，则称这个数值为边的权重。</li>
<li>路径（path）：表示从一个顶点到另一个顶点依次经过的边和顶点的序列，路径的长度为路径上所有边的权重之和。</li>
<li>环（cycle）：表示一个顶点经过一系列边回到自身的路径。</li>
<li>连通（connected）：如果图中的任意两个顶点都有一条路径相连，则称该图是连通的。</li>
<li>连通分量（connected component）：无向图中每个连通的部分称为一个连通分量。</li>
<li>强连通（strongly connected）：如果有向图中的任意两个顶点都有互相到达的路径，则称该图是强连通的。</li>
<li>强连通分量（strongly connected component）：有向图中每个强连通的部分称为一个强连通分量。</li>
<li>入度（in-degree）：有向图中指向一个顶点的边的数量。</li>
<li>出度（out-degree）：有向图中从一个顶点出发的边的数量。</li>
<li>邻接点（adjacent vertex）：与一个顶点直接相连的顶点称为它的邻接点。</li>
<li>邻接矩阵（adjacency matrix）：用矩阵来表示图中每个顶点之间的连通关系，其中矩阵中的行和列分别代表图中的顶点，矩阵中的元素表示两个顶点之间是否有连通关系。</li>
<li>邻接表（adjacency list）：用链表来表示图中每个顶点的邻接点列表，链表中的每个节点表示一个邻接点。</li>
</ol>
<h4 id="51-图的抽象数据类型以及其实现"><a class="markdownIt-Anchor" href="#51-图的抽象数据类型以及其实现"></a> 5.1 图的抽象数据类型以及其实现</h4>
<h5 id="511-邻接矩阵"><a class="markdownIt-Anchor" href="#511-邻接矩阵"></a> 5.1.1 邻接矩阵</h5>
<p>只是一个矩阵，不多赘述</p>
<h5 id="512-邻接表"><a class="markdownIt-Anchor" href="#512-邻接表"></a> 5.1.2 邻接表</h5>
<p>python中，字典的键值对可以有效地实现图的边。下面是一个示例，利用字典connectedTo来记录与节点Vertex相邻的点。</p>
<p>以下给出一个节点类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,key</span>):</span><br><span class="line">		self.<span class="built_in">id</span>=key</span><br><span class="line">		self.connectedTo=&#123;&#125;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">addNeighbor</span>(<span class="params">self,nbr,weight=<span class="number">0</span></span>):</span><br><span class="line">		self.connectefTo(nbr)=weight</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">str</span>(self.<span class="built_in">id</span>)+<span class="string">&#x27; connectedTo: &#x27;</span>+<span class="built_in">str</span>([x.<span class="built_in">id</span> <span class="keyword">for</span> x <span class="keyword">in</span> self.connectedTo])</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">getConnections</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="comment">#通过获取所有键，获取节点所有相接的顶点名</span></span><br><span class="line">		<span class="keyword">return</span> self.connectedTo.keys()</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">getId</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> self.<span class="built_in">id</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">getWeight</span>(<span class="params">self,nbr</span>):</span><br><span class="line">		<span class="keyword">return</span> self.connectedTo[nbr]</span><br></pre></td></tr></table></figure>
<p>Graph类就不再赘述，只需要特别注意两个功能：添加顶点，添加边</p>
<h4 id="52-广度优先搜索bfs"><a class="markdownIt-Anchor" href="#52-广度优先搜索bfs"></a> 5.2 广度优先搜索（BFS）</h4>
<p>要求边的权值都为0！！！！！！</p>
<p>BFS，即广度优先搜索（Breadth-First Search），是一种图的遍历算法，用于在图中搜索特定的节点或路径。BFS从给定的起始节点开始遍历图，首先访问起始节点的所有邻居节点，然后按照遍历的深度依次访问下一层节点，直到遍历完整张图或找到目标节点为止。</p>
<p>BFS通常借助队列（Queue）数据结构来实现。首先将起始节点加入队列中，然后不断从队列中取出最早进入队列的节点，并将其邻居节点加入队列中（如果之前取过了，则不取），并计算节点到起始节点的距离（父节点到起始节点的距离+1）直到队列为空或找到目标节点为止。</p>
<img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.gif" class="" title="sucessful style&#x3D;display: block; margin: 0 auto; max-width: 50%;">
<p>下面是一个实现的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pythonds.graphs <span class="keyword">import</span> Graph, Vertex</span><br><span class="line"><span class="keyword">from</span> pythonds.basic <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">BFS</span>(<span class="params">g,start,end</span>):</span><br><span class="line">	<span class="comment">#储存据起始节点距离</span></span><br><span class="line">	distance=&#123;&#125;</span><br><span class="line">	distance[start]=<span class="number">0</span></span><br><span class="line">	<span class="comment">#储存是否有被访问过</span></span><br><span class="line">	visited=[]</span><br><span class="line">	<span class="comment">#队列</span></span><br><span class="line">	queue=Queue()</span><br><span class="line">	queue.enqueue(start)</span><br><span class="line">	<span class="comment">#创建字典，用于记录每个节点的父节点，用于回溯路径</span></span><br><span class="line">	parent = &#123;&#125; </span><br><span class="line">	<span class="keyword">while</span>(!queue.size==<span class="number">0</span>):</span><br><span class="line">		<span class="comment">#currentq：当前访问到的节点，名字起错了，不想改了</span></span><br><span class="line">		currentq=queue.dequeue()</span><br><span class="line">		<span class="keyword">if</span>(currentq==end):</span><br><span class="line">			<span class="comment">#回溯打印</span></span><br><span class="line">			<span class="keyword">while</span>(!currentq==start):</span><br><span class="line">				<span class="built_in">print</span>(currentq.<span class="built_in">id</span>)</span><br><span class="line">				currentq=parent[currentq]</span><br><span class="line">			<span class="built_in">print</span>(start.<span class="built_in">id</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">			</span><br><span class="line">		<span class="keyword">for</span> item <span class="keyword">in</span> currentq.connectedTo:</span><br><span class="line">			<span class="keyword">if</span>(item <span class="keyword">not</span> <span class="keyword">in</span> visited):</span><br><span class="line">				visited.appenf(item)</span><br><span class="line">				queue.enqueue(item)</span><br><span class="line">				distance[item]=distance[current]+<span class="number">1</span></span><br><span class="line">				parent[item]=currentq</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">False</span>	</span><br></pre></td></tr></table></figure>
<h4 id="53-深度优先搜索"><a class="markdownIt-Anchor" href="#53-深度优先搜索"></a> 5.3 深度优先搜索</h4>
<p>深度优先搜索（Depth-First-Search, DFS）是一种用于遍历或搜索树或图的算法，其主要思想是从起点开始，不断往深度方向搜索，直到找到目标节点或者无法继续为止，然后返回上一层节点，继续搜索其他未被访问过的节点。</p>
<p>递归式的DFS可以通过递归调用实现。具体实现过程如下：</p>
<ol>
<li>创建一个visited数组，用于记录每个节点是否被访问过，初始值都为False。</li>
<li>定义DFS函数，输入参数为当前节点和图的邻接表表示。首先标记当前节点为已访问，并输出当前节点。然后遍历当前节点的邻居节点，对于每个未被访问过的邻居节点，递归调用DFS函数。</li>
<li>在主函数中遍历图中的每个节点，对于每个未被访问过的节点，调用DFS函数。</li>
</ol>
<p>以下是Python实现代码示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">currentVertex, visited</span>)<span class="comment">#当前访问的节点，已经访问过的节点列表</span></span><br><span class="line">	visited[currentVertex]=<span class="literal">True</span></span><br><span class="line">	<span class="built_in">print</span>(currentVertex.<span class="built_in">id</span>)</span><br><span class="line">	<span class="keyword">for</span> item <span class="keyword">in</span> currentVertex.connectedTo:</span><br><span class="line">		<span class="keyword">if</span>(item <span class="keyword">not</span> <span class="keyword">in</span> visited):</span><br><span class="line">			DFS(currentVertex,visited)</span><br></pre></td></tr></table></figure>
<h4 id="54-最短路径"><a class="markdownIt-Anchor" href="#54-最短路径"></a> 5.4 最短路径</h4>
<h5 id="541-dijkstra算法"><a class="markdownIt-Anchor" href="#541-dijkstra算法"></a> 5.4.1 Dijkstra算法</h5>
<p>Dijkstra算法是一种用于求解单源最短路径的贪心算法，它能够计算出从一个源点到图中其他所有点的最短路径。算法的基本思想是维护一个到源点的距离数组，每次选取一个距离最短的点进行松弛操作（通过更新边来减小从起点到顶点的距离），更新其他节点到源点的距离值。当所有节点都被更新后，最短路径就求解完成。</p>
<p>以下是使用Python实现Dijkstra算法的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个函数用于实现Dijkstra算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dijkstra</span>(<span class="params">graph, start</span>):</span><br><span class="line">    <span class="comment"># 初始化距离字典，所有节点的距离值默认为无限大</span></span><br><span class="line">    dist = &#123;node: <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125;</span><br><span class="line">    <span class="comment"># 将起点的距离值初始化为0</span></span><br><span class="line">    dist[start] = <span class="number">0</span></span><br><span class="line">    ……<span class="comment">#初始化距离字典</span></span><br><span class="line">    <span class="comment"># 初始化路径字典</span></span><br><span class="line">    path = &#123;start: []&#125;</span><br><span class="line">    <span class="comment"># 将起点放入已访问节点集合中</span></span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 从未访问节点中找到距离起点最近的节点</span></span><br><span class="line">        min_node = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> graph:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">if</span> min_node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    min_node = node</span><br><span class="line">                <span class="keyword">elif</span> dist[node] &lt; dist[min_node]:</span><br><span class="line">                    min_node = node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> min_node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将该节点标记为已访问</span></span><br><span class="line">        visited.add(min_node)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新所有与该节点相邻的节点的距离值</span></span><br><span class="line">        <span class="keyword">for</span> neighbor, weight <span class="keyword">in</span> graph[min_node].items():</span><br><span class="line">            <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                new_dist = dist[min_node] + weight</span><br><span class="line">                <span class="keyword">if</span> new_dist &lt; dist[neighbor]:</span><br><span class="line">                    dist[neighbor] = new_dist</span><br><span class="line">                    path[neighbor] = path[min_node] + [min_node]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist, path</span><br></pre></td></tr></table></figure>
<h5 id="542-prim算法"><a class="markdownIt-Anchor" href="#542-prim算法"></a> 5.4.2 Prim算法</h5>
<p>Prim算法是一种用于解决最小生成树问题的贪心算法。其基本思路是从一个起点开始，不断扩展生成树，每次加入距离已有部分最近的一个点，直到所有点都被加入为止。</p>
<p>具体步骤如下：</p>
<ol>
<li>初始化一个空的生成树，以一个节点作为起始节点；</li>
<li>找到与生成树相邻的边中，权值最小的那条边，将其连接的点加入生成树中；</li>
<li>重复第二步，直到所有节点都加入生成树中。</li>
</ol>
<p>该算法可以借助优先级队列来实现（Dijkstra算法也可以，但我没用），优先级队列可以弹出包含最小元素的字典。</p>
<p>下面是一个python实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pythonds.graphs <span class="keyword">import</span> PriorityQueue, Graph, Vertex</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Prim</span>(<span class="params">G, start</span>):</span><br><span class="line">	pq=PriorityQueue()</span><br><span class="line">	<span class="keyword">for</span> v <span class="keyword">in</span> G:</span><br><span class="line">		v.setDistance(sys.maxsize)<span class="comment">#设置和起始点的距离</span></span><br><span class="line">		v.setPred(<span class="literal">None</span>)<span class="comment">#设置前驱结点</span></span><br><span class="line">	start.SetDistance(<span class="number">0</span>)</span><br><span class="line">	<span class="comment">#创建一个堆，存放河节点的相邻节点</span></span><br><span class="line">	pq.buildHeap([(v.getDistance, v) <span class="keyword">for</span> v <span class="keyword">in</span> G])</span><br><span class="line">	<span class="keyword">while</span> <span class="keyword">not</span> pq.isEmpty():</span><br><span class="line">		<span class="comment">#取出最小的起始点的相邻节点</span></span><br><span class="line">		currentVert=pq.delMin()</span><br><span class="line">		<span class="comment">#遍历该节点的所有相邻节点</span></span><br><span class="line">		<span class="keyword">for</span> nextVert <span class="keyword">in</span> currentVert.getConnections():</span><br><span class="line">			<span class="comment">#新的距离=节点currentVert和原点的距离+当前节点和currentVert的距离</span></span><br><span class="line">			newCost=currentVert.getWeight(nextVert)+currentVert.getDistance()</span><br><span class="line">			<span class="comment">#如果新生成的路径长度比原来的短</span></span><br><span class="line">			<span class="keyword">if</span> v <span class="keyword">in</span> pq <span class="keyword">and</span> newCost&lt;nextVert.getDistance():</span><br><span class="line">				nextVert.setPred(currentVert)</span><br><span class="line">				nextVert.setDistance(newCost)</span><br><span class="line">				pq.decreaseKey(nextVert,newCost)</span><br></pre></td></tr></table></figure>
<h3 id="6-python基础复习"><a class="markdownIt-Anchor" href="#6-python基础复习"></a> 6. python基础复习</h3>
<h4 id="61-python基础库"><a class="markdownIt-Anchor" href="#61-python基础库"></a> 6.1 python基础库</h4>
<ol>
<li>队列：queue，入队和出队的方法分别是put()和get()，empty(): 判断队列是否为空。qsize(): 返回队列中当前的元素个数。</li>
<li>栈：Python 中没有专门表示栈的基础库，但是可以使用内置的 list类来实现栈的功能，因为list 的 append() 和 pop()方法可以分别实现入栈和出栈操作。</li>
</ol>
<h4 id="62-基础函数"><a class="markdownIt-Anchor" href="#62-基础函数"></a> 6.2 基础函数</h4>
<h5 id="621-列表基础函数"><a class="markdownIt-Anchor" href="#621-列表基础函数"></a> 6.2.1 列表基础函数</h5>
<ol>
<li>append：在列表末尾添加一个元素，例如：<code>list.append(item)</code></li>
<li>extend：将一个列表中的所有元素添加到另一个列表末尾，例如：<code>list.extend(another_list)</code></li>
<li>insert：在列表的指定位置插入一个元素，例如：<code>list.insert(index, item)</code></li>
<li>remove：删除列表中指定的元素，例如：<code>list.remove(item)</code></li>
<li>pop：从列表中删除指定位置的元素，并返回该元素，例如：<code>list.pop(index)</code></li>
<li>index：返回列表中指定元素的索引位置，例如：<code>list.index(item)</code></li>
<li>count：返回列表中指定元素出现的次数，例如：<code>list.count(item)</code></li>
<li>sort：对列表中的元素进行排序，例如：<code>list.sort()</code></li>
<li>reverse：将列表中的元素反向排序，例如：<code>list.reverse()</code></li>
<li>clear：从列表中删除所有元素，例如：<code>list.clear()</code></li>
<li>构建二维数组：Sum=[[0 for i in range(n)]for j in range(m)]</li>
</ol>
<h5 id="622-字典基础函数"><a class="markdownIt-Anchor" href="#622-字典基础函数"></a> 6.2.2 字典基础函数</h5>
<ol>
<li>dict()：创建一个新字典</li>
<li>len(dict)：返回字典中键值对的数量</li>
<li>dict[key]：获取字典中指定键的值</li>
<li>dict[key] = value：设置字典中指定键的值</li>
<li>del dict[key]：从字典中删除指定键</li>
<li>key in dict：检查字典中是否包含指定键</li>
<li>dict.keys()：返回一个包含字典所有键的列表</li>
<li>dict.values()：返回一个包含字典所有值的列表</li>
<li>dict.items()：返回一个包含字典所有键值对的列表</li>
<li>dict.get(key, default)：获取字典中指定键的值，如果键不存在返回默认值</li>
<li>dict.setdefault(key, default)：获取字典中指定键的值，如果键不存在设置默认值并返回</li>
<li>dict.pop(key, default)：从字典中删除指定键，并返回其对应的值。如果键不存在返回默认值</li>
<li>dict.update(other_dict)：使用其他字典中的键值对来更新当前字典</li>
</ol>
<h5 id="623-map-filter函数"><a class="markdownIt-Anchor" href="#623-map-filter函数"></a> 6.2.3 map、filter函数</h5>
<p><code>map()</code> 是 Python 内置的一个高阶函数，它将一个函数作用于一个或多个可迭代对象的每个元素上，并返回一个可迭代对象（迭代器），其中包含应用函数后的结果。</p>
<p><code>map()</code> 函数的语法如下，下面是一个简单的例子，将一个列表中的每个元素乘以 2：：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">double</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">doubled_numbers = <span class="built_in">list</span>(<span class="built_in">map</span>(double, numbers))</span><br><span class="line"><span class="built_in">print</span>(doubled_numbers)  <span class="comment"># [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>double()</code> 函数接收一个参数并返回该参数的两倍。<code>map()</code> 函数将 <code>double()</code> 应用于 <code>numbers</code> 列表中的每个元素，并返回一个迭代器，其中包含应用函数后的结果。<code>list()</code> 函数将迭代器转换为一个列表，最终输出 <code>[2, 4, 6, 8, 10]</code>。</p>
<p><code>filter</code>函数：对一个可迭代对象中的元素进行过滤，返回满足条件的元素组成的新的可迭代对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_even</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">return</span> num % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">even_nums = <span class="built_in">filter</span>(is_even, nums)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(even_nums))  <span class="comment"># [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure>
<h5 id="624-字符串函数"><a class="markdownIt-Anchor" href="#624-字符串函数"></a> 6.2.4 字符串函数</h5>
<ol>
<li>len()：获取字符串的长度。</li>
<li>strip()：去掉字符串开头和结尾的空格。</li>
<li>split()：按照指定的分隔符将字符串分割成列表。</li>
<li>join()：将列表或元组中的字符串拼接成一个字符串，中间用指定的字符隔开。</li>
<li>replace()：将字符串中指定的子字符串替换为另一个字符串。</li>
<li>find()：查找指定的子字符串在字符串中的位置，返回第一个匹配到的位置。</li>
<li>lower()和upper()：分别将字符串转换成小写和大写。</li>
<li>startswith()和endswith()：判断字符串是否以指定的字符串开头或结尾。</li>
<li>isdigit()、isalpha()和isalnum()：判断字符串是否全部由数字、字母或数字字母组成。</li>
<li>format()：将指定的值格式化到字符串中。</li>
<li>list()：转化为一个列表</li>
</ol>
<p>示例：join的用法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">words = [<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;awesome&#x27;</span>]</span><br><span class="line">sep = <span class="string">&#x27; &#x27;</span></span><br><span class="line">sentence = sep.join(words)</span><br><span class="line"><span class="built_in">print</span>(sentence) <span class="comment"># 输出：Python is awesome</span></span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/07/06/JS%E5%AE%9E%E7%8E%B0%E5%9C%B0%E7%90%86%E6%B5%81%E5%8F%AF%E8%A7%86%E5%8C%96/" rel="prev" title="JS实现地理流可视化">
      <i class="fa fa-chevron-left"></i> JS实现地理流可视化
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/09/11/%E7%99%BE%E5%BA%A6%E6%8C%87%E6%95%B0%E7%88%AC%E5%8F%96%E2%80%94%E2%80%94%E4%B8%8D%E5%90%8C%E5%9F%8E%E5%B8%82%E5%AF%B9%E4%BA%8E%E5%90%84%E7%B1%BB%E5%85%B3%E9%94%AE%E8%AF%8D%E6%90%9C%E7%B4%A0%E9%87%8F%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/" rel="next" title="百度指数爬取">
      百度指数爬取 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text"> 1. 基础数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-%E6%A0%88"><span class="nav-number">1.1.</span> <span class="nav-text"> 1.1 栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-a%E9%98%9F%E5%88%97"><span class="nav-number">1.2.</span> <span class="nav-text"> 1.2 a.队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-b%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="nav-number">1.3.</span> <span class="nav-text"> 1.2 b.双端队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-%E5%88%97%E8%A1%A8"><span class="nav-number">1.4.</span> <span class="nav-text"> 1.3 列表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#131%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%E9%93%BE%E8%A1%A8"><span class="nav-number">1.4.1.</span> <span class="nav-text"> 1.3.1无序列表：链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#132-%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8"><span class="nav-number">1.4.2.</span> <span class="nav-text"> 1.3.2 有序列表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%80%92%E5%BD%92"><span class="nav-number">2.</span> <span class="nav-text"> 2. 递归</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#21-%E8%BF%B7%E5%AE%AB%E6%90%9C%E7%B4%A2"><span class="nav-number">2.1.</span> <span class="nav-text"> 2.1 迷宫搜索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-%E6%B1%89%E8%AF%BA%E5%A1%94"><span class="nav-number">2.2.</span> <span class="nav-text"> 2.2 汉诺塔</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">2.3.</span> <span class="nav-text"> 2.3 动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#231-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">2.3.1.</span> <span class="nav-text"> 2.3.1 背包问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#232-%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98"><span class="nav-number">2.3.2.</span> <span class="nav-text"> 2.3.2 台阶问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%90%9C%E7%B4%A2%E4%B8%8E%E6%8E%92%E5%BA%8F"><span class="nav-number">3.</span> <span class="nav-text"> 3. 搜索与排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#31-%E6%90%9C%E7%B4%A2"><span class="nav-number">3.1.</span> <span class="nav-text"> 3.1 搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#311-%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2"><span class="nav-number">3.1.1.</span> <span class="nav-text"> 3.1.1 顺序搜索</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#312-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2"><span class="nav-number">3.1.2.</span> <span class="nav-text"> 3.1.2 二分搜索</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#313-%E6%95%A3%E5%88%97"><span class="nav-number">3.1.3.</span> <span class="nav-text"> 3.1.3 散列</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#32-%E6%8E%92%E5%BA%8F"><span class="nav-number">3.2.</span> <span class="nav-text"> 3.2 排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#321-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">3.2.1.</span> <span class="nav-text"> 3.2.1 冒泡排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#322-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">3.2.2.</span> <span class="nav-text"> 3.2.2 选择排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#323-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">3.2.3.</span> <span class="nav-text"> 3.2.3 插入排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#324-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-number">3.2.4.</span> <span class="nav-text"> 3.2.4 希尔排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#325-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">3.2.5.</span> <span class="nav-text"> 3.2.5 归并排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#326-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">3.2.6.</span> <span class="nav-text"> 3.2.6 快速排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%A0%91"><span class="nav-number">4.</span> <span class="nav-text"> 4. 树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#41-%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.1.</span> <span class="nav-text"> 4.1 树的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#411-%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%951%E5%88%97%E8%A1%A8%E4%B9%8B%E5%88%97%E8%A1%A8"><span class="nav-number">4.1.1.</span> <span class="nav-text"> 4.1.1 实现方法1：列表之列表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#412-%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%952%E8%8A%82%E7%82%B9%E4%B8%8E%E5%BC%95%E7%94%A8"><span class="nav-number">4.1.2.</span> <span class="nav-text"> 4.1.2 实现方法2：节点与引用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#42-%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">4.2.</span> <span class="nav-text"> 4.2 树的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#421-%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">4.2.1.</span> <span class="nav-text"> 4.2.1 前序遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#422-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">4.2.2.</span> <span class="nav-text"> 4.2.2 中序遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#423-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">4.2.3.</span> <span class="nav-text"> 4.2.3 后序遍历</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#43-%E5%88%A9%E7%94%A8%E4%BA%8C%E5%8F%89%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="nav-number">4.3.</span> <span class="nav-text"> 4.3 利用二叉堆实现优先级队列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#431-%E4%BA%8C%E5%8F%89%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.3.1.</span> <span class="nav-text"> 4.3.1 二叉堆的实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#44-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">4.4.</span> <span class="nav-text"> 4.4 二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#441-%E6%8F%92%E5%85%A5"><span class="nav-number">4.4.1.</span> <span class="nav-text"> 4.4.1 插入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#442-%E6%9F%A5%E6%89%BE"><span class="nav-number">4.4.2.</span> <span class="nav-text"> 4.4.2 查找</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#443-%E5%88%A0%E9%99%A4"><span class="nav-number">4.4.3.</span> <span class="nav-text"> 4.4.3 删除</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#45-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">4.5.</span> <span class="nav-text"> 4.5 平衡二叉搜索树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#46-%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="nav-number">4.6.</span> <span class="nav-text"> 4.6 霍夫曼树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%9B%BE"><span class="nav-number">5.</span> <span class="nav-text"> 5. 图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#51-%E5%9B%BE%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.1.</span> <span class="nav-text"> 5.1 图的抽象数据类型以及其实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#511-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="nav-number">5.1.1.</span> <span class="nav-text"> 5.1.1 邻接矩阵</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#512-%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="nav-number">5.1.2.</span> <span class="nav-text"> 5.1.2 邻接表</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#52-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2bfs"><span class="nav-number">5.2.</span> <span class="nav-text"> 5.2 广度优先搜索（BFS）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#53-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-number">5.3.</span> <span class="nav-text"> 5.3 深度优先搜索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#54-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">5.4.</span> <span class="nav-text"> 5.4 最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#541-dijkstra%E7%AE%97%E6%B3%95"><span class="nav-number">5.4.1.</span> <span class="nav-text"> 5.4.1 Dijkstra算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#542-prim%E7%AE%97%E6%B3%95"><span class="nav-number">5.4.2.</span> <span class="nav-text"> 5.4.2 Prim算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-python%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0"><span class="nav-number">6.</span> <span class="nav-text"> 6. python基础复习</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#61-python%E5%9F%BA%E7%A1%80%E5%BA%93"><span class="nav-number">6.1.</span> <span class="nav-text"> 6.1 python基础库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#62-%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0"><span class="nav-number">6.2.</span> <span class="nav-text"> 6.2 基础函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#621-%E5%88%97%E8%A1%A8%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0"><span class="nav-number">6.2.1.</span> <span class="nav-text"> 6.2.1 列表基础函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#622-%E5%AD%97%E5%85%B8%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0"><span class="nav-number">6.2.2.</span> <span class="nav-text"> 6.2.2 字典基础函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#623-map-filter%E5%87%BD%E6%95%B0"><span class="nav-number">6.2.3.</span> <span class="nav-text"> 6.2.3 map、filter函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#624-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="nav-number">6.2.4.</span> <span class="nav-text"> 6.2.4 字符串函数</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Fang Tianyao"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Fang Tianyao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:fty643737159@gmail.com" title="欢迎交流 E-Mail → mailto:fty643737159@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>欢迎交流 E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://geo.ecnu.edu.cn/" title="华东师范大学，地图学与地理信息系统 → https:&#x2F;&#x2F;geo.ecnu.edu.cn&#x2F;" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>华东师范大学，地图学与地理信息系统</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fang Tianyao</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">121k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:40</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  











<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":25,"vOffset":-30},"mobile":{"show":true},"react":{"opacity":0.9},"log":false});</script></body>
</html>
