<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|JetBrains Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"atffang.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="万字长文梳理JAVA线程方法的基础应用">
<meta property="og:type" content="article">
<meta property="og:title" content="从0开始学JAVA 4 JAVA线程方法汇总">
<meta property="og:url" content="https://atffang.github.io/2025/12/22/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/index.html">
<meta property="og:site_name" content="Tianyao&#39; s BLOG">
<meta property="og:description" content="万字长文梳理JAVA线程方法的基础应用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://atffang.github.io/2025/12/22/JAVA多线程方法汇总/线程的生命周期.png">
<meta property="article:published_time" content="2025-12-22T02:37:17.000Z">
<meta property="article:modified_time" content="2026-01-10T14:21:39.860Z">
<meta property="article:author" content="Fang Tianyao">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://atffang.github.io/2025/12/22/JAVA多线程方法汇总/线程的生命周期.png">

<link rel="canonical" href="https://atffang.github.io/2025/12/22/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>从0开始学JAVA 4 JAVA线程方法汇总 | Tianyao' s BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Tianyao' s BLOG" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Tianyao' s BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Tianyao</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://atffang.github.io/2025/12/22/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Fang Tianyao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tianyao' s BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          从0开始学JAVA 4 JAVA线程方法汇总
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-12-22 10:37:17" itemprop="dateCreated datePublished" datetime="2025-12-22T10:37:17+08:00">2025-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-01-10 22:21:39" itemprop="dateModified" datetime="2026-01-10T22:21:39+08:00">2026-01-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-java/" itemprop="url" rel="index"><span itemprop="name">编程学习-java</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>31k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>56 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>万字长文梳理JAVA线程方法的基础应用</p>
<span id="more"></span>
<h3 id="第一章多线程基础"><a class="markdownIt-Anchor" href="#第一章多线程基础"></a> 第一章：多线程基础</h3>
<p>在 Java 中，线程（Thread）是操作系统调度的最小单元。理解多线程，首先要从如何启动它、它经历过哪些状态、以及我们如何控制它开始。</p>
<h4 id="线程的创建方式"><a class="markdownIt-Anchor" href="#线程的创建方式"></a> 线程的创建方式</h4>
<p>虽然最终都是通过 <code>Thread.start()</code> 启动，但 Java 提供了<strong>三种主要的任务定义方式</strong>：</p>
<ul>
<li><strong>继承 <code>Thread</code> 类</strong>：
<ul>
<li><strong>做法</strong>：定义一个类继承 <code>Thread</code> 并重写 <code>run()</code> 方法。</li>
<li><strong>缺点</strong>：Java 是单继承的，继承了 Thread 就不能再继承其他类（如 BaseService），灵活性差。</li>
</ul>
</li>
</ul>
<p>我们直接new一个Tread类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;  </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">            <span class="built_in">super</span>.run();  </span><br><span class="line">            System.out.println(<span class="string">&quot;run: &quot;</span> + <span class="built_in">this</span>.getState());</span><br><span class="line">              </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(<span class="string">&quot;main: &quot;</span> + thread.getState());  </span><br><span class="line">    thread.start();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>实现 <code>Runnable</code> 接口</strong>（推荐）：
<ul>
<li><strong>做法</strong>：实现 <code>run()</code> 方法，并将其作为参数传递给 <code>Thread</code> 构造函数。</li>
<li><strong>优点</strong>：解耦了“任务逻辑”与“线程资源”。多个线程可以执行同一个 <code>Runnable</code> 实例，适合资源共享。</li>
</ul>
</li>
</ul>
<p><strong><code>Runnable</code> 接口</strong>。<code>Runnable</code> 是 Java 中一个功能性的接口，它定义了一个 <code>run()</code> 方法。实现这个接口的类（如 <code>TaskRunnable</code>）表示一个任务，这个任务可以被一个线程执行。</p>
<p><strong><code>Thread</code> 与 <code>Runnable</code></strong>：<code>Thread</code> 类用于表示一个执行的线程，但它并不直接定义要做什么。<code>Thread</code> 需要一个 <code>Runnable</code> 对象，来确定线程启动后应该执行什么样的任务。所以，<code>Thread</code> 会将一个 <code>Runnable</code> 对象传给其构造方法，这样线程就知道了执行什么任务。</p>
<p>我们实现一个<code>runnable接口</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">    <span class="type">TaskRunnable</span> <span class="variable">taskRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskRunnable</span>();  </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(taskRunnable);  </span><br><span class="line">    thread.start();  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);  </span><br><span class="line">        taskRunnable.cancel();  </span><br><span class="line">          </span><br><span class="line">    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TaskRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">boolean</span> cancel;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (cancel)&#123;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">try</span>&#123;  </span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            System.out.println(<span class="string">&quot;running&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span> &#123;  </span><br><span class="line">        cancel = <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>实现 <code>Callable</code> 接口</strong>：
<ul>
<li><strong>做法</strong>：实现 <code>call()</code> 方法，配合 <code>FutureTask</code> 或线程池使用。</li>
<li><strong>核心区别</strong>：<code>call()</code> 方法<strong>有返回值</strong>且<strong>允许抛出异常</strong>，而 <code>run()</code> 不行。</li>
</ul>
</li>
</ul>
<p>我们来实现一个<code>Callable</code> 接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableBaseDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 定义任务：实现 Callable 接口，泛型 String 是返回值的类型</span></span><br><span class="line">        Callable&lt;String&gt; myTask = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;任务执行完毕：这是从子线程返回的结果！&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 包装任务：由于 Thread 构造方法只接收 Runnable，</span></span><br><span class="line">        <span class="comment">// 我们需要用 FutureTask 包装一下。FutureTask 实现了 Runnable 接口。</span></span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(myTask);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 启动线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程：已经启动子线程，我现在可以做点别的事...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 获取结果：get() 方法会阻塞当前线程，直到子线程执行完毕并返回结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get(); </span><br><span class="line">        System.out.println(<span class="string">&quot;主线程收到的结果: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上，三种实现方式的区别在于：</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>Thread</strong></th>
<th><strong>Runnable</strong></th>
<th><strong>Callable</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>继承性</strong></td>
<td>限制单继承</td>
<td>无限制</td>
<td>无限制</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>无</td>
<td>无</td>
<td>有 (Future获取)</td>
</tr>
<tr>
<td><strong>异常抛出</strong></td>
<td>只能内部捕获</td>
<td>只能内部捕获</td>
<td>允许 throws 抛出</td>
</tr>
</tbody>
</table>
<h4 id="线程的生命周期与状态转换-state-machine"><a class="markdownIt-Anchor" href="#线程的生命周期与状态转换-state-machine"></a> 线程的生命周期与状态转换 (State Machine)</h4>
<p>Java 线程在生命周期内并不是一直占着 CPU 不放，它会在多种状态间切换。通过 <code>thread.getState()</code> 可以获取以下六种状态：</p>
<ol>
<li>
<p><strong>NEW (新建)</strong>：<code>new Thread()</code> 之后，调用 <code>start()</code> 之前。</p>
</li>
<li>
<p><strong>RUNNABLE (可运行)</strong>：调用了 <code>start()</code>。在 Java 中，就绪（Ready）和运行中（Running）统称为“可运行”。</p>
</li>
<li>
<p><strong>BLOCKED (阻塞)</strong>：等待获取 <code>synchronized</code> 锁。</p>
</li>
<li>
<p><strong>WAITING (等待)</strong>：调用了 <code>wait()</code>、<code>join()</code> 或 <code>LockSupport.park()</code>。需要被其他线程显式唤醒。</p>
</li>
<li>
<p><strong>TIMED_WAITING (超时等待)</strong>：调用了 <code>sleep(ms)</code>、<code>wait(ms)</code> 等。时间到了自动苏醒。</p>
</li>
<li>
<p><strong>TERMINATED (终止)</strong>：<code>run()</code> 方法执行完毕或因异常退出。</p>
</li>
</ol>
<img src="https://atffang.github.io/2025/12/22/JAVA多线程方法汇总/线程的生命周期.png"/>
<h4 id="基础控制方法"><a class="markdownIt-Anchor" href="#基础控制方法"></a> 基础控制方法</h4>
<p>这一节介绍的是 Java <code>Thread</code> 类中提供的几个核心控制方法，它们决定了线程在执行过程中的行为。</p>
<h5 id="1-sleeplong-millis"><a class="markdownIt-Anchor" href="#1-sleeplong-millis"></a> 1. sleep(long millis)</h5>
<p><code>sleep</code> 是静态方法，使当前线程进入 <strong>TIMED_WAITING</strong> 状态，暂停执行一段时间。</p>
<ul>
<li><strong>锁的行为</strong>：线程在睡眠时<strong>不会释放</strong>它持有的任何锁（Monitor Lock）。</li>
<li><strong>异常处理</strong>：睡眠中的线程如果被中断，会抛出 <code>InterruptedException</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 暂停1秒</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// 线程在休眠中被中断时的处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-yield"><a class="markdownIt-Anchor" href="#2-yield"></a> 2. yield()</h5>
<p><code>yield</code> 也是静态方法，它表示当前线程愿意让出 CPU 的使用权。</p>
<ul>
<li><strong>调度结果</strong>：调用后，线程从“运行中”变为“就绪”状态。</li>
<li><strong>局限性</strong>：这只是一个“建议”，线程调度器可能会忽略它。如果当前没有其他同优先级的线程，该线程可能立即再次获得 CPU。</li>
<li><strong>锁的行为</strong>：同样不会释放锁。</li>
</ul>
<h5 id="3-join"><a class="markdownIt-Anchor" href="#3-join"></a> 3. join()</h5>
<p><code>join</code> 是成员方法，用于同步多个线程的执行顺序。</p>
<ul>
<li><strong>作用</strong>：如果在线程 A 中调用 <code>B.join()</code>，则 A 线程会进入 <strong>WAITING</strong> 状态，直到 B 线程执行完毕。</li>
<li><strong>原理</strong>：底层调用的是 <code>Object.wait()</code> 方法，因此调用者会释放掉 B 线程对象的锁。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; <span class="comment">/* 耗时任务 */</span> &#125;);</span><br><span class="line">t1.start();</span><br><span class="line">t1.join(); <span class="comment">// 主线程在此阻塞，直到 t1 彻底运行结束</span></span><br></pre></td></tr></table></figure>
<h5 id="4-interrupt"><a class="markdownIt-Anchor" href="#4-interrupt"></a> 4. interrupt()</h5>
<p>Java 采用的是协作式的中断机制，而不是暴力停止。</p>
<ul>
<li><strong>interrupt()</strong>：将目标线程的中断标志位设为 <code>true</code>。</li>
<li><strong>isInterrupted()</strong>：实例方法，判断线程是否被中断。</li>
<li><strong>静态 interrupted()</strong>：检查当前线程的中断状态，并<strong>清除</strong>标志位。</li>
<li><strong>特殊情况</strong>：如果线程正阻塞在 <code>sleep</code>、<code>wait</code>、<code>join</code> 等方法上，<code>interrupt()</code> 会使这些方法抛出异常，并自动清除中断状态（变回 <code>false</code>）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">    <span class="comment">// 执行业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-守护线程-daemon-thread"><a class="markdownIt-Anchor" href="#5-守护线程-daemon-thread"></a> 5. 守护线程 (Daemon Thread)</h5>
<p>Java 中的线程分为“用户线程”和“守护线程”</p>
<ul>
<li><strong>定义</strong>：守护线程是为用户线程服务的（如 GC 垃圾回收）。</li>
<li><strong>退出机制</strong>：当 JVM 中所有的用户线程都运行结束时，守护线程会随 JVM 一起直接退出，无论其任务是否完成。</li>
<li><strong>限制</strong>：必须在 <code>thread.start()</code> 之前调用 <code>setDaemon(true)</code>。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;  </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">daemonThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;  </span><br><span class="line">            <span class="built_in">super</span>.run();  </span><br><span class="line">                System.out.println(getName() + <span class="string">&quot; &quot;</span> + System.currentTimeMillis());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;  </span><br><span class="line">  </span><br><span class="line">    daemonThread.setName(<span class="string">&quot;B&quot;</span>);  </span><br><span class="line">    daemonThread.setDaemon(<span class="literal">true</span>);  </span><br><span class="line">  </span><br><span class="line">    daemonThread.start();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二章线程安全与内存模型-safety-jmm"><a class="markdownIt-Anchor" href="#第二章线程安全与内存模型-safety-jmm"></a> 第二章：线程安全与内存模型 (Safety &amp; JMM)</h3>
<p>线程安全的核心在于：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。</p>
<h4 id="什么是线程安全"><a class="markdownIt-Anchor" href="#什么是线程安全"></a> 什么是线程安全？</h4>
<p>要实现线程安全，必须保证并发编程的三大特性：</p>
<ol>
<li>
<p><strong>原子性 (Atomicity)</strong>：一个或多个操作，要么全部执行且在执行过程中不被任何因素打断，要么全部不执行。</p>
<ul>
<li><em>典型问题</em>：<code>i++</code> 包含读、加、写三步，在多线程下不具备原子性。</li>
</ul>
</li>
<li>
<p><strong>可见性 (Visibility)</strong>：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。</p>
<ul>
<li><em>原因</em>：JMM 规定线程有工作内存，修改变量后不会立即同步到主内存。</li>
</ul>
</li>
<li>
<p><strong>有序性 (Ordering)</strong>：程序执行的顺序按照代码的先后顺序执行。</p>
<ul>
<li><em>原因</em>：编译器和处理器为了优化性能，往往会对指令进行<strong>重排序</strong>。</li>
</ul>
</li>
</ol>
<h4 id="synchronized-关键字"><a class="markdownIt-Anchor" href="#synchronized-关键字"></a> <code>synchronized</code> 关键字</h4>
<p><code>synchronized</code> 是一种互斥锁，它通过控制多个线程对共享资源的访问，一次只允许一个线程执行，从而同时保证了原子性、可见性和有序性。</p>
<p><code>synchronized</code> 底层依赖 JVM 的 <strong>Monitor（监视器锁）</strong>。编译后会生成 <code>monitorenter</code> 和 <code>monitorexit</code> 指令。每个对象头中都有 Mark Word，记录了锁的状态（偏向锁、轻量级锁、重量级锁）。</p>
<p>下面是两个不同的应用：</p>
<p><code>synchronized</code> 方法<br />
在一个方法上使用 <code>synchronized</code>，可以保证同一时刻只能有一个线程访问该方法。这对于涉及共享资源的操作很有用，防止多个线程同时修改资源导致状态不一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 同步的代码块</span></span><br><span class="line">    <span class="comment">// 执行一些对共享资源的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>synchronized</code> 代码块<br />
有时候我们并不需要整个方法都保持同步，而是只需要某部分代码在执行时是互斥的。此时，我们可以使用 <strong><code>synchronized</code> 代码块</strong>。通过指定一个对象锁来控制代码块的同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (锁对象) &#123;</span><br><span class="line">    <span class="comment">// 需要同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>锁对象</code>：它可以是任意对象，通常是一个共享对象。<code>synchronized</code> 关键字会将该对象作为锁，只允许一个线程在同一时间进入该代码块。</p>
</li>
<li>
<p>如果多个线程试图同时进入该同步代码块，它们必须等待其他线程释放该锁。</p>
</li>
<li>
<p><strong>方法级锁</strong>：当你用 <code>synchronized</code> 修饰一个方法时，锁的粒度是<strong>方法级别</strong>的。只有一个线程能访问方法中的同步部分。</p>
</li>
<li>
<p><strong>代码块级锁</strong>：使用 <code>synchronized</code> 代码块时，锁的粒度是<strong>代码块级别</strong>的。它只锁定特定的资源，而不是整个方法，这样可以提高性能，因为不必要的代码部分不会被同步。</p>
</li>
</ul>
<p><code>wait()</code> 方法使当前线程进入 <strong>等待状态</strong>，直到另一个线程发出通知（通过 <code>notify()</code> 或 <code>notifyAll()</code>）。当线程调用 <code>wait()</code> 时，它会释放当前持有的对象锁，并且进入 <strong>等待队列</strong>，直到被其他线程唤醒。</p>
<p><code>wait()</code> 必须在 <strong>同步代码块</strong> 或 <strong>同步方法</strong> 中调用，因为它需要获得对象的监视器锁（即 <code>synchronized</code> 锁）。当线程在同步方法或同步代码块中调用 <code>wait()</code> 时，它会释放对象的锁，允许其他线程获得锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (someObject) &#123;</span><br><span class="line">    <span class="keyword">while</span> (conditionNotMet) &#123;</span><br><span class="line">        someObject.wait();  <span class="comment">// 线程在条件不满足时等待</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行后续操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>notify()</code> 方法唤醒 <strong>一个等待中的线程</strong>。当线程调用 <code>notify()</code> 时，它会从等待队列中随机选择一个线程，并将其唤醒，唤醒后的线程会尝试重新获取对象锁，获得锁后才会继续执行。</p>
<ul>
<li><code>notify()</code> 必须在 <strong>同步代码块</strong> 或 <strong>同步方法</strong> 中调用。</li>
<li>被唤醒的线程不会立即执行，而是进入 <strong>可运行状态</strong>，等待获取对象锁。</li>
</ul>
<p><code>notifyAll()</code> 方法唤醒 <strong>所有等待中的线程</strong>。与 <code>notify()</code> 不同的是，<code>notifyAll()</code> 会唤醒所有等待该对象锁的线程。所有唤醒的线程会争夺锁，只有获得锁的线程才会继续执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedBuffer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(<span class="type">int</span> value)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (data != -<span class="number">1</span>) &#123;  <span class="comment">// 如果数据已存在，生产者等待</span></span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        data = value;  <span class="comment">// 生产数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Produced: &quot;</span> + value);</span><br><span class="line">        notify();  <span class="comment">// 唤醒消费者</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (data == -<span class="number">1</span>) &#123;  <span class="comment">// 如果数据为空，消费者等待</span></span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumed: &quot;</span> + data);</span><br><span class="line">        data = -<span class="number">1</span>;  <span class="comment">// 消费数据</span></span><br><span class="line">        notify();  <span class="comment">// 唤醒生产者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotifyExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SharedBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SharedBuffer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    buffer.produce(i);</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);  <span class="comment">// 模拟生产的时间</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    buffer.consume();</span><br><span class="line">                    Thread.sleep(<span class="number">150</span>);  <span class="comment">// 模拟消费的时间</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="volatile-关键字"><a class="markdownIt-Anchor" href="#volatile-关键字"></a> <code>volatile</code> 关键字</h4>
<p><code>volatile</code> 是 Java 提供的最轻量级的同步机制，它保证了<strong>可见性</strong>和<strong>有序性</strong>，但<strong>不保证原子性</strong>。</p>
<ul>
<li><strong>可见性原理</strong>：写一个 <code>volatile</code> 变量时，JMM 会把该线程对应的工作内存值立即刷新到主内存；读时，会使本地内存失效，直接从主内存读取。</li>
<li><strong>禁止重排序</strong>：通过插入<strong>内存屏障</strong>，确保编译器不会为了优化而改变指令顺序。</li>
</ul>
<p>为了举例，我们介绍java中的<strong>双重检查锁定</strong>（Double-Checked Locking,<strong>DCL</strong>）,主要是为了解决单例模式（Singleton）在多线程环境下的性能和安全平衡问题。</p>
<p>如果没有 DCL，我们最简单的同步写法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次调用 <code>getInstance()</code> 都要加锁，而实际上只有第一次创建实例时才需要同步，后续读取直接返回即可。加锁是非常重的操作，这会严重拖慢性能。那么，我们可以先判断是否为 null，如果不为 null 直接返回；如果为 null，再进入同步块创建对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 必须加 volatile，防止指令重排导致拿到尚未初始化的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); </span><br><span class="line">                    <span class="comment">// 这里包含三步：1.分配空间 2.初始化 3.指向地址</span></span><br><span class="line">                    <span class="comment">// 重排序可能导致：1 -&gt; 3 -&gt; 2，使得其他线程拿到非 null 但未初始化的对象</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看 原来的<code>instance = new Singleton();</code> 这一行。在 JVM 层面，它其实被分成了 <strong>3 个步骤</strong>执行：</p>
<ol>
<li><strong>分配内存空间</strong>（给这个对象找块地方）。</li>
<li><strong>初始化对象</strong>（执行构造函数里的逻辑）。</li>
<li><strong>将 instance 变量指向分配的内存地址</strong>（此时 instance 不再是 null 了）。</li>
</ol>
<p><strong>问题出在编译器的优化上</strong>： 由于步骤 2 和步骤 3 之间没有必然的依赖关系，编译器或 CPU 可能会为了提高效率进行<strong>指令重排序</strong>，把顺序变成： <strong>1（分配内存） -&gt; 3（指向地址） -&gt; 2（初始化对象）</strong>。</p>
<p>这会导致下面发生的灾难场景：</p>
<ol>
<li><strong>线程 A</strong> 进入同步块，执行 <code>instance = new Singleton()</code>。</li>
<li>由于重排序，线程 A 先执行了步骤 3（指向地址），此时 <code>instance</code> 已经<strong>不是 null</strong> 了，但步骤 2（初始化）<strong>还没完成</strong>。</li>
<li>就在这一瞬间，<strong>线程 B</strong> 调用 <code>getInstance()</code>，它判断 <code>instance != null</code>，于是开心地直接把这个 instance 拿去用了。</li>
<li>结果线程 B 在使用对象时，发现由于还没初始化，内部属性全是空的，直接报出 <strong>空指针异常（NPE）</strong> 或逻辑错误。</li>
</ol>
<p>在 <code>instance</code> 变量上加上 <code>volatile</code> 关键字后，会发挥两个核心作用：</p>
<ol>
<li><strong>禁止指令重排序</strong>：它会插入一个“内存屏障”，强制保证执行顺序必须是 <code>1 -&gt; 2 -&gt; 3</code>。这样当线程 B 拿到对象时，它一定已经是初始化完成的。</li>
<li><strong>保证可见性</strong>：一旦线程 A 完成了对象的创建，线程 B 能够立即从主内存中看到 <code>instance</code> 的最新值。</li>
</ol>
<h4 id="原子类-atomic"><a class="markdownIt-Anchor" href="#原子类-atomic"></a> 原子类 <code>Atomic</code></h4>
<p>对于简单的数值运算，使用 <code>synchronized</code> 太重，频繁的线程上下文切换会损耗性能。<code>Atomic</code> 系列工具类（如 <code>AtomicInteger</code>）采用 <strong>CAS (Compare And Swap)</strong> 机制实现。</p>
<ul>
<li><strong>CAS 原理</strong>：包含三个参数：变量内存地址 (V)、预期原值 (A) 和新值 (B)。
<ul>
<li>只有当 V 的实际值等于 A 时，才将 V 修改为 B。否则说明变量已被修改，当前线程会通过自旋（死循环）不断尝试，直到成功。</li>
</ul>
</li>
</ul>
<p>从概念上来说，<strong>原子变量 = 操作不可被打断的变量</strong><br />
对它的操作要么全部执行完，要么完全不执行，<strong>不会被线程切换中断</strong>，因此天然线程安全，不需要 synchronized。</p>
<p>对于普通变量操作，如i++，看起来是一句，但实际上包含三个步骤：</p>
<ol>
<li>读取 i</li>
<li>i + 1</li>
<li>写回 i</li>
</ol>
<p>如果两个线程同时执行，就可能出现：</p>
<ul>
<li>两个线程都读到旧值</li>
<li>最终只加一次</li>
</ul>
<p>这就出现了典型的 <strong>竞态条件（Race Condition）</strong><br />
举个简单的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    count.incrementAndGet(); <span class="comment">// 等同于非原子的 count++</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程封闭-threadlocal"><a class="markdownIt-Anchor" href="#线程封闭-threadlocal"></a> 线程封闭 (<code>ThreadLocal</code>)</h4>
<p>如果说锁是解决“如何同步访问共享数据”，那么 <code>ThreadLocal</code> 则是“如何不共享数据”。它为每个线程提供一份独立的变量副本，实现线程间的数据隔离。</p>
<ul>
<li><strong>核心用途</strong>：解决数据库连接、Session 管理等场景下的线程安全问题。<br />
举个简单的例子</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; localValue = ThreadLocal.withInitial(() -&gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            localValue.set(<span class="number">10</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + localValue.get());</span><br><span class="line">        &#125;, <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            localValue.set(<span class="number">20</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + localValue.get());</span><br><span class="line">        &#125;, <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第三章juc-显式锁-explicit-locks"><a class="markdownIt-Anchor" href="#第三章juc-显式锁-explicit-locks"></a> 第三章：JUC 显式锁 (Explicit Locks)</h3>
<p>在 Java 并发工具包（JUC）中，<code>java.util.concurrent.locks</code> 提供了比 <code>synchronized</code> 更灵活、更强大的锁定机制。<code>synchronized</code> 又被称为内置锁，其不需要程序员过多的手动操作，而基于<code>Lock</code>接口实现的为显式锁，需要程序员一些手动操作才能执行。</p>
<h4 id="lock-接口与-reentrantlock"><a class="markdownIt-Anchor" href="#lock-接口与-reentrantlock"></a> <code>Lock</code> 接口与 <code>ReentrantLock</code></h4>
<p><code>ReentrantLock</code> 是最常用的显式锁，它不仅完全覆盖了 <code>synchronized</code> 的功能，还提供了许多高级特性:</p>
<ul>
<li><strong>手动规范</strong>：使用显式锁必须遵循特定的模板。由于它不会自动释放锁，为了防止死锁，<strong>必须</strong>在 <code>finally</code> 块中调用 <code>unlock()</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>可重入性</strong>：同一个线程可以多次获得同一把锁，内部通过计数器实现。</p>
</li>
<li>
<p><strong>可中断性</strong>：使用 <code>lockInterruptibly()</code> 获取锁时，如果线程正在等待锁，它可以响应中断信号并停止等待。</p>
</li>
<li>
<p><strong>公平锁与非公平锁</strong>：构造函数支持传入 <code>boolean</code> 值。公平锁会严格按照线程排队的顺序给锁，而非公平锁（默认）允许插队，通常拥有更高的吞吐量。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>); <span class="comment">// 公平锁</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>可轮询获取锁（tryLock）</strong>: 线程可以“试一试”拿锁，拿不到直接走，不会阻塞。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 拿到锁才执行</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 拿不到锁，执行别的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock(); <span class="comment">// 阻塞式获取</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock(); <span class="comment">// 必须在 finally 中释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试获取锁：拿不到就走，不阻塞</span></span><br><span class="line"><span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">/* 业务逻辑 */</span> &#125; <span class="keyword">finally</span> &#123; lock.unlock(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="readwritelock-读写锁"><a class="markdownIt-Anchor" href="#readwritelock-读写锁"></a> <code>ReadWriteLock</code> 读写锁</h4>
<p>在很多场景下，数据是“读多写少”的。如果用普通的互斥锁，多个线程同时读也会互相排队，效率低下。<code>ReentrantReadWriteLock</code> 实现了“读写分离”。读写锁是对普通互斥锁的升级，允许多个线程同时读，但写操作只能有一个，并且写时不能读，即：</p>
<ul>
<li><strong>读读不互斥</strong>（并发度高）</li>
<li><strong>读写互斥</strong></li>
<li><strong>写写互斥</strong></li>
</ul>
<p><strong>ReentrantReadWriteLock</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"><span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> rwLock.readLock();</span><br><span class="line"><span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> rwLock.writeLock();</span><br></pre></td></tr></table></figure>
<p>多个线程可以同时拿：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">readLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 读取共享数据</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    readLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有一个线程能拿：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">writeLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 修改共享数据</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    writeLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一个简单的读写锁的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantReadWriteLockDEMO</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> readWriteLock.readLock();  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">writeLock</span>  <span class="operator">=</span> readWriteLock.writeLock();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(String key)</span> &#123;  </span><br><span class="line">        readLock.lock();  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            <span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> map.get(key);  </span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get &quot;</span> + key + <span class="string">&quot; &quot;</span> + val);  </span><br><span class="line">            <span class="keyword">return</span> val;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            readLock.unlock();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, String val)</span> &#123;  </span><br><span class="line">        writeLock.lock();  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            map.put(key, val);  </span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; put &quot;</span> + key + <span class="string">&quot; &quot;</span> + val);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            writeLock.unlock();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;  </span><br><span class="line">        <span class="type">ReentrantReadWriteLockDEMO</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLockDEMO</span>();  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> cache.get(<span class="string">&quot;name&quot;</span>);  </span><br><span class="line">                <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">100</span>); &#125; <span class="keyword">catch</span> (Exception ignored) &#123;&#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> cache.get(<span class="string">&quot;name&quot;</span>);  </span><br><span class="line">                <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">100</span>); &#125; <span class="keyword">catch</span> (Exception ignored) &#123;&#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">                cache.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;value-&quot;</span> + (cnt++));  </span><br><span class="line">                <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">500</span>); &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        t1.start();  </span><br><span class="line">        t2.start();  </span><br><span class="line">        t3.start();  </span><br><span class="line">        t1.join();  </span><br><span class="line">        t2.join();  </span><br><span class="line">        t3.join();   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="condition-机制"><a class="markdownIt-Anchor" href="#condition-机制"></a> <code>Condition</code> 机制</h4>
<p><code>Condition</code> 是为了配合 <code>Lock</code> 使用的，它用来替代 <code>Object.wait()/notify()</code>。它的最大优势在于：<strong>一个锁可以关联多个 Condition（条件变量）</strong>。</p>
<p>在 <code>synchronized</code> 中，所有的线程都挤在一个等待队列里，调用 <code>notifyAll()</code> 会唤醒所有人。而 <code>Condition</code> 可以实现“精准唤醒”。</p>
<p>在 synchronized 里我们用：<br />
•	wait()<br />
•	notify()<br />
•	notifyAll()</p>
<p>在 显式锁（ReentrantLock） 中，我们不能再用它们，要用：<br />
•	await() 代替 wait()<br />
•	signal() 代替 notify()<br />
•	signalAll() 代替 notifyAll()</p>
<p>一个典型的应用场景是<strong>生产消费者模型</strong>， 我们可以创建两个条件：<code>notFull</code>（不满）和 <code>notEmpty</code>（不空）。生产者只唤醒等待 <code>notEmpty</code> 的消费者，互不干扰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Depot</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == MAX) &#123;</span><br><span class="line">                notFull.await();   <span class="comment">// 等待仓库有空位</span></span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产，总数 = &quot;</span> + count);</span><br><span class="line">            notEmpty.signal();     <span class="comment">// 唤醒等待取货的线程</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">take</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmpty.await();  <span class="comment">// 等待仓库非空</span></span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费，总数 = &quot;</span> + count);</span><br><span class="line">            notFull.signal();      <span class="comment">// 唤醒等待生产的线程</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="锁的降级-写锁-读锁"><a class="markdownIt-Anchor" href="#锁的降级-写锁-读锁"></a> 锁的降级 (写锁 -&gt; 读锁)</h4>
<p>锁降级是指：<strong>线程持有写锁 -&gt; 获取读锁 -&gt; 释放写锁</strong>。</p>
<p>这么做主要是为了保证数据的<strong>可见性</strong>和<strong>原子性</strong>。如果你先释放写锁再获取读锁，在中间的空隙，数据可能被其他线程修改了。通过锁降级，线程可以无缝地从“修改者”切换为“观察者”，且在这个过程中，数据不会被他人篡改。</p>
<p>下面是一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">writeLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 修改数据</span></span><br><span class="line">    <span class="comment">// 2. 降级：在释放写锁前先获取读锁</span></span><br><span class="line">    readLock.lock();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    writeLock.unlock(); <span class="comment">// 3. 释放写锁，此时依然持有读锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 4. 使用数据</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    readLock.unlock(); <span class="comment">// 5. 最后释放读锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第四章并发协作工具类-synchronization-tools"><a class="markdownIt-Anchor" href="#第四章并发协作工具类-synchronization-tools"></a> 第四章：并发协作工具类 (Synchronization Tools)</h3>
<p>JUC（Java 并发工具包）除了提供锁之外，还提供了一系列非常有用的协作工具。如果说锁是解决资源竞争的，那么这些工具就是解决线程配合的。</p>
<h4 id="倒计时器-countdownlatch"><a class="markdownIt-Anchor" href="#倒计时器-countdownlatch"></a> 倒计时器 <code>CountDownLatch</code></h4>
<p>CountDownLatch 是一个同步工具类，用来让一个或多个线程等待其他线程完成任务。<br />
就像一个倒计时器：<br />
•	初始有一个计数 count<br />
•	每次调用 countDown()，计数减 1<br />
•	当计数变成 0 时，所有在 await() 等待的线程都会继续执行</p>
<p>典型场景：等待多个任务都完成后继续执行<br />
例如：<br />
•	主线程启动 3 个子线程<br />
•	每个子线程完成后执行 countDown()<br />
•	主线程调用 await()，一直等待所有子线程完成<br />
•	所有子线程完成后，主线程继续执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">taskCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(taskCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; taskCount; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程 &quot;</span> + id + <span class="string">&quot; 开始任务&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span> + id * <span class="number">500</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程 &quot;</span> + id + <span class="string">&quot; 完成任务&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123; &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    latch.countDown(); <span class="comment">// 计数 -1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程等待所有子任务完成...&quot;</span>);</span><br><span class="line">        latch.await(); <span class="comment">// 等待 count 变为 0</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;所有子任务完成，主线程继续执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="循环栅栏-cyclicbarrier"><a class="markdownIt-Anchor" href="#循环栅栏-cyclicbarrier"></a> 循环栅栏 <code>CyclicBarrier</code></h4>
<p><strong>CyclicBarrier 是一种同步屏障，让一组线程必须等到“全部都到达屏障点”，然后同时继续执行。</strong><br />
特点：<br />
•	屏障点（barrier）可以重复使用（循环 cyclic）<br />
•	线程到达 barrier 后会阻塞<br />
•	当所有线程都到达后，自动释放所有线程</p>
<p>假设要 3 个线程同时开始下一步：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 &quot;</span> + id + <span class="string">&quot; 到达屏障点&quot;</span>);</span><br><span class="line">                    barrier.await(); <span class="comment">// 阻塞，直到 3 个线程都调用</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 &quot;</span> + id + <span class="string">&quot; 通过屏障，继续执行&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">线程 0 到达屏障点</span><br><span class="line">线程 2 到达屏障点</span><br><span class="line">线程 1 到达屏障点</span><br><span class="line">（满足3个线程到达）</span><br><span class="line">线程 2 通过屏障，继续执行</span><br><span class="line">线程 1 通过屏障，继续执行</span><br><span class="line">线程 0 通过屏障，继续执行</span><br></pre></td></tr></table></figure>
<p>CyclicBarrier 与 CountDownLatch 的区别</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>CyclicBarrier</strong></th>
<th><strong>CountDownLatch</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>作用</td>
<td>让多个线程“集合，然后一起继续”</td>
<td>让线程等待其他线程做完某件事</td>
</tr>
<tr>
<td>是否可重用</td>
<td>✔ 可重复使用（cyclic）</td>
<td>❌ 不能重置（一次性）</td>
</tr>
<tr>
<td>是否所有线程都会等待</td>
<td>✔ 是</td>
<td>❌ 通常只有一个或少量线程等待</td>
</tr>
<tr>
<td>调用方法</td>
<td>await()</td>
<td>await() + countDown()</td>
</tr>
<tr>
<td>谁减计数</td>
<td>每个线程调用 await() 都算一个到达</td>
<td>调用 countDown() 的线程</td>
</tr>
<tr>
<td>信号方向</td>
<td>大家互相等待</td>
<td>一些线程等待，另一些负责 countDown</td>
</tr>
</tbody>
</table>
<h4 id="信号量-semaphore"><a class="markdownIt-Anchor" href="#信号量-semaphore"></a> 信号量 <code>Semaphore</code></h4>
<p>**Semaphore（信号量）**是Java 并发编程里一个非常核心的同步工具，主要用于控制同时访问某个资源的线程数量。</p>
<p>Semaphore = 一个“许可证”计数器，用来限制并发访问数量。<br />
比如你有 3 台打印机，但有 10 个线程要打印文件。<br />
Semaphore(3) 就相当于发 3 张“许可证”，同时只允许 3 个线程使用打印机。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>); <span class="comment">// 有 3 个许可证</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        semaphore.acquire(); <span class="comment">// 请求一个许可证，如果没有就阻塞</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始打印...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟任务</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 打印结束&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        semaphore.release(); <span class="comment">// 释放一个许可证</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Semaphore 常用方法</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>acquire()</td>
<td>获取一个许可证，没有则阻塞</td>
</tr>
<tr>
<td>acquire(int n)</td>
<td>一次获取 n 个许可证</td>
</tr>
<tr>
<td>tryAcquire()</td>
<td>尝试获取，不阻塞，获取不到返回 false</td>
</tr>
<tr>
<td>release()</td>
<td>释放许可证</td>
</tr>
<tr>
<td>availablePermits()</td>
<td>查看剩余许可证数量</td>
</tr>
</tbody>
</table>
<p>Semaphore vs Lock / synchronized</p>
<table>
<thead>
<tr>
<th><strong>对比对象</strong></th>
<th><strong>Semaphore</strong></th>
<th><strong>Lock / synchronized</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>核心用途</td>
<td>限制并发数量</td>
<td>同一时间只有一个线程进入临界区（互斥）</td>
</tr>
<tr>
<td>支持多少线程同时进入</td>
<td><strong>多个</strong>（取决于 permits）</td>
<td><strong>只能 1 个</strong></td>
</tr>
<tr>
<td>是否可作为锁使用</td>
<td>可以（permits=1 时类似 mutex）</td>
<td>是锁</td>
</tr>
</tbody>
</table>
<p>公平/非公平</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>, <span class="literal">true</span>); <span class="comment">// 公平，按排队顺序</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>, <span class="literal">false</span>); <span class="comment">// 非公平（默认），速度更快</span></span><br></pre></td></tr></table></figure>
<h4 id="阶段同步-phaser"><a class="markdownIt-Anchor" href="#阶段同步-phaser"></a> 阶段同步 <code>Phaser</code></h4>
<p>Phaser 是 Java 并发里 <strong>最灵活、可重用、可动态注册线程的“阶段同步器”</strong><br />
可以理解为：一个可以分成很多阶段（phase）的同步器，每个阶段都要所有“参与者”到齐后才能进入下一阶段，并且参与者数量还可以动态增减。</p>
<table>
<thead>
<tr>
<th><strong>工具</strong></th>
<th><strong>问题</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CountDownLatch</strong></td>
<td>一次性等待，不能复用，不能动态增加线程</td>
</tr>
<tr>
<td><strong>CyclicBarrier</strong></td>
<td>可复用，但是参与线程数固定，不能动态变化</td>
</tr>
<tr>
<td><strong>Phaser</strong></td>
<td>✔ 可复用 ✔ 可多阶段 ✔ 可动态增加/减少线程 ✔ 更灵活</td>
</tr>
</tbody>
</table>
<p>基础使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Phaser</span> <span class="variable">phaser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phaser</span>(<span class="number">3</span>); <span class="comment">// 3 个参与者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行阶段1&quot;</span>);</span><br><span class="line">        phaser.arriveAndAwaitAdvance();  <span class="comment">// 等别人</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行阶段2&quot;</span>);</span><br><span class="line">        phaser.arriveAndAwaitAdvance();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行阶段3&quot;</span>);</span><br><span class="line">        phaser.arriveAndAwaitAdvance();</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T1 执行阶段1</span><br><span class="line">T2 执行阶段1</span><br><span class="line">T3 执行阶段1</span><br><span class="line">--- 阶段1结束 ---</span><br><span class="line">T1 执行阶段2</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>核心方法：</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>意义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>arrive()</td>
<td>到达当前阶段，不等待</td>
</tr>
<tr>
<td>arriveAndAwaitAdvance()</td>
<td>到达并等待其他线程（最常用）</td>
</tr>
<tr>
<td>arriveAndDeregister()</td>
<td>到达后退出，不再参加后续阶段</td>
</tr>
</tbody>
</table>
<p>phaser可以动态注册线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phaser.register(); <span class="comment">// 新线程加入同步控制</span></span><br></pre></td></tr></table></figure>
<p>一个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Phaser</span> <span class="variable">phaser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phaser</span>(<span class="number">1</span>); <span class="comment">// main 是 1 个参与者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    Phaser ph;</span><br><span class="line">    Player(Phaser ph) &#123; <span class="built_in">this</span>.ph = ph; ph.register(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 准备进入游戏&quot;</span>);</span><br><span class="line">        ph.arriveAndAwaitAdvance();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 加载地图&quot;</span>);</span><br><span class="line">        ph.arriveAndAwaitAdvance();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 加载角色&quot;</span>);</span><br><span class="line">        ph.arriveAndAwaitAdvance();</span><br><span class="line">        </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成所有加载&quot;</span>);</span><br><span class="line">        ph.arriveAndDeregister();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Phaser</span> <span class="variable">ph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phaser</span>(<span class="number">1</span>); <span class="comment">// main</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Player</span>(ph), <span class="string">&quot;玩家1&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Player</span>(ph), <span class="string">&quot;玩家2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    ph.arriveAndAwaitAdvance(); <span class="comment">// 主线程同步各阶段</span></span><br><span class="line">    ph.arriveAndAwaitAdvance();</span><br><span class="line">    ph.arriveAndAwaitAdvance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数据交换-exchanger"><a class="markdownIt-Anchor" href="#数据交换-exchanger"></a> 数据交换 <code>Exchanger</code></h4>
<p><code>Exchanger</code> 用于两个线程之间的数据交换。它提供一个同步点，在这个点，两个线程可以交换彼此的数据。</p>
<ul>
<li><strong>核心逻辑</strong>：当一个线程调用 <code>exchange()</code> 时，它会阻塞直到第二个线程也调用该方法。然后两个线程交换数据并返回。</li>
<li><strong>特性</strong>：只能成对使用（2个线程）。</li>
<li><strong>场景</strong>：两个流水线环节的数据传递，或者遗传算法中的交叉操作。</li>
</ul>
<p>一个简单的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;A线程数据&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> exchanger.exchange(data);</span><br><span class="line">        System.out.println(<span class="string">&quot;A 得到：&quot;</span> + result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ignored) &#123;&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;B线程数据&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> exchanger.exchange(data);</span><br><span class="line">        System.out.println(<span class="string">&quot;B 得到：&quot;</span> + result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ignored) &#123;&#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<h3 id="第五章线程池架构-executor-framework"><a class="markdownIt-Anchor" href="#第五章线程池架构-executor-framework"></a> 第五章：线程池架构 (Executor Framework)</h3>
<p>在实际生产开发中，我们几乎从不手动 <code>new Thread()</code>。为了节省系统资源并提高响应速度，我们会使用线程池来管理线程。</p>
<h4 id="为什么要用线程池"><a class="markdownIt-Anchor" href="#为什么要用线程池"></a> 为什么要用线程池？</h4>
<p>创建一个 Java 线程需要调用操作系统的内核 API，这是一个昂贵的操作。</p>
<ul>
<li><strong>降低资源消耗</strong>：通过池化技术重复利用已创建的线程，减少线程创建和销毁的性能开销。</li>
<li><strong>提高响应速度</strong>：任务到达时，无需等待线程创建即可立即执行。</li>
<li><strong>提高线程的可管理性</strong>：线程是稀缺资源，使用线程池可以统一分配、调优和监控，防止无限制创建线程导致系统崩溃（OOM）。</li>
</ul>
<h4 id="threadpoolexecutor-核心参数"><a class="markdownIt-Anchor" href="#threadpoolexecutor-核心参数"></a> <code>ThreadPoolExecutor</code> 核心参数</h4>
<p>所有的线程池底层都是 <code>ThreadPoolExecutor</code>，包含七个核心的参数：</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>名称</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>corePoolSize</code></td>
<td><strong>核心线程数</strong></td>
<td>线程池中常驻的“保底”线程数量，即使它们闲着也不会被销毁。</td>
</tr>
<tr>
<td><code>maximumPoolSize</code></td>
<td><strong>最大线程数</strong></td>
<td>线程池允许创建的最大线程总量。</td>
</tr>
<tr>
<td><code>keepAliveTime</code></td>
<td><strong>存活时间</strong></td>
<td>当线程数大于核心线程数时，多余的空闲线程能活多久。</td>
</tr>
<tr>
<td><code>unit</code></td>
<td><strong>时间单位</strong></td>
<td><code>keepAliveTime</code> 的时间单位（秒、毫秒等）。</td>
</tr>
<tr>
<td><code>workQueue</code></td>
<td><strong>任务队列</strong></td>
<td>存放待执行任务的阻塞队列（BlockingQueue）。</td>
</tr>
<tr>
<td><code>threadFactory</code></td>
<td><strong>线程工厂</strong></td>
<td>用于创建新线程，通常在这里给线程起个有意义的名字。</td>
</tr>
<tr>
<td><code>handler</code></td>
<td><strong>拒绝策略</strong></td>
<td>当队列满了且线程数达到最大值时，如何处理新来的任务。</td>
</tr>
</tbody>
</table>
<h4 id="线程池工作流程与拒绝策略"><a class="markdownIt-Anchor" href="#线程池工作流程与拒绝策略"></a> 线程池工作流程与拒绝策略</h4>
<p>线程池的处理逻辑遵循“<strong>先核心，再队列，后最大</strong>”的原则：</p>
<ol>
<li><strong>提交任务</strong>：如果当前线程数 &lt; <code>corePoolSize</code>，直接创建新线程执行。</li>
<li><strong>进入队列</strong>：如果线程数 ≥ <code>corePoolSize</code>，任务进入 <code>workQueue</code> 排队。</li>
<li><strong>尝试扩容</strong>：如果队列满了且线程数 &lt; <code>maximumPoolSize</code>，创建非核心线程执行。</li>
<li><strong>触发拒绝</strong>：如果队列满了且线程数 = <code>maximumPoolSize</code>，执行拒绝策略。</li>
</ol>
<p><strong>JDK 自带的四种拒绝策略：</strong></p>
<ul>
<li><strong>AbortPolicy</strong>（默认）：直接抛出 <code>RejectedExecutionException</code> 异常，阻止系统正常工作。</li>
<li><strong>CallerRunsPolicy</strong>：“谁提交谁执行”。让提交任务的线程（比如主线程）自己去跑这个任务，从而降低任务提交速度。</li>
<li><strong>DiscardPolicy</strong>：直接丢弃任务，不予任何处理也不报错。</li>
<li><strong>DiscardOldestPolicy</strong>：丢弃队列里最老的一个任务，尝试再次提交当前任务。</li>
</ul>
<h4 id="工厂类-executors"><a class="markdownIt-Anchor" href="#工厂类-executors"></a> 工厂类 <code>Executors</code></h4>
<p>常用方法：<br />
•	Executors.newFixedThreadPool(n)：固定大小线程池<br />
•	Executors.newCachedThreadPool()：弹性线程池<br />
•	Executors.newSingleThreadExecutor()：单线程<br />
•	Executors.newScheduledThreadPool(n)：定时任务线程池</p>
<h5 id="executorservice线程池接口"><a class="markdownIt-Anchor" href="#executorservice线程池接口"></a> ExecutorService（线程池接口）</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Executor</span><br><span class="line">  │</span><br><span class="line">  ├── ExecutorService</span><br><span class="line">  │        │</span><br><span class="line">  │        └── AbstractExecutorService</span><br><span class="line">  │                │</span><br><span class="line">  │                └── ThreadPoolExecutor  ← 普通线程池核心</span><br><span class="line">  │</span><br><span class="line">  └── ScheduledExecutorService</span><br><span class="line">           │</span><br><span class="line">           └── ScheduledThreadPoolExecutor ← 定时任务线程池核心</span><br></pre></td></tr></table></figure>
<p>常用方法：<br />
•	submit()：提交任务<br />
•	shutdown()：优雅关闭<br />
•	shutdownNow()：强制终止</p>
<h5 id="scheduledexecutorservice"><a class="markdownIt-Anchor" href="#scheduledexecutorservice"></a> <strong>ScheduledExecutorService</strong></h5>
<p>用于执行定时任务、周期任务。<br />
包含：<br />
<code>schedule()</code><br />
<code>scheduleAtFixedRate()</code><br />
<code>scheduleWithFixedDelay()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个具有2个线程的定时任务线程池</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">scheduler</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 延迟 3 秒执行一次任务</span></span><br><span class="line">        scheduler.schedule(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务 A：延迟 3 秒执行 -&gt; &quot;</span> + System.currentTimeMillis());</span><br><span class="line">        &#125;, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 每隔 2 秒执行一次任务（固定频率）</span></span><br><span class="line">        scheduler.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务 B：每隔 2 秒执行 -&gt; &quot;</span> + System.currentTimeMillis());</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 程序不退出，保持执行</span></span><br><span class="line">        <span class="comment">// 若想停止，稍后调用 scheduler.shutdown();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="forkjoinpool-分治思想"><a class="markdownIt-Anchor" href="#forkjoinpool-分治思想"></a> <code>ForkJoinPool</code> (分治思想)</h4>
<p>ForkJoinPool 是一种专门用于“分而治之（Fork）+ 合并结果（Join）”的高效并行计算线程池，它用来处理大量可以拆分的任务，自动进行任务窃取（work-stealing）以提升 CPU 利用率。</p>
<p>你一般只需要继承：<br />
•	RecursiveAction（void 任务）<br />
•	RecursiveTask（有返回值任务）</p>
<p>大数组求和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SumTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> start, end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SumTask</span><span class="params">(<span class="type">long</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = arr;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> end - start;</span><br><span class="line">        <span class="keyword">if</span> (length &lt;= THRESHOLD) &#123; <span class="comment">// 小任务直接算</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) sum += arr[i];</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> start + length / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">SumTask</span> <span class="variable">left</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(arr, start, mid);</span><br><span class="line">        <span class="type">SumTask</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(arr, mid, end);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分裂</span></span><br><span class="line">        left.fork();</span><br><span class="line">        right.fork();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并</span></span><br><span class="line">        <span class="keyword">return</span> left.join() + right.join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span>[] arr = <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">1000000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) arr[i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> pool.invoke(<span class="keyword">new</span> <span class="title class_">SumTask</span>(arr, <span class="number">0</span>, arr.length));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;总和：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="future"><a class="markdownIt-Anchor" href="#future"></a> Future</h4>
<p>Future 表示一个异步计算的结果，你可以在提交任务后立即得到 Future 对象，以后再从这个对象中取结果。<br />
其接口为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">         <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>future的最常见来源：线程池的 <strong>submit()</strong> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">Future&lt;Integer&gt; future = pool.submit(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>得到的 future 就是异步结果句柄。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Future&lt;String&gt; future = pool.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 模拟耗时任务</span></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;任务完成&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;我先做点别的事...&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到结果（阻塞）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line"></span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我先做点别的事...</span><br><span class="line">任务完成</span><br></pre></td></tr></table></figure>
<p>因此，future可以 通过 get() 方法获取异步执行的结果（阻塞等待）。<br />
同时，也可以通过cancel取消任务，通过isDone判断任务是否完成，通过get(timeout)等待固定时间，如果任务还没完成，则抛 TimeoutException。</p>
<h3 id="第六章异步编程-asynchronous-programming"><a class="markdownIt-Anchor" href="#第六章异步编程-asynchronous-programming"></a> 第六章：异步编程 (Asynchronous Programming)</h3>
<h4 id="future-的局限性"><a class="markdownIt-Anchor" href="#future-的局限性"></a> <code>Future</code> 的局限性</h4>
<p>虽然 <code>Future</code> 开启了异步执行的先河，但它在处理复杂业务逻辑时非常笨拙：</p>
<ul>
<li><strong>阻塞等待</strong>：要获取结果只能调用 <code>get()</code>，如果子线程没跑完，主线程必须在此阻塞，这实际上把异步变成了同步等待。</li>
<li><strong>轮询耗能</strong>：如果不阻塞，就得用 <code>isDone()</code> 开启死循环轮询，极度消耗 CPU。</li>
<li><strong>无法回调</strong>：无法表达“任务完成后自动执行下一步”的逻辑。</li>
<li><strong>编排困难</strong>：很难将多个 <code>Future</code> 的结果组合在一起，代码会嵌套得非常难看（回调地狱）。</li>
</ul>
<h4 id="completablefuture"><a class="markdownIt-Anchor" href="#completablefuture"></a> <code>CompletableFuture</code></h4>
<p>JDK 8 引入的 <code>CompletableFuture</code> 是异步编程的里程碑。它实现了 <code>Future</code> 和 <code>CompletionStage</code> 两个接口，支持任务的回调、组合和链式编排。</p>
<h5 id="异步任务的启动与执行策略"><a class="markdownIt-Anchor" href="#异步任务的启动与执行策略"></a> 异步任务的启动与执行策略</h5>
<p>任务的启动通常依赖于静态工厂方法。<code>supplyAsync</code> 用于启动具有返回值的异步计算，而 <code>runAsync</code> 则适用于仅需执行特定动作且无需返回结果的场景。在资源调度层面，若不指定 <code>Executor</code>，这些任务默认由 <code>ForkJoinPool.commonPool()</code> 承载，但在生产环境下，通常建议传入自定义线程池以实现业务间的资源隔离与监控。</p>
<h5 id="异步链路的回调处理机制"><a class="markdownIt-Anchor" href="#异步链路的回调处理机制"></a> 异步链路的回调处理机制</h5>
<p>在任务完成后，<code>CompletableFuture</code> 支持通过链式调用定义回调逻辑。<code>thenApply</code> 方法能够获取前一阶段的执行结果并对其进行转换，产生一个新的返回值，从而构建出流水线式的处理链路。与之相对，<code>thenAccept</code> 仅用于消费前序任务的结果而不产生新的输出，而 <code>thenRun</code> 则完全忽略结果，仅在任务完成这一特定时机触发后续动作。</p>
<h5 id="多任务的逻辑编排与协同"><a class="markdownIt-Anchor" href="#多任务的逻辑编排与协同"></a> 多任务的逻辑编排与协同</h5>
<p>针对复杂的并发场景，<code>CompletableFuture</code> 提供了强大的编排能力。对于存在先后依赖关系的串行任务，<code>thenCompose</code> 可以将前一个任务的输出平滑传递给下一个异步任务；而对于互不依赖、需并行执行的任务，<code>thenCombine</code> 支持在两个任务全部完成后对其结果进行聚合。在更宏观的层面，<code>allOf</code> 提供了阻塞式同步机制，确保所有并行的异步任务全部完成后再向下执行，而 <code>anyOf</code> 则实现了竞争逻辑，只要其中任意一个任务率先完成即返回其结果。</p>
<h5 id="异步链路的异常捕获与容错"><a class="markdownIt-Anchor" href="#异步链路的异常捕获与容错"></a> 异步链路的异常捕获与容错</h5>
<p>异步编程中的异常传播与传统同步代码有所不同，需要专门的兜底机制。<code>exceptionally</code> 方法类似于同步代码中的 catch 块，能够在链路出现异常时拦截错误并返回一个预设的默认值，确保后续链路不会因未捕获的异常而中断。此外，<code>handle</code> 方法提供了更全面的控制，无论前序任务是正常结束还是抛出异常，它均能接收到执行结果或异常对象，并进行统一的处理与转换。</p>
<p>举一个链式流水线的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;查询商品ID:123&quot;</span>)</span><br><span class="line">    .thenApply(id -&gt; <span class="string">&quot;获取商品价格: $99&quot;</span>) <span class="comment">// 链式处理</span></span><br><span class="line">    .thenCombine(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;获取优惠券: -$10&quot;</span>), </span><br><span class="line">        (price, coupon) -&gt; price + <span class="string">&quot; &quot;</span> + coupon) <span class="comment">// 组合两个异步任务</span></span><br><span class="line">    .thenAccept(finalResult -&gt; System.out.println(<span class="string">&quot;最终报价: &quot;</span> + finalResult))</span><br><span class="line">    .exceptionally(e -&gt; &#123; </span><br><span class="line">        System.err.println(<span class="string">&quot;出错: &quot;</span> + e.getMessage()); </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="completionservice"><a class="markdownIt-Anchor" href="#completionservice"></a> <code>CompletionService</code></h4>
<p><code>CompletionService&lt;V&gt;</code> 是一个接口，用于 提交异步任务并按完成顺序获取结果。它结合了 Executor（线程池）和 BlockingQueue 的功能。任务完成顺序与提交顺序可能不同，使用 CompletionService 可以 按照完成顺序 获取任务结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletionServiceExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        CompletionService&lt;String&gt; service = <span class="keyword">new</span> <span class="title class_">ExecutorCompletionService</span>&lt;&gt;(pool);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        service.submit(() -&gt; &#123; Thread.sleep(<span class="number">300</span>); <span class="keyword">return</span> <span class="string">&quot;Task 1&quot;</span>; &#125;);</span><br><span class="line">        service.submit(() -&gt; &#123; Thread.sleep(<span class="number">100</span>); <span class="keyword">return</span> <span class="string">&quot;Task 2&quot;</span>; &#125;);</span><br><span class="line">        service.submit(() -&gt; &#123; Thread.sleep(<span class="number">200</span>); <span class="keyword">return</span> <span class="string">&quot;Task 3&quot;</span>; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按完成顺序获取结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Future&lt;String&gt; future = service.take();  <span class="comment">// 阻塞直到有任务完成</span></span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第七章并发容器-concurrent-collections"><a class="markdownIt-Anchor" href="#第七章并发容器-concurrent-collections"></a> 第七章：并发容器 (Concurrent Collections)</h3>
<h4 id="concurrenthashmap-原理"><a class="markdownIt-Anchor" href="#concurrenthashmap-原理"></a> <code>ConcurrentHashMap</code> 原理</h4>
<p><code>ConcurrentHashMap</code> 是为了解决 <code>Hashtable</code> 全局锁定导致并发效率低下的问题而设计的。在 Java 8 及其后续版本中，它舍弃了早期版本中的分段锁（Segment）设计，转而采用 <strong>Node 数组 + 链表 + 红黑树</strong> 的结构，并结合 <strong>CAS（Compare-And-Swap）</strong> 和 <strong>synchronized</strong> 实现更细粒度的锁控制。</p>
<p>在执行读操作时，<code>ConcurrentHashMap</code> 完全不加锁，通过 <code>volatile</code> 关键字保证了数据的可见性，这使得它在读取密集的场景下表现极佳。在执行写操作时，它仅锁定当前正在操作的哈希桶（即 Node 数组的头节点），而不是整个 Map。这种“局部锁定”的策略允许多个线程同时对不同的哈希桶进行写入。此外，当链表长度超过阈值（默认为 8）且数组容量大于 64 时，链表会转化为红黑树，以保证在高碰撞情况下的查询效率仍能维持在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p>
<h4 id="copyonwritearraylist"><a class="markdownIt-Anchor" href="#copyonwritearraylist"></a> <code>CopyOnWriteArrayList</code></h4>
<p><code>CopyOnWriteArrayList</code> 采用了一种极其独特的“写时复制”（Copy-On-Write）策略。它的核心思想是：当你对容器进行修改（添加、删除、设置元素）时，它并不直接修改当前数组，而是先将原数组拷贝一份副本，在副本上完成修改操作，最后再将原数组的引用指向这个新副本。</p>
<p>这种机制带来了显著的特性：<strong>读操作完全无锁且不阻塞</strong>。当一个线程在遍历列表时，即使有另一个线程正在进行修改，遍历线程看到的依然是修改前的旧数组镜像，因此它天然地解决了并发修改异常（<code>ConcurrentModificationException</code>）。然而，这种设计也存在明显的权衡，即每次修改都会导致数组拷贝，内存开销较大。因此，它仅适用于<strong>读多写极少</strong>且对实时性要求不是极高的场景（例如配置白名单或监听器列表）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写操作示例：内部会加锁并复制数组</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;data&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 读操作示例：直接读取引用，性能极高</span></span><br><span class="line"><span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h4 id="阻塞队列-blockingqueue-全家桶"><a class="markdownIt-Anchor" href="#阻塞队列-blockingqueue-全家桶"></a> 阻塞队列 <code>BlockingQueue</code> 全家桶</h4>
<p><code>BlockingQueue</code> 是实现“生产者-消费者”模型的灵魂组件。它与普通队列的区别在于支持<strong>阻塞机制</strong>：当队列为空时，尝试取出的线程会被阻塞直到有数据可用；当队列满时，尝试存入的线程会被阻塞直到队列出现空位。</p>
<p>JUC 提供了多种不同特性的实现类。<code>ArrayBlockingQueue</code> 基于定长数组，强制要求设置初始容量，适合任务量稳定的系统。<code>LinkedBlockingQueue</code> 基于链表，默认容量为 <code>Integer.MAX_VALUE</code>，如果不设限可能会导致内存溢出。<code>SynchronousQueue</code> 则更为特殊，它不存储任何元素，每一个插入操作必须等待另一个线程的移除操作，是线程间“手递手”传递数据的桥梁。此外，还有支持优先级的 <code>PriorityBlockingQueue</code> 和处理延迟任务的 <code>DelayQueue</code>。这些队列通过内部的 <code>ReentrantLock</code> 和 <code>Condition</code> 机制，优雅地解决了线程间的同步调度问题。</p>
<h3 id="第八章-死锁"><a class="markdownIt-Anchor" href="#第八章-死锁"></a> 第八章 死锁</h3>
<p>在多线程环境下，<strong>死锁（Deadlock）</strong> 是最令人头疼的并发问题之一。它发生在两个或多个线程互相持有对方所需的资源，导致所有相关线程都进入无限期的等待状态。</p>
<h4 id="死锁的四大必要条件"><a class="markdownIt-Anchor" href="#死锁的四大必要条件"></a> 死锁的四大必要条件</h4>
<p>根据经典操作系统理论，死锁的发生必须同时满足以下四个条件。如果能破坏其中任何一个，死锁就不会发生：</p>
<ol>
<li><strong>互斥条件（Mutual Exclusion）</strong>：<br />
资源是独占的。在某一时刻，一个资源（如一个对象锁）只能被一个线程持有。如果其他线程请求该资源，必须等待直到持有者释放。</li>
<li><strong>占有且等待（Hold and Wait）</strong>：<br />
一个线程已经持有了至少一个资源，但又提出了新的资源请求，而该资源正被其他线程占有。此时请求线程阻塞，但对自己已获得的资源保持不放。</li>
<li><strong>不可剥夺（No Preemption）</strong>：<br />
线程已获得的资源在未使用完之前，不能被其他线程强行夺走，只能由该线程在完成任务后主动释放。</li>
<li><strong>循环等待（Circular Wait）</strong>：<br />
存在一个线程的资源循环链。例如，线程 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">T1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord">1</span></span></span></span> 等待 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">T2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord">2</span></span></span></span> 占有的资源，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">T2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord">2</span></span></span></span> 等待 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">T3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord">3</span></span></span></span> 的资源……最后 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Tn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">n</span></span></span></span> 又在等待 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">T1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord">1</span></span></span></span> 占有的资源。</li>
</ol>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程 t1：先拿 A，再拿 B</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">100</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125; <span class="comment">// 确保 t2 拿到了 B</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 1 acquired both locks&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程 t2：先拿 B，再拿 A</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">100</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125; <span class="comment">// 确保 t1 拿到了 A</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 2 acquired both locks&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>
<p>在这个例子中，Thread.sleep(100) 是产生死锁的关键催化剂。它保证了 t1 锁住 lockA 的同时，t2 有足够的时间锁住 lockB。此时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">t</span><span class="mord">1</span></span></span></span> 试图获取 lockB 时会因为“互斥”被阻塞，同时它“占有且等待”着 lockA；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">t</span><span class="mord">2</span></span></span></span> 同理。由于锁是“不可剥夺”的，最终形成了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mn>1</mn><mo>→</mo><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>B</mi><mo>→</mo><mi>t</mi><mn>2</mn><mo>→</mo><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>A</mi><mo>→</mo><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t1 \rightarrow lockB \rightarrow t2 \rightarrow lockA \rightarrow t1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">t</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">t</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">t</span><span class="mord">1</span></span></span></span> 的循环等待。</p>
<p><strong>如何排查死锁？</strong><br />
当程序突然“卡死”且 CPU 占用率极低时，极有可能是发生了死锁。你可以使用 JDK 自带的工具进行检测：</p>
<ol>
<li><strong><code>jcmd / jps</code></strong>：获取运行中的 Java 进程 ID。</li>
<li><strong><code>jstack &lt;pid&gt;</code></strong>：打印线程堆栈。如果存在死锁，<code>jstack</code> 会在末尾明确提示 <code>Found one Java-level deadlock</code>，并详细列出是哪些线程在哪个对象上互相折磨。</li>
</ol>
<p><strong>如何预防死锁？</strong></p>
<ol>
<li><strong>固定加锁顺序</strong>（破坏循环等待）：这是最常用的方案。让 <code>t1</code> 和 <code>t2</code> 都按照“先拿 A 再拿 B”的顺序去竞争，这样就不会形成环路。</li>
<li><strong>尝试性获取锁</strong>（破坏不可剥夺）：使用 <code>ReentrantLock</code> 的 <code>tryLock(long time, TimeUnit unit)</code> 方法。如果线程在规定时间内拿不到下一把锁，就主动释放已经拿到的锁，退回并重试。</li>
<li><strong>减小锁粒度</strong>：尽量不要在一个同步块中嵌套另一个同步块。</li>
</ol>
<h3 id="第九章-thread内存泄漏"><a class="markdownIt-Anchor" href="#第九章-thread内存泄漏"></a> 第九章 Thread内存泄漏</h3>
<p>在多线程开发中，除了死锁，另一个隐蔽且高发的陷阱是 <strong>ThreadLocal 导致的内存泄漏</strong>。这通常发生在长生命周期的线程（如线程池中的线程）中。</p>
<h4 id="threadlocal-内存泄漏的根源"><a class="markdownIt-Anchor" href="#threadlocal-内存泄漏的根源"></a> ThreadLocal 内存泄漏的根源</h4>
<p><code>ThreadLocal</code> 的原理是为每个线程维护一个私有的 <code>ThreadLocalMap</code>。这个 Map 的特殊之处在于它的内部结构：其 <strong>Key（ThreadLocal 实例）是弱引用（WeakReference）</strong>，而 <strong>Value（存储的数据）是强引用</strong>。</p>
<p>这种设计的初衷是为了保护内存：当外部不再持有 <code>ThreadLocal</code> 实例的强引用时，Key 会在下一次 GC 时被回收，变成 <code>null</code>。然而，问题也就此产生。虽然 Key 消失了，但 <strong>Value 依然被线程的 <code>ThreadLocalMap</code> 以强引用的方式持有</strong>。</p>
<p>如果这个线程是普通线程，执行完任务就销毁了，那么整个 Map 都会被回收。但现代应用几乎都在使用<strong>线程池</strong>。线程池中的线程是高度复用的，这意味着：</p>
<ol>
<li>线程永远不会结束。</li>
<li><code>ThreadLocalMap</code> 里的那块 Value 内存会一直被占用。</li>
<li>由于 Key 变成了 <code>null</code>，你再也没有办法通过正常途径访问到这块 Value，它成了一块“幽灵内存”。</li>
</ol>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalLeakDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;<span class="type">byte</span>[]&gt; localData = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟一个固定大小为 5 的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            pool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 每个任务占用 5MB 内存</span></span><br><span class="line">                localData.set(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">5</span>]);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 设置了数据&quot;</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 注意：这里没有调用 localData.remove()</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，虽然任务执行完了，但由于线程池里的线程没死，每个线程持有的 5MB 字节数组会一直驻留在内存中。如果任务不断提交，内存占用会持续攀升，最终导致 <code>OutOfMemoryError</code>。</p>
<p>使用 <code>jvisualvm</code> 或 <code>MAT</code> (Memory Analyzer Tool) 查看堆转储（Heap Dump）。如果你发现 <code>ThreadLocalMap</code> 里的 <code>Entry</code> 数量异常多，且其 <code>value</code> 字段占用了大量内存，基本可以确定是泄漏。</p>
<p>在代码中使用 <code>ThreadLocal</code> 时，务必遵循 <code>try-finally</code> 模式，在 <code>finally</code> 块中调用 <code>remove()</code> 方法。这会清除当前线程 Map 中对应的 Entry。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    localData.set(value);</span><br><span class="line">    <span class="comment">// 执行业务逻辑</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 关键：任务结束前一定要清理，尤其是在线程池环境下</span></span><br><span class="line">    localData.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/12/21/MTMCT%E6%96%B9%E5%90%91%E7%9A%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E4%B9%A0%E6%A2%B3%E7%90%86/" rel="prev" title="MTMCT方向的度量学习梳理">
      <i class="fa fa-chevron-left"></i> MTMCT方向的度量学习梳理
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/12/22/%E5%9F%BA%E4%BA%8ECesium%E7%9A%84%E4%B8%89%E7%BB%B4%E8%A7%86%E9%94%A5%E7%BB%98%E5%88%B6%E4%B8%8E%E7%94%BB%E9%9D%A2%E6%A8%A1%E6%8B%9F/" rel="next" title="基于Cesium的三维视锥绘制与画面模拟">
      基于Cesium的三维视锥绘制与画面模拟 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text"> 第一章：多线程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="nav-number">1.1.</span> <span class="nav-text"> 线程的创建方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2-state-machine"><span class="nav-number">1.2.</span> <span class="nav-text"> 线程的生命周期与状态转换 (State Machine)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text"> 基础控制方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-sleeplong-millis"><span class="nav-number">1.3.1.</span> <span class="nav-text"> 1. sleep(long millis)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-yield"><span class="nav-number">1.3.2.</span> <span class="nav-text"> 2. yield()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-join"><span class="nav-number">1.3.3.</span> <span class="nav-text"> 3. join()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-interrupt"><span class="nav-number">1.3.4.</span> <span class="nav-text"> 4. interrupt()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B-daemon-thread"><span class="nav-number">1.3.5.</span> <span class="nav-text"> 5. 守护线程 (Daemon Thread)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-safety-jmm"><span class="nav-number">2.</span> <span class="nav-text"> 第二章：线程安全与内存模型 (Safety &amp; JMM)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">2.1.</span> <span class="nav-text"> 什么是线程安全？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.2.</span> <span class="nav-text"> synchronized 关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.3.</span> <span class="nav-text"> volatile 关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB-atomic"><span class="nav-number">2.4.</span> <span class="nav-text"> 原子类 Atomic</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD-threadlocal"><span class="nav-number">2.5.</span> <span class="nav-text"> 线程封闭 (ThreadLocal)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0juc-%E6%98%BE%E5%BC%8F%E9%94%81-explicit-locks"><span class="nav-number">3.</span> <span class="nav-text"> 第三章：JUC 显式锁 (Explicit Locks)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#lock-%E6%8E%A5%E5%8F%A3%E4%B8%8E-reentrantlock"><span class="nav-number">3.1.</span> <span class="nav-text"> Lock 接口与 ReentrantLock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#readwritelock-%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">3.2.</span> <span class="nav-text"> ReadWriteLock 读写锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#condition-%E6%9C%BA%E5%88%B6"><span class="nav-number">3.3.</span> <span class="nav-text"> Condition 机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E9%99%8D%E7%BA%A7-%E5%86%99%E9%94%81-%E8%AF%BB%E9%94%81"><span class="nav-number">3.4.</span> <span class="nav-text"> 锁的降级 (写锁 -&gt; 读锁)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%B9%B6%E5%8F%91%E5%8D%8F%E4%BD%9C%E5%B7%A5%E5%85%B7%E7%B1%BB-synchronization-tools"><span class="nav-number">4.</span> <span class="nav-text"> 第四章：并发协作工具类 (Synchronization Tools)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%92%E8%AE%A1%E6%97%B6%E5%99%A8-countdownlatch"><span class="nav-number">4.1.</span> <span class="nav-text"> 倒计时器 CountDownLatch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E6%A0%85%E6%A0%8F-cyclicbarrier"><span class="nav-number">4.2.</span> <span class="nav-text"> 循环栅栏 CyclicBarrier</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F-semaphore"><span class="nav-number">4.3.</span> <span class="nav-text"> 信号量 Semaphore</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E5%90%8C%E6%AD%A5-phaser"><span class="nav-number">4.4.</span> <span class="nav-text"> 阶段同步 Phaser</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2-exchanger"><span class="nav-number">4.5.</span> <span class="nav-text"> 数据交换 Exchanger</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9E%B6%E6%9E%84-executor-framework"><span class="nav-number">5.</span> <span class="nav-text"> 第五章：线程池架构 (Executor Framework)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">5.1.</span> <span class="nav-text"> 为什么要用线程池？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#threadpoolexecutor-%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="nav-number">5.2.</span> <span class="nav-text"> ThreadPoolExecutor 核心参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E4%B8%8E%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="nav-number">5.3.</span> <span class="nav-text"> 线程池工作流程与拒绝策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E7%B1%BB-executors"><span class="nav-number">5.4.</span> <span class="nav-text"> 工厂类 Executors</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#executorservice%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.4.1.</span> <span class="nav-text"> ExecutorService（线程池接口）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#scheduledexecutorservice"><span class="nav-number">5.4.2.</span> <span class="nav-text"> ScheduledExecutorService</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#forkjoinpool-%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3"><span class="nav-number">5.5.</span> <span class="nav-text"> ForkJoinPool (分治思想)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#future"><span class="nav-number">5.6.</span> <span class="nav-text"> Future</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B-asynchronous-programming"><span class="nav-number">6.</span> <span class="nav-text"> 第六章：异步编程 (Asynchronous Programming)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#future-%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="nav-number">6.1.</span> <span class="nav-text"> Future 的局限性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#completablefuture"><span class="nav-number">6.2.</span> <span class="nav-text"> CompletableFuture</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8E%E6%89%A7%E8%A1%8C%E7%AD%96%E7%95%A5"><span class="nav-number">6.2.1.</span> <span class="nav-text"> 异步任务的启动与执行策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E9%93%BE%E8%B7%AF%E7%9A%84%E5%9B%9E%E8%B0%83%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-number">6.2.2.</span> <span class="nav-text"> 异步链路的回调处理机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%9A%84%E9%80%BB%E8%BE%91%E7%BC%96%E6%8E%92%E4%B8%8E%E5%8D%8F%E5%90%8C"><span class="nav-number">6.2.3.</span> <span class="nav-text"> 多任务的逻辑编排与协同</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E9%93%BE%E8%B7%AF%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E4%B8%8E%E5%AE%B9%E9%94%99"><span class="nav-number">6.2.4.</span> <span class="nav-text"> 异步链路的异常捕获与容错</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#completionservice"><span class="nav-number">6.3.</span> <span class="nav-text"> CompletionService</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8-concurrent-collections"><span class="nav-number">7.</span> <span class="nav-text"> 第七章：并发容器 (Concurrent Collections)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#concurrenthashmap-%E5%8E%9F%E7%90%86"><span class="nav-number">7.1.</span> <span class="nav-text"> ConcurrentHashMap 原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#copyonwritearraylist"><span class="nav-number">7.2.</span> <span class="nav-text"> CopyOnWriteArrayList</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97-blockingqueue-%E5%85%A8%E5%AE%B6%E6%A1%B6"><span class="nav-number">7.3.</span> <span class="nav-text"> 阻塞队列 BlockingQueue 全家桶</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%AD%BB%E9%94%81"><span class="nav-number">8.</span> <span class="nav-text"> 第八章 死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">8.1.</span> <span class="nav-text"> 死锁的四大必要条件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-thread%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">9.</span> <span class="nav-text"> 第九章 Thread内存泄漏</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#threadlocal-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%A0%B9%E6%BA%90"><span class="nav-number">9.1.</span> <span class="nav-text"> ThreadLocal 内存泄漏的根源</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Fang Tianyao"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Fang Tianyao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:fty643737159@gmail.com" title="欢迎交流 E-Mail → mailto:fty643737159@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>欢迎交流 E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://geo.ecnu.edu.cn/" title="华东师范大学，地图学与地理信息系统 → https:&#x2F;&#x2F;geo.ecnu.edu.cn&#x2F;" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>华东师范大学，地图学与地理信息系统</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-terminal"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fang Tianyao</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">316k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">9:34</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  











<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">


  

</body>
</html>
