<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|JetBrains Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"atffang.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="介绍常用的 Redis Token Bucket 令牌桶算法">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis：Token Bucket 令牌桶算法">
<meta property="og:url" content="https://atffang.github.io/2026/01/26/RedisTokenBucket/index.html">
<meta property="og:site_name" content="Tianyao&#39; s BLOG">
<meta property="og:description" content="介绍常用的 Redis Token Bucket 令牌桶算法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://atffang.github.io/2026/01/26/RedisTokenBucket/%E7%AE%80%E4%BB%8B.png">
<meta property="og:image" content="https://atffang.github.io/2026/01/26/RedisTokenBucket/output.png">
<meta property="article:published_time" content="2026-01-26T02:21:47.000Z">
<meta property="article:modified_time" content="2026-01-26T04:42:38.477Z">
<meta property="article:author" content="Fang Tianyao">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://atffang.github.io/2026/01/26/RedisTokenBucket/%E7%AE%80%E4%BB%8B.png">

<link rel="canonical" href="https://atffang.github.io/2026/01/26/RedisTokenBucket/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Redis：Token Bucket 令牌桶算法 | Tianyao' s BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Tianyao' s BLOG" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Tianyao' s BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Tianyao</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://atffang.github.io/2026/01/26/RedisTokenBucket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Fang Tianyao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tianyao' s BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis：Token Bucket 令牌桶算法
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2026-01-26 10:21:47 / 修改时间：12:42:38" itemprop="dateCreated datePublished" datetime="2026-01-26T10:21:47+08:00">2026-01-26</time>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>介绍常用的 Redis Token Bucket 令牌桶算法</p>
<span id="more"></span>
<h3 id="intro"><a class="markdownIt-Anchor" href="#intro"></a> Intro</h3>
<p>在众多的限流与流量整形方案中，<span style="color: #BB8ED0; font-weight: bold;">令牌桶算法（Token Bucket Algorithm）</span> 几乎是最常见的。其灵感源自于分组交换网络中的流量控制机制。让Gemini生成了一个科普小漫画：</p>
<img src="/2026/01/26/RedisTokenBucket/%E7%AE%80%E4%BB%8B.png" class="" title="sucessful">
<p>从抽象层面来看，该算法通过维护一个固定容量的容器（即“桶”）来控制请求的通过率。其运作机制包含两个并发的过程：<span style="color: #89986D; font-weight: bold;">令牌的生产</span>与<span style="color: #89986D; font-weight: bold;">令牌的消耗</span>。</p>
<p>系统以一个<strong>恒定的速率</strong>（设为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>，单位为 tokens/sec）向桶中投放令牌。这个速率代表了系统允许的平均处理能力。与此同时，桶具有一个固定的容量上限（设为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>）。这一上限至关重要，它决定了系统能够容忍的最大突发量。当桶满时，新产生的令牌会被丢弃。</p>
<p>当一个请求（或数据包）到达时，它必须尝试从桶中获取一定数量的令牌（通常为 1 个，但在某些基于字节大小限流的场景下，可能对应数据包的大小）。</p>
<ul>
<li><span style="color: #89986D; font-weight: bold;">如果桶内令牌充足</span>，请求获取令牌后将被放行，同时桶内令牌数扣减；</li>
<li><span style="color: #89986D; font-weight: bold;">如果桶内令牌不足</span>，请求则会被拒绝或进入队列等待，具体取决于限流策略是流量监管还是流量整形。</li>
</ul>
<p>在任意时间段 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> 内，令牌桶算法允许通过的最大请求量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 遵循公式：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>N</mi><mo>=</mo><mi>b</mi><mo>+</mo><mi>r</mi><mo>×</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">N = b + r \times T
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></span></p>
<p>令牌桶算法允许在短时间内处理的数据量超过平均速率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>。只要桶内有累积的令牌，系统就能以极快的速度（受限于物理带宽或处理性能）瞬间处理这批请求，直到桶被排空，随后处理速率将回归并被锁定在恒定速率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 上。</p>
<h3 id="redis实现token-bucket"><a class="markdownIt-Anchor" href="#redis实现token-bucket"></a> Redis实现Token Bucket</h3>
<p>在分布式环境下实现令牌桶，最大的敌人是<strong>并发竞争（Race Condition）</strong>。如果两个服务实例同时读取 Redis 中的令牌数，发现都还剩 1 个，于是都决定“放行”并将令牌数减为 0 写回。结果是，原本只能通过 1 个请求，实际上却通过了 2 个。</p>
<p>为了解决这个问题，我们必须利用 Redis 的 <span style="color: #5aa9e6; font-weight: bold;">Lua 脚本</span> 功能。Redis 保证 Lua 脚本在执行过程中是以<strong>原子方式</strong>运行的（其实就是Redis 是单线程处理命令的），这意味着脚本执行期间，不会有其他 Redis 命令插入执行。这相当于在 Redis 服务端加了一把锁。</p>
<div style="background-color: #f7f9fc; border: 1px solid #e1e4e8; border-radius: 15px; padding: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;"><p style="margin-top: 0; margin-bottom: 6px; color: #333; border-bottom: 2px solid #5aa9e6; padding-bottom: 8px; display: inline-block; font-size: 1.1em; font-weight: 600;">Lua脚本</p>
<p style="color: #666; font-size: 0.9em; margin: 8px 0; line-height: 1.5;"><span style="color: #333; font-weight: bold;">Lua是一种轻量级、高效的脚本语言。</span>Lua 的解释器非常小（只有几百 KB），编译后的执行速度极快。在用户想要对redis执行一系列逻辑时，可以把这些逻辑写成一个Lua脚本发给 Redis。Redis 会将整个脚本作为一个原子操作执行。执行期间，其他任何命令都不会被插入。</p>
</div>
<br>
#### 执行流程
<p><span style="color: #89986D; font-weight: bold;">STEP0：定义参数</span></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 参数说明：</span></span><br><span class="line"><span class="comment">-- KEYS[1]: 限流的唯一 Key (例如 rate_limit:api:user_123)</span></span><br><span class="line"><span class="comment">-- ARGV[1]: 桶的容量 (capacity)</span></span><br><span class="line"><span class="comment">-- ARGV[2]: 令牌生成速率 (rate, token/sec)</span></span><br><span class="line"><span class="comment">-- ARGV[3]: 当前请求需要的令牌数 (requested_tokens, 默认 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> capacity = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> rate = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">local</span> requested = <span class="built_in">tonumber</span>(ARGV[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<p><span style="color: #89986D; font-weight: bold;">STEP1：获取时间</span>，调用 Redis 内置的 <code>TIME</code> 命令获取时间戳：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> time_info = redis.call(<span class="string">&#x27;TIME&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> now = <span class="built_in">tonumber</span>(time_info[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>在分布式系统中，应用服务器可能有几十台，它们的系统时间很难做到绝对同步，因此，从redis获取时间是最稳妥的做法。</p>
<p><span style="color: #89986D; font-weight: bold;">STEP2：获取当前桶的状态</span>：使用 <code>HMGET</code> 一次性取出当前桶里剩多少令牌 (<code>tokens</code>)，以及上一次在这个桶里放入令牌是什么时候 (<code>last_refill_time</code>)。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> info = redis.call(<span class="string">&#x27;HMGET&#x27;</span>, key, <span class="string">&#x27;tokens&#x27;</span>, <span class="string">&#x27;last_refill_time&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> current_tokens = <span class="built_in">tonumber</span>(info[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> last_refill_time = <span class="built_in">tonumber</span>(info[<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p><span style="color: #89986D; font-weight: bold;">STEP3：初始化</span>：判断 Redis 里有没有这个 Key。如果 <code>current_tokens</code> 为空，说明这是系统第一次遇到这个请求（或者 Key 过期了）。此时，我们直接把桶填满，并将上次填充时间设为现在。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> current_tokens == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    current_tokens = capacity</span><br><span class="line">    last_refill_time = now</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><span style="color: #89986D; font-weight: bold;">STEP4：惰性填充</span>：计算时间差 (<code>delta</code>)、应补令牌 (<code>filled</code>)、容量限制 (<code>math.min</code>)、更新时间。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> now &gt; last_refill_time <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">local</span> delta = now - last_refill_time</span><br><span class="line">    <span class="keyword">local</span> filled = delta * rate</span><br><span class="line">    current_tokens = <span class="built_in">math</span>.<span class="built_in">min</span>(capacity, current_tokens + filled)</span><br><span class="line">    last_refill_time = now</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><span style="color: #89986D; font-weight: bold;">STEP5：扣减令牌与决策</span>：判断令牌是否足够支持流量通过。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> allowed = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> current_tokens &gt;= requested <span class="keyword">then</span></span><br><span class="line">    current_tokens = current_tokens - requested</span><br><span class="line">    allowed = <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><span style="color: #89986D; font-weight: bold;">STEP6：状态回写与生命周期管理</span>：将计算后的最新令牌数和最新时间写回 Redis，给这个 Key 设置一个过期时间。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis.call(<span class="string">&#x27;HMSET&#x27;</span>, key, <span class="string">&#x27;tokens&#x27;</span>, current_tokens, <span class="string">&#x27;last_refill_time&#x27;</span>, last_refill_time)</span><br><span class="line">redis.call(<span class="string">&#x27;EXPIRE&#x27;</span>, key, <span class="built_in">math</span>.<span class="built_in">ceil</span>(capacity/rate) + <span class="number">60</span>)</span><br><span class="line"><span class="keyword">return</span> allowed</span><br></pre></td></tr></table></figure>
<h4 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h4>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- rate_limit.lua</span></span><br><span class="line"><span class="comment">-- 参数说明：</span></span><br><span class="line"><span class="comment">-- KEYS[1]: 限流的唯一 Key (例如 rate_limit:api:user_123)</span></span><br><span class="line"><span class="comment">-- ARGV[1]: 桶的容量 (capacity)</span></span><br><span class="line"><span class="comment">-- ARGV[2]: 令牌生成速率 (rate, token/sec)</span></span><br><span class="line"><span class="comment">-- ARGV[3]: 当前请求需要的令牌数 (requested_tokens, 默认 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> capacity = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> rate = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">local</span> requested = <span class="built_in">tonumber</span>(ARGV[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取 Redis 服务器当前时间（秒级和微秒级），保证分布式时钟一致性</span></span><br><span class="line"><span class="comment">-- 相比由客户端传入时间，使用 Redis 自身时间能避免服务器时钟不同步问题</span></span><br><span class="line"><span class="keyword">local</span> time_info = redis.call(<span class="string">&#x27;TIME&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> now = <span class="built_in">tonumber</span>(time_info[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取当前桶的剩余令牌数和上次填充时间</span></span><br><span class="line"><span class="keyword">local</span> info = redis.call(<span class="string">&#x27;HMGET&#x27;</span>, key, <span class="string">&#x27;tokens&#x27;</span>, <span class="string">&#x27;last_refill_time&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> current_tokens = <span class="built_in">tonumber</span>(info[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> last_refill_time = <span class="built_in">tonumber</span>(info[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 初始化：如果 key 不存在，说明是第一次访问，默认桶是满的</span></span><br><span class="line"><span class="keyword">if</span> current_tokens == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    current_tokens = capacity</span><br><span class="line">    last_refill_time = now</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 计算惰性填充</span></span><br><span class="line"><span class="keyword">if</span> now &gt; last_refill_time <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">local</span> delta = now - last_refill_time</span><br><span class="line">    <span class="comment">-- 计算这段时间生成的令牌：时间差 * 速率</span></span><br><span class="line">    <span class="keyword">local</span> filled = delta * rate</span><br><span class="line">    <span class="comment">-- 令牌数不能超过桶容量</span></span><br><span class="line">    current_tokens = <span class="built_in">math</span>.<span class="built_in">min</span>(capacity, current_tokens + filled)</span><br><span class="line">    <span class="comment">-- 更新填充时间</span></span><br><span class="line">    last_refill_time = now</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 判断令牌是否足够</span></span><br><span class="line"><span class="keyword">local</span> allowed = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> current_tokens &gt;= requested <span class="keyword">then</span></span><br><span class="line">    current_tokens = current_tokens - requested</span><br><span class="line">    allowed = <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新 Redis 状态</span></span><br><span class="line">redis.call(<span class="string">&#x27;HMSET&#x27;</span>, key, <span class="string">&#x27;tokens&#x27;</span>, current_tokens, <span class="string">&#x27;last_refill_time&#x27;</span>, last_refill_time)</span><br><span class="line"><span class="comment">-- 设置 Key 过期时间（例如 60 秒），防止冷数据长期占用内存</span></span><br><span class="line"><span class="comment">-- 过期时间应至少大于 (capacity / rate)，确保桶满之前不会丢失数据</span></span><br><span class="line">redis.call(<span class="string">&#x27;EXPIRE&#x27;</span>, key, <span class="built_in">math</span>.<span class="built_in">ceil</span>(capacity/rate) + <span class="number">60</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> allowed</span><br></pre></td></tr></table></figure>
<h3 id="springboot-使用-token-bucket"><a class="markdownIt-Anchor" href="#springboot-使用-token-bucket"></a> SpringBoot 使用 Token Bucket</h3>
<p><span style="color: #89986D; font-weight: bold;">STEP0</span>：将 Lua 脚本文件放在 <code>src/main/resources/lua/rate_limit.lua</code></p>
<p><span style="color: #89986D; font-weight: bold;">STEP1</span>：在原本的配置类中通过 <code>DefaultRedisScript</code> 加载它，这样脚本会被预加载到 Redis 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisScriptConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DefaultRedisScript&lt;Long&gt; <span class="title function_">limitScript</span><span class="params">()</span> &#123;</span><br><span class="line">        DefaultRedisScript&lt;Long&gt; redisScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置脚本路径</span></span><br><span class="line">        redisScript.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;lua/rate_limit.lua&quot;</span>));</span><br><span class="line">        <span class="comment">// 设置返回值类型</span></span><br><span class="line">        redisScript.setResultType(Long.class);</span><br><span class="line">        <span class="keyword">return</span> redisScript;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="color: #89986D; font-weight: bold;">STEP2</span>：编写调用工具类，写一个Service，封装调用逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimiterService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DefaultRedisScript&lt;Long&gt; limitScript;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldAllow</span><span class="params">(String key, <span class="type">int</span> capacity, <span class="type">int</span> rate)</span> &#123;</span><br><span class="line">        <span class="comment">// 参数说明：脚本, Key 列表, 参数列表</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">                limitScript,</span><br><span class="line">                Collections.singletonList(key),</span><br><span class="line">                String.valueOf(capacity),</span><br><span class="line">                String.valueOf(rate),</span><br><span class="line">                <span class="string">&quot;1&quot;</span> <span class="comment">// 默认请求 1 个令牌</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result != <span class="literal">null</span> &amp;&amp; result == <span class="number">1L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="color: #89986D; font-weight: bold;">STEP4</span>：编写一个测试，这里我们引入泊松过程模拟，来模仿真实的流量访问，将最大容量设置为100，加入了集中大批量的访问场景，最终模拟结果如下图。</p>
<img src="/2026/01/26/RedisTokenBucket/output.png" class="" title="sucessful">
<p>其中，绿色部分节点为成功访问，而红色的为拒绝访问。可以看到，在刚开始的稳定访问阶段，Token Bucket 的消耗与补充基本处于平衡状态，而在随之而来的集中访问阶段，token 的补充速度远远小于消耗速度，因此，导致了访问失败的情况，从而减少对服务器的流量冲击。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2026/01/16/Kafka1kafka%E6%9E%B6%E6%9E%84%E5%85%A5%E9%97%A8/" rel="prev" title="Kafka架构入门">
      <i class="fa fa-chevron-left"></i> Kafka架构入门
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#intro"><span class="nav-number">1.</span> <span class="nav-text"> Intro</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis%E5%AE%9E%E7%8E%B0token-bucket"><span class="nav-number">2.</span> <span class="nav-text"> Redis实现Token Bucket</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="nav-number">2.1.</span> <span class="nav-text"> 完整代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#springboot-%E4%BD%BF%E7%94%A8-token-bucket"><span class="nav-number">3.</span> <span class="nav-text"> SpringBoot 使用 Token Bucket</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Fang Tianyao"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Fang Tianyao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:fty643737159@gmail.com" title="欢迎交流 E-Mail → mailto:fty643737159@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>欢迎交流 E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://geo.ecnu.edu.cn/" title="华东师范大学，地图学与地理信息系统 → https:&#x2F;&#x2F;geo.ecnu.edu.cn&#x2F;" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>华东师范大学，地图学与地理信息系统</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-terminal"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fang Tianyao</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">316k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">9:34</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  











<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">


  

</body>
</html>
