<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ATField&#39; s BLOG</title>
  
  <subtitle>ATField</subtitle>
  <link href="https://atffang.github.io/atom.xml" rel="self"/>
  
  <link href="https://atffang.github.io/"/>
  <updated>2025-05-11T14:30:58.568Z</updated>
  <id>https://atffang.github.io/</id>
  
  <author>
    <name>FangTianYao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>geohash与geotree</title>
    <link href="https://atffang.github.io/2025/05/10/geohash%E4%B8%8Egeotree/"/>
    <id>https://atffang.github.io/2025/05/10/geohash%E4%B8%8Egeotree/</id>
    <published>2025-05-10T15:50:09.000Z</published>
    <updated>2025-05-11T14:30:58.568Z</updated>
    
    <content type="html"><![CDATA[<h3 id="geohash"><a class="markdownIt-Anchor" href="#geohash"></a> Geohash</h3><p><strong>Geohash</strong> 是一种将二维地理坐标（经度 Longitude 和 纬度 Latitude）编码为一个可排序的字符串的空间索引方法。由 Gustavo Niemeyer 于 2008 年提出，并被广泛用于分布式地理数据索引、近邻搜索、区域聚合等场景。</p><p>核心特征为：</p><ul><li>编码结果是<strong>Base32 字符串</strong></li><li>字符越多，<strong>空间精度越高</strong></li><li>相近位置编码字符串有<strong>公共前缀</strong></li></ul><h4 id="geohash-编码原理"><a class="markdownIt-Anchor" href="#geohash-编码原理"></a> Geohash 编码原理</h4><p>Geohash 使用<strong>经纬度交替二分</strong>的方式，将整个地球的经纬度范围不断缩小，直到定位到目标点。过程主要分为以下 4 步：</p><p><strong>步骤 1：初始化经纬度范围</strong></p><ul><li>经度范围 lon_range = [-180, 180]</li><li>纬度范围 lat_range = [-90, 90]</li></ul><p><strong>步骤 2：交替二分编码，生成二进制序列</strong><br />使用**二分法（Binary Search）**编码纬度和经度：</p><ul><li>从经度开始（偶数位处理经度，奇数位处理纬度）</li><li>每次比较当前坐标是否大于区间中点，如果是，记为 1，否则为 0</li><li>并更新范围（左/右半区）<br />这个过程交替进行直到你得到足够数量的位，比如 5 位 * 7 字符 = 35 位。</li></ul><p><strong>步骤 3：每 5 位为一组，转为十进制索引</strong><br />将所得的长二进制串，<strong>每 5 位一组</strong>，转为十进制，然后用 Base32 映射表替换。</p><p><strong>步骤 4：生成最终字符串</strong><br />每 5 位 → 1 个字符，共 n 个字符（通常精度为 6~9 个字符）。</p><h4 id="geohash优点"><a class="markdownIt-Anchor" href="#geohash优点"></a> Geohash优点</h4><p><strong>1.</strong> <strong>支持空间邻近查询</strong></p><ul><li>Geohash 编码相邻的区域通常具有<strong>相似前缀</strong>，适合使用前缀匹配（如 LIKE ‘wx4g0%’）实现快速范围查询。</li><li>特别适合在数据库中对空间对象做索引。</li></ul><p><strong>2.</strong>  <strong>分级精度（多级网格）</strong></p><ul><li>编码长度越长，表示区域越小，精度越高。</li><li>可动态控制精度，适合不同缩放层级的空间分析。</li></ul><p><strong>3.</strong>  <strong>文本存储，易于索引</strong></p><ul><li>Geohash 是字符串格式，便于存储、索引（B-Tree、Trie）、压缩和分布式传输。</li></ul><p><strong>4.</strong> <strong>无依赖的数据结构</strong></p><ul><li>不依赖复杂的空间数据结构（如 R-Tree、QuadTree），适用于轻量级地理索引服务。</li></ul><p><strong>5.</strong> <strong>适合分布式系统</strong></p><ul><li>Geohash 可直接用于 Sharding，例如前缀作为分片 key，天然适配大数据平台如 HBase、Elasticsearch。</li></ul><h4 id="geohash的不足"><a class="markdownIt-Anchor" href="#geohash的不足"></a> Geohash的不足</h4><p><strong>1.</strong> <strong>经纬度不均匀映射</strong></p><ul><li>纬度范围 [-90, 90]，经度 [-180, 180]，导致赤道附近一个 Geohash 单元的面积大于极地。</li><li>地球是球体，Geohash 假设平面映射，有畸变。</li></ul><p><strong>2.</strong>  <strong>边界误差问题</strong></p><ul><li>相邻的两个地理位置如果落在不同的 Geohash 网格单元中，会出现<strong>编码前缀差异</strong>，影响邻近判断。</li><li>需要额外处理“邻居格子”。</li></ul><p><strong>3.</strong> <strong>形状不规则</strong></p><ul><li>Geohash 网格在地图上是<strong>长方形</strong>而非正方形，且每一级的比例不均一，查询时常需额外扩大范围。</li></ul><p><strong>4.</strong>  <strong>二维信息压缩成一维有信息损失</strong></p><ul><li>经纬度交替合并会丢失部分空间关系（例如正方形邻域判断更复杂）。</li></ul><p><strong>5.</strong> <strong>精度和效率权衡</strong></p><ul><li>长 Geohash 字符串意味着更高精度，但也带来索引增长和性能损耗问题。</li></ul><p>总的来说，Geohash 是一种优雅的地理编码方案，它以轻量、易索引的方式，在现代数据库和分布式系统中广泛应用。然而，在面对高精度、复杂空间关系时，它也暴露出一定的局限性。因此，在实际使用中，应结合业务需求，评估其合适性，并配合如邻接格补全、R-Tree 等技术优化空间查询性能。</p><h3 id="geotree"><a class="markdownIt-Anchor" href="#geotree"></a> GeoTree</h3><p><strong>GeoTree</strong> 是一种基于空间层级划分的地理编码体系，它将地球表面按不同层级进行规则划分，并通过编码的方式表达空间单元的层级和位置关系。相比 Geohash 等网格编码，GeoTree 更强调“树结构”和“地理拓扑”的结合，适用于需要空间聚合、路径查询、空间层次建模的应用场景。</p><p>GeoTree 的思想与四叉树（QuadTree）类似，但更灵活，支持<strong>多尺度编码</strong>与<strong>空间父子继承关系表达</strong>，广泛用于如地空一体化管理、空域划分、地理分区治理等空间应用。</p><h4 id="核心特征"><a class="markdownIt-Anchor" href="#核心特征"></a> <strong>核心特征：</strong></h4><ul><li>每个节点表示一个空间区域，节点 ID 为<strong>可排序的字符串或整数</strong></li><li>子区域编码在父编码基础上扩展（<strong>继承性编码</strong>）</li><li>层级结构清晰，便于表示“包含关系”和<strong>层次聚合</strong></li><li>支持<strong>三维空间索引</strong>（经度、纬度、高度）</li></ul><h4 id="geotree-编码原理"><a class="markdownIt-Anchor" href="#geotree-编码原理"></a> <strong>GeoTree 编码原理</strong></h4><p>GeoTree 并非采用经纬度交替压缩为二进制，而是按照空间网格划分规则，分层递归构建编码。过程一般如下：<br /><strong>步骤 1：定义根层空间范围（Level 0）</strong></p><ul><li>将地球划分为若干大格（如全球 8 区或全球 6 面体）</li><li>每个大格分配一个唯一编码（如 “1”、“A”、“R0”）</li></ul><p><strong>步骤 2：递归划分子区域（Level 1~n）</strong></p><ul><li>每个区域根据固定或可变规则继续划分为子区域（如 4 等分、9 等分、3D 立方等）</li><li>子区域编码在父编码基础上追加子代标识（如 “1-3” 表示根节点 1 的第 3 个子区）</li></ul><p><strong>步骤 3：形成空间编码树</strong></p><ul><li>所有区域构成一棵空间树：根为地球、分支为区域、叶子为最小单元</li><li>编码如 A-1-2-0 表示：区域 A → 子区 1 → 子区 2 → 子区 0</li></ul><p><strong>步骤 4：支持三维编码（可选）</strong></p><ul><li>对于需要高空建模的场景，每层子区可增加“高度切分”，编码如：A-1-2-0-H2</li></ul><h4 id="geotree-的优势"><a class="markdownIt-Anchor" href="#geotree-的优势"></a> <strong>GeoTree 的优势</strong></h4><p><strong>1.</strong>  <strong>天然支持空间层次结构</strong></p><ul><li>每个编码天然携带层级信息，如 A-2-3 表示第 2 层、第 3 区</li><li>支持区域归属、包含、父子导航等空间树操作</li></ul><p><strong>2.</strong> <strong>邻接关系明确，便于空间合并</strong></p><ul><li>可快速判断相邻区域是否有共同父节点，从而实现区域合并、聚合分析</li></ul><p><strong>3.</strong> <strong>便于多尺度查询</strong></p><ul><li>查询精度可控制在某一层级，例如只查询第 3 层的所有编码</li></ul><p><strong>4.</strong> <strong>编码形式灵活</strong></p><ul><li>可以使用字符串（如 “E-3-1”）或整型编码（如位运算 0b010101）支持高效索引</li></ul><p><strong>5.</strong> <strong>支持三维空间编码</strong></p><ul><li>除经纬度之外，GeoTree 可扩展高度维度，适用于低空空域、建筑分层、空间管网等场景</li></ul><p><strong>6.</strong> <strong>更强的空间拓扑表达能力</strong></p><ul><li>相比 Geohash 的“前缀相似”，GeoTree 明确建模空间父子关系，有助于空间推理和规划控制</li></ul><h4 id="geotree-的不足"><a class="markdownIt-Anchor" href="#geotree-的不足"></a> <strong>GeoTree 的不足</strong></h4><p><strong>1.</strong> <strong>空间分区规则需自定义</strong></p><ul><li>没有标准化的编码划分规则，不同业务可能用不同树型划分方式</li></ul><p><strong>2.</strong> <strong>区域形状不规则</strong></p><ul><li>编码背后代表的空间单元可能非正方形（视分割策略），可能导致某些计算复杂</li></ul><p><strong>3.</strong> <strong>实现成本略高</strong></p><ul><li>相比 Geohash 纯字符串压缩，GeoTree 需要维护树结构、支持路径解析和层级操作</li></ul><p><strong>4.</strong> <strong>邻接格查找略繁琐</strong></p><ul><li>查找空间邻居不像 Geohash 可以通过简单变换字符实现，而需要访问同层兄弟节点</li></ul><p>GeoTree 是一种<strong>结构化、层级化、拓扑清晰的地理编码体系</strong>，它从空间组织结构出发，更适合表达“地理分区与归属”这一类场景。在复杂区域管理、空间权限控制、多尺度数据建模等领域，比 Geohash 更具表达力。<br />然而，由于 GeoTree 没有统一标准实现，初始设计需结合业务规则规划编码体系。在面向大规模分布式查询的场景下，GeoTree 可与 Geohash 等轻量编码联合使用，取长补短，实现高效、结构清晰的空间信息处理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;geohash&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#geohash&quot;&gt;&lt;/a&gt; Geohash&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Geohash&lt;/strong&gt; 是一种将二维地理坐标（经度 Longitude 和 纬度 Lat</summary>
      
    
    
    
    <category term="空间分析与GIS算法" scheme="https://atffang.github.io/categories/%E7%A9%BA%E9%97%B4%E5%88%86%E6%9E%90%E4%B8%8EGIS%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Python中的闭包</title>
    <link href="https://atffang.github.io/2025/05/09/Python%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/"/>
    <id>https://atffang.github.io/2025/05/09/Python%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/</id>
    <published>2025-05-09T02:39:33.000Z</published>
    <updated>2025-05-09T03:06:18.554Z</updated>
    
    <content type="html"><![CDATA[<p>Python中的闭包机制简介</p><span id="more"></span><h3 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h3><p>闭包（<strong>Closure</strong>）是 Python 中一个非常重要且常用的概念，它是函数式编程的核心特性之一。闭包是一个函数，它“记住”了它被创建时的环境，即使在其环境之外被调用，这些变量仍然可用。换句话说：<strong>一个函数返回了另一个函数，这个返回的函数引用了其外部函数的变量</strong>，这个内部函数就是一个闭包。</p><p><strong>闭包的三个必要条件</strong>：</p><ol><li><strong>嵌套函数</strong>：函数内部定义了另一个函数；</li><li><strong>内部函数引用了外部函数的变量（自由变量）</strong>；</li><li><strong>外部函数返回了内部函数</strong>。</li></ol><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">y</span>):</span><br><span class="line">        <span class="keyword">return</span> x + y  <span class="comment"># inner 使用了 outer 的变量 x</span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">f = outer(<span class="number">10</span>)  <span class="comment"># outer 返回了 inner 函数</span></span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">5</span>))    <span class="comment"># 输出 15，等于 10 + 5</span></span><br></pre></td></tr></table></figure><p>每当函数内部引用了外部作用域的变量时，Python 会将这些变量“捕获”并保存在闭包中。<br />我们可以用函数的 <strong>closure</strong> 属性查看闭包中存储的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(f.__closure__[<span class="number">0</span>].cell_contents)  <span class="comment"># 输出 10</span></span><br></pre></td></tr></table></figure><h3 id="usage"><a class="markdownIt-Anchor" href="#usage"></a> Usage</h3><h4 id="数据隐藏类似于私有变量"><a class="markdownIt-Anchor" href="#数据隐藏类似于私有变量"></a> 数据隐藏（类似于私有变量）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_counter</span>():</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">counter</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> count</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line"></span><br><span class="line">c1 = make_counter()</span><br><span class="line"><span class="built_in">print</span>(c1())  <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(c1())  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">c2 = make_counter()</span><br><span class="line"><span class="built_in">print</span>(c2())  <span class="comment"># 1（新的闭包）</span></span><br></pre></td></tr></table></figure><p>如果你在一个函数内定义了另一个函数（形成闭包），而你想<strong>在内部函数中修改外部函数的变量</strong>，就需要用 nonlocal 来声明这个变量。nonlocal 是 Python 3 中引入的一个关键字，用于在<strong>嵌套函数中声明一个变量不是局部变量</strong>，而是来自于<strong>最近一层的外部（非全局）作用域</strong>。</p><h4 id="回调函数"><a class="markdownIt-Anchor" href="#回调函数"></a> 回调函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_multiplier</span>(<span class="params">factor</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">multiply</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="keyword">return</span> n * factor</span><br><span class="line">    <span class="keyword">return</span> multiply</span><br><span class="line"></span><br><span class="line">double = make_multiplier(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(double(<span class="number">10</span>))  <span class="comment"># 20</span></span><br></pre></td></tr></table></figure><h4 id="函数工厂"><a class="markdownIt-Anchor" href="#函数工厂"></a> 函数工厂</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">power_factory</span>(<span class="params">exp</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> x ** exp</span><br><span class="line">    <span class="keyword">return</span> power</span><br><span class="line"></span><br><span class="line">square = power_factory(<span class="number">2</span>)</span><br><span class="line">cube = power_factory(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(square(<span class="number">5</span>))  <span class="comment"># 25</span></span><br><span class="line"><span class="built_in">print</span>(cube(<span class="number">2</span>))    <span class="comment"># 8</span></span><br></pre></td></tr></table></figure><h4 id="装饰器的本质也是闭包"><a class="markdownIt-Anchor" href="#装饰器的本质也是闭包"></a> 装饰器的本质也是闭包！</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Before function call&quot;</span>)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;After function call&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@my_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">greet(<span class="string">&quot;Alice&quot;</span>)</span><br></pre></td></tr></table></figure><p>进一步的，我们可以使用装饰器来为函数计时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start = time.time()  <span class="comment"># 开始时间</span></span><br><span class="line">        result = func(*args, **kwargs)  <span class="comment"># 调用被装饰的函数</span></span><br><span class="line">        end = time.time()  <span class="comment"># 结束时间</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;函数 `<span class="subst">&#123;func.__name__&#125;</span>` 运行耗时：<span class="subst">&#123;end - start:<span class="number">.6</span>f&#125;</span> 秒&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">slow_function</span>():</span><br><span class="line">    time.sleep(<span class="number">2</span>)  <span class="comment"># 模拟耗时操作</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务完成&quot;</span>)</span><br><span class="line"></span><br><span class="line">slow_function()</span><br></pre></td></tr></table></figure><p>再进一步的，我们对装饰器进行增强，使其能够同时实现：</p><ul><li>✅ 打印日志（函数名称和参数）</li><li>⏱ 计时执行时间</li><li>⚠️ 自动捕获异常并打印错误信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log_timer_exception</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[LOG] 正在调用函数 `<span class="subst">&#123;func.__name__&#125;</span>`&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[LOG] 参数: args=<span class="subst">&#123;args&#125;</span>, kwargs=<span class="subst">&#123;kwargs&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        start_time = time.time()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            result = func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[ERROR] 函数 `<span class="subst">&#123;func.__name__&#125;</span>` 执行出错: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            traceback.print_exc()</span><br><span class="line">            result = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[LOG] 函数 `<span class="subst">&#123;func.__name__&#125;</span>` 返回结果: <span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            end_time = time.time()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[TIME] 函数 `<span class="subst">&#123;func.__name__&#125;</span>` 执行耗时: <span class="subst">&#123;end_time - start_time:<span class="number">.6</span>f&#125;</span> 秒\n&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@log_timer_exception</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br><span class="line"></span><br><span class="line"><span class="meta">@log_timer_exception</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sleep_task</span>(<span class="params">seconds</span>):</span><br><span class="line">    time.sleep(seconds)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;休眠 <span class="subst">&#123;seconds&#125;</span> 秒完成&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">divide(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">divide(<span class="number">10</span>, <span class="number">0</span>)  <span class="comment"># 除零错误</span></span><br><span class="line"></span><br><span class="line">sleep_task(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[LOG] 正在调用函数 `divide`</span><br><span class="line">[LOG] 参数: args=(10, 2), kwargs=&#123;&#125;</span><br><span class="line">[LOG] 函数 `divide` 返回结果: 5.0</span><br><span class="line">[TIME] 函数 `divide` 执行耗时: 0.000002 秒</span><br><span class="line"></span><br><span class="line">[LOG] 正在调用函数 `divide`</span><br><span class="line">[LOG] 参数: args=(10, 0), kwargs=&#123;&#125;</span><br><span class="line">[ERROR] 函数 `divide` 执行出错: division by zero</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line">[TIME] 函数 `divide` 执行耗时: 0.000004 秒</span><br></pre></td></tr></table></figure><h4 id="闭包lamba表达式"><a class="markdownIt-Anchor" href="#闭包lamba表达式"></a> 闭包+lamba表达式</h4><p>lambda 常用于创建简单闭包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_adder</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> y: x + y</span><br><span class="line"></span><br><span class="line">add5 = make_adder(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(add5(<span class="number">3</span>))  <span class="comment"># 8</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Python中的闭包机制简介&lt;/p&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
  <entry>
    <title>工厂函数与工厂方法</title>
    <link href="https://atffang.github.io/2025/05/09/%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0/"/>
    <id>https://atffang.github.io/2025/05/09/%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0/</id>
    <published>2025-05-09T01:51:56.000Z</published>
    <updated>2025-05-09T03:16:35.605Z</updated>
    
    <content type="html"><![CDATA[<p>本文以python为例，简单介绍工厂函数。</p><span id="more"></span><h3 id="工厂函数"><a class="markdownIt-Anchor" href="#工厂函数"></a> 工厂函数</h3><p>工厂函数（Factory Function）是一种常见的设计模式，尤其适用于面向对象编程和函数式编程场景中，用来 <strong>动态创建对象</strong> 或 <strong>封装复杂初始化逻辑</strong>。</p><h4 id="definition"><a class="markdownIt-Anchor" href="#definition"></a> Definition</h4><p>工厂函数本质上是一个<strong>返回对象的函数</strong>，而不是类的构造函数（<strong>init</strong>）。它根据传入的参数决定返回什么类型或配置的对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">animal_factory</span>(<span class="params">animal_type</span>):</span><br><span class="line">    <span class="keyword">if</span> animal_type == <span class="string">&quot;dog&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> Dog()</span><br><span class="line">    <span class="keyword">elif</span> animal_type == <span class="string">&quot;cat&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> Cat()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Unknown animal type&quot;</span>)</span><br></pre></td></tr></table></figure><p>工厂函数的优势在于：</p><ol><li><strong>封装复杂逻辑</strong>：隐藏创建对象所需的复杂初始化步骤；</li><li><strong>运行时类型决定</strong>：可以在运行时根据参数决定返回何种子类；</li><li><strong>返回同一类的多个变种</strong>：支持不同配置、不同状态的实例；</li><li><strong>替代类继承</strong>：在某些函数式编程场景中，不用类继承，也可以通过工厂函数生成封装好的行为；</li><li><strong>支持缓存或单例</strong>：结合缓存机制（比如字典）可复用实例。</li></ol><h4 id="usage"><a class="markdownIt-Anchor" href="#usage"></a> Usage</h4><p>数据库连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MySQLConnection</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MySQL connected&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PostgreSQLConnection</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;PostgreSQL connected&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">db_connection_factory</span>(<span class="params">db_type</span>):</span><br><span class="line">    <span class="keyword">if</span> db_type == <span class="string">&quot;mysql&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> MySQLConnection()</span><br><span class="line">    <span class="keyword">elif</span> db_type == <span class="string">&quot;postgres&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> PostgreSQLConnection()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Unsupported DB type&quot;</span>)</span><br><span class="line"></span><br><span class="line">conn = db_connection_factory(<span class="string">&quot;mysql&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(conn.connect())  <span class="comment"># 输出: MySQL connected</span></span><br></pre></td></tr></table></figure><p>工厂函数封装初始化参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_logger</span>(<span class="params">log_type=<span class="string">&quot;file&quot;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> log_type == <span class="string">&quot;file&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span> msg: <span class="built_in">print</span>(<span class="string">f&quot;[FILE] <span class="subst">&#123;datetime.now()&#125;</span>: <span class="subst">&#123;msg&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> log_type == <span class="string">&quot;console&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span> msg: <span class="built_in">print</span>(<span class="string">f&quot;[CONSOLE] <span class="subst">&#123;datetime.now()&#125;</span>: <span class="subst">&#123;msg&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Unknown log type&quot;</span>)</span><br><span class="line"></span><br><span class="line">logger = create_logger(<span class="string">&quot;console&quot;</span>)</span><br><span class="line">logger(<span class="string">&quot;Something happened&quot;</span>)  <span class="comment"># 输出: [CONSOLE] 时间: Something happened</span></span><br></pre></td></tr></table></figure><p>结合缓存，返回单例或共享对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">_instances = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">singleton_factory</span>(<span class="params">cls</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_instance</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> _instances:</span><br><span class="line">            _instances[cls] = cls(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> _instances[cls]</span><br><span class="line">    <span class="keyword">return</span> get_instance</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton_factory</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Configuration</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.settings = &#123;&#125;</span><br><span class="line"></span><br><span class="line">config1 = Configuration()</span><br><span class="line">config2 = Configuration()</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> config1 <span class="keyword">is</span> config2</span><br></pre></td></tr></table></figure><h4 id="在类中使用工厂函数"><a class="markdownIt-Anchor" href="#在类中使用工厂函数"></a> 在类中使用工厂函数</h4><p>现在有一需求，我们想为每个宠物自动分配一个出生时间，给它一个独立的玩具箱（字典），这些值在每次创建时应该不同。<br />✅ 正确做法：使用<strong>default_factory</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass, field</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pet</span>:</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    kind: <span class="built_in">str</span>  <span class="comment"># &quot;cat&quot; or &quot;dog&quot;</span></span><br><span class="line">    born_time: datetime = field(default_factory=datetime.now)</span><br><span class="line">    toys: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">int</span>] = field(default_factory=<span class="built_in">dict</span>)  <span class="comment"># 玩具名 -&gt; 数量</span></span><br></pre></td></tr></table></figure><p><strong>field函数</strong>: 使用 field(default_factory=datetime.now) 表示：每次创建 Pet 实例时，都调用 datetime.now() 来自动生成时间戳（不是在类加载时就固定）。</p><p>field 是 Python dataclasses 模块中的一个函数，用来<strong>给类的属性定义更复杂的行为或默认值</strong>。default_factory 是 field() 函数的一个<strong>参数</strong>，它的作用是指定一个“工厂函数”，每次创建 dataclass 实例时调用它来生成字段的默认值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat = Pet(name=<span class="string">&quot;Mimi&quot;</span>, kind=<span class="string">&quot;cat&quot;</span>)</span><br><span class="line">dog = Pet(name=<span class="string">&quot;Doudou&quot;</span>, kind=<span class="string">&quot;dog&quot;</span>)</span><br><span class="line"></span><br><span class="line">cat.toys[<span class="string">&quot;ball&quot;</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cat.born_time)     <span class="comment"># 每个宠物自己的出生时间</span></span><br><span class="line"><span class="built_in">print</span>(dog.born_time)     <span class="comment"># 不同时间</span></span><br><span class="line"><span class="built_in">print</span>(dog.toys)          <span class="comment"># &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cat.toys <span class="keyword">is</span> dog.toys)  <span class="comment"># False ✅，玩具箱不共享</span></span><br></pre></td></tr></table></figure><p>❌ 错误示范：不使用default_factory，所有宠物共享玩具箱和出生时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BrokenPet</span>:</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    kind: <span class="built_in">str</span></span><br><span class="line">    born_time: datetime = datetime.now()  <span class="comment"># ❌ 类加载时固定</span></span><br><span class="line">    toys: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">int</span>] = &#123;&#125;             <span class="comment"># ❌ 所有宠物共享一套玩具</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat = BrokenPet(name=<span class="string">&quot;Mimi&quot;</span>, kind=<span class="string">&quot;cat&quot;</span>)</span><br><span class="line">dog = BrokenPet(name=<span class="string">&quot;Doudou&quot;</span>, kind=<span class="string">&quot;dog&quot;</span>)</span><br><span class="line"></span><br><span class="line">cat.toys[<span class="string">&quot;fish&quot;</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dog.toys)  <span class="comment"># ❌ &#123;&#x27;fish&#x27;: 1&#125;，狗和猫共用玩具箱</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cat.born_time == dog.born_time)  <span class="comment"># True ❌，出生时间完全相同</span></span><br></pre></td></tr></table></figure><p>有时人们会混淆<strong>类属性</strong>和<strong>实例属性</strong>，导致共享值错误！！！！</p><h3 id="工厂方法"><a class="markdownIt-Anchor" href="#工厂方法"></a> 工厂方法</h3><p><strong>厂方法模式（Factory Method Pattern</strong>本质是定义一个接口（抽象方法），让子类决定要实例化的类：</p><ul><li>是 GoF 的正式设计模式之一；</li><li>基于类继承；</li><li>通常用在面向对象的架构中；</li><li>Python中可以用 abc（抽象基类）来实现。</li></ul><p>一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Woof&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Meow&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 工厂方法基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnimalFactory</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_animal</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogFactory</span>(<span class="title class_ inherited__">AnimalFactory</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_animal</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> Dog()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CatFactory</span>(<span class="title class_ inherited__">AnimalFactory</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_animal</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> Cat()</span><br><span class="line"></span><br><span class="line">factory = DogFactory()</span><br><span class="line">animal = factory.create_animal()</span><br><span class="line"><span class="built_in">print</span>(animal.speak())  <span class="comment"># 输出：Woof</span></span><br></pre></td></tr></table></figure><p>DogFactory 和 CatFactory 继承了 AnimalFactory，并各自实现了创建逻辑。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文以python为例，简单介绍工厂函数。&lt;/p&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
  <entry>
    <title>详解Python类的装饰器和魔法方法</title>
    <link href="https://atffang.github.io/2025/03/30/%E8%AF%A6%E8%A7%A3Python%E7%B1%BB%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"/>
    <id>https://atffang.github.io/2025/03/30/%E8%AF%A6%E8%A7%A3Python%E7%B1%BB%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/</id>
    <published>2025-03-30T07:51:52.000Z</published>
    <updated>2025-03-30T07:55:53.030Z</updated>
    
    <content type="html"><![CDATA[<p>介绍一下Python类的装饰器和魔法方法，以及参数的下划线前缀</p><span id="more"></span><p>一个记性并不好的人将在工作中学习到的碎片化的知识统筹起来必须要依靠记录，非常不幸的是鄙人在记忆力不强的前提下依然没有良好的记录习惯，加之跑通万岁的实用主义，使得写的代码总是看起来比较低级而缺乏优雅的气息，与本人气质强烈不符。痛定思痛，痛改前非，先从一个相对基础但极其重要的机制开始记起：Python中类的装饰器与魔法方法。</p><h3 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h3><h4 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h4><p>在 Python 中，类是面向对象编程（OOP）的核心概念，它用于定义对象的蓝图。类封装了数据（属性）和行为（方法），通过类可以创建多个具有相同结构的实例对象。通过使用类，代码可以更具组织性和模块化，易于扩展和维护。</p><p>在 Python 中定义一个基本的类非常简单，使用关键字 <code>class</code> 进行定义。以下是一个简单的类定义的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="comment"># 这是一个类属性</span></span><br><span class="line">    class_variable = <span class="string">&quot;I am a class variable&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这是初始化方法（构造函数），当类实例化时会自动调用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="comment"># 这是实例属性</span></span><br><span class="line">        self.instance_variable = value</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这是一个实例方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">instance_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;This is an instance method and instance_variable is: <span class="subst">&#123;self.instance_variable&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这是一个类方法，使用 @classmethod 装饰器定义</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">class_method</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;This is a class method and class_variable is: <span class="subst">&#123;cls.class_variable&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这是一个静态方法，使用 @staticmethod 装饰器定义</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">static_method</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;This is a static method&quot;</span></span><br></pre></td></tr></table></figure><p>在上述代码中，展现了类的各个组成部分为：</p><ul><li><p><strong>类属性</strong>：</p><ul><li>类属性是类级别的属性，它们对于所有实例都是共享的。类属性通常定义在类体中，独立于任何方法。</li><li>在上例中，<code>class_variable</code> 就是一个类属性，所有对象共享同一个值。</li></ul></li><li><p><strong>实例属性</strong>：</p><ul><li>实例属性是在类的实例化过程中通过 <code>__init__()</code> 方法（也叫构造函数）动态创建的，每个实例有独立的属性值。</li><li>通过 <code>self.instance_variable = value</code>，我们为每个实例赋予不同的 <code>instance_variable</code> 值。</li></ul></li><li><p><strong>实例方法</strong>：</p><ul><li>实例方法是类中定义的普通方法，它们操作实例属性，且必须接受参数 <code>self</code>，<code>self</code> 代表的是实例本身。</li><li>实例方法通常用于定义对象的行为。</li></ul></li><li><p><strong>类方法</strong>：</p><ul><li>类方法是作用于类本身的方法，使用 <code>@classmethod</code> 装饰器定义。它接收 <code>cls</code> 参数，表示类对象，而不是实例对象。</li><li>类方法可以访问和修改类属性。</li></ul></li><li><p><strong>静态方法</strong>：</p><ul><li>静态方法是类中的方法，但它既不依赖类属性也不依赖实例属性。静态方法使用<code>@staticmethod</code> 装饰器定义，通常用于执行与类相关但不需要访问类或实例的逻辑。</li></ul></li></ul><p>通过实例化类，可以获得对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实例化类，创建对象</span></span><br><span class="line">obj1 = MyClass(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">obj2 = MyClass(<span class="string">&quot;World&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>类</strong> 是抽象的模板，用于创建对象，它定义了对象的属性和行为。</li><li><strong>对象</strong> 是类的实例，每个对象都有自己独立的属性值和行为表现。</li></ul><h4 id="类的继承inheritance"><a class="markdownIt-Anchor" href="#类的继承inheritance"></a> 类的继承（Inheritance）</h4><p>继承是面向对象编程的核心概念之一，它允许一个类继承另一个类的属性和方法，从而避免代码重复，并能够对现有的类进行扩展。被继承的类称为<strong>父类（基类或超类）</strong>，继承的类称为<strong>子类（派生类）</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> makes a sound.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义子类，继承父类 Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> barks.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> meows.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化子类</span></span><br><span class="line">dog = Dog(<span class="string">&quot;Buddy&quot;</span>)</span><br><span class="line">cat = Cat(<span class="string">&quot;Whiskers&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dog.speak())  <span class="comment"># 输出: Buddy barks.</span></span><br><span class="line"><span class="built_in">print</span>(cat.speak())  <span class="comment"># 输出: Whiskers meows.</span></span><br></pre></td></tr></table></figure><p>继承的特点：</p><ul><li>子类继承父类的所有属性和方法，并且可以<strong>重写</strong>（override）父类的方法。</li><li>可以通过 <code>super()</code> 调用父类的方法。</li><li>支持多重继承，子类可以从多个父类继承。</li></ul><h4 id="类的多态polymorphism"><a class="markdownIt-Anchor" href="#类的多态polymorphism"></a> 类的多态（Polymorphism）</h4><p>多态允许不同的类实现相同的方法，而表现出不同的行为。它是一种编程能力，能够让相同的接口对不同的数据类型做出不同的响应，具体行为由具体的对象来决定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&quot;Subclass must implement this method.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Woof!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Meow!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">animal_sound</span>(<span class="params">animal</span>):</span><br><span class="line">    <span class="built_in">print</span>(animal.speak())</span><br><span class="line"></span><br><span class="line">dog = Dog()</span><br><span class="line">cat = Cat()</span><br><span class="line"></span><br><span class="line">animal_sound(dog)  <span class="comment"># 输出: Woof!</span></span><br><span class="line">animal_sound(cat)  <span class="comment"># 输出: Meow!</span></span><br></pre></td></tr></table></figure><h4 id="抽象类abstract-class"><a class="markdownIt-Anchor" href="#抽象类abstract-class"></a> 抽象类（Abstract Class）</h4><p>抽象类是不能被实例化的类，它用于定义方法的模板，而子类必须实现这些方法。Python 通过 <code>abc</code> 模块中的 <code>ABC</code> 类和 <code>abstractmethod</code> 装饰器来实现抽象类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Woof!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Meow!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># animal = Animal()  # 这会抛出错误，因为抽象类不能实例化</span></span><br><span class="line">dog = Dog()</span><br><span class="line"><span class="built_in">print</span>(dog.speak())  <span class="comment"># 输出: Woof!</span></span><br></pre></td></tr></table></figure><ul><li>抽象类定义了抽象方法，子类必须实现这些抽象方法。</li><li>抽象类提供了代码结构的基础框架，具体实现由子类负责。</li></ul><h4 id="组合composition"><a class="markdownIt-Anchor" href="#组合composition"></a> 组合（Composition）</h4><p>组合是一种设计原则，通过将对象的实例作为其他类的属性来实现。这种方法允许类之间的松散耦合。相比继承，组合通常提供了更大的灵活性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Engine started&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.engine = Engine()  <span class="comment"># 将 Engine 类实例作为 Car 的属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.engine.start()</span><br><span class="line"></span><br><span class="line">car = Car()</span><br><span class="line"><span class="built_in">print</span>(car.start())  <span class="comment"># 输出: Engine started</span></span><br></pre></td></tr></table></figure><h3 id="装饰器"><a class="markdownIt-Anchor" href="#装饰器"></a> 装饰器</h3><h4 id="装饰器的定义"><a class="markdownIt-Anchor" href="#装饰器的定义"></a> 装饰器的定义</h4><p>在 Python 中，<strong>装饰器</strong>（Decorator）是一种函数，允许你在不修改原有函数代码的情况下，动态地增加或修改该函数的功能。简单来说，装饰器是用来&quot;包装&quot;其他函数的函数，它允许你在运行时增加函数的功能，通常用于日志记录、权限检查、缓存、计时等功能。</p><p>装饰器本质上是一个函数，它接受一个函数作为输入，并返回一个新的函数（通常是原函数的增强版本）。这种方式可以帮助我们在不改变原函数代码的前提下，对其进行修改或扩展。</p><p>在 Python 中，装饰器使用 <code>@decorator_name</code> 语法应用到一个函数上。这个语法等价于调用装饰器函数并将目标函数作为参数传递给它。</p><p>下面是一系列针对装饰器的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个装饰器函数decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="comment"># 我们用函数wrapper来代表被装饰后的func函数，最后返回wrapper</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;end_time - start_time&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面这段代码在wrapper函数外面包裹了一个装饰器函数decorator，</span></span><br><span class="line"><span class="comment"># 使得wrapper函数的运行时间可以被检测。(*args, **kwargs)这两个参数可以代表传入的一切参数。</span></span><br><span class="line"><span class="comment"># 我们来看看如何使用它：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先定义一个square函数：</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span>  a*b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随后，使用装饰器装饰他，生成一个新的函数</span></span><br><span class="line">decorated_square = decorator(square)</span><br><span class="line"><span class="comment">#print(decorated_square(10,10))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际上，python提供了一个更简单的方法：</span></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span>  a*b</span><br><span class="line"><span class="comment"># 这样，直接执行square(10,10)，就能输出运行的时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然，我们也可以定义一个装饰器生成器:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">threshold</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="comment"># 这是一个python中自带的装饰器，可以使得wrapper函数继承func的名字等</span></span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            start_time = time.time()</span><br><span class="line">            result = func(*args, **kwargs)</span><br><span class="line">            end_time = time.time()</span><br><span class="line">            <span class="keyword">if</span> start_time - end_time &gt; threshold:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;超时&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰这个函数</span></span><br><span class="line"><span class="meta">@timer(<span class="params"><span class="number">0.1</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sleep_04</span>():</span><br><span class="line">    time.sleep(<span class="number">0.4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sleep_04()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者生成一个新函数</span></span><br><span class="line">sleep_04 = timer(<span class="number">0.1</span>)(sleep_04)</span><br><span class="line"><span class="built_in">print</span>(sleep_04.__name__)</span><br></pre></td></tr></table></figure><p>装饰器概念：用来装饰其他函数的，即为其他函数添加特定功能的函数 装饰器的基本原则：</p><ol><li>不能修改被装饰函数的源码</li><li>不能修改被装饰函数的调用方式</li></ol><h4 id="类中内置装饰器"><a class="markdownIt-Anchor" href="#类中内置装饰器"></a> 类中内置装饰器</h4><p>ython 类中自带的装饰器是一些内置的、专门用于修改类行为的装饰器。这些装饰器可以帮助你更方便地实现特定的类行为或功能扩展。常见的内置类装饰器包括 <code>@staticmethod</code>、<code>@classmethod</code>、<code>@property</code> 和 <code>@abstractmethod</code> 等。</p><h5 id="staticmethod"><a class="markdownIt-Anchor" href="#staticmethod"></a> @staticmethod</h5><p><code>@staticmethod</code> 装饰器用于将一个方法声明为静态方法。静态方法属于类本身，而不是类的实例。它不需要访问类实例或类本身，因此不需要传递 <code>self</code> 或 <code>cls</code> 参数。静态方法通常用于执行一些与类本身相关的任务，但不需要访问类的属性或实例数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用静态方法</span></span><br><span class="line">result = MyClass.add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出: 5</span></span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>静态方法不依赖于类的实例化。</li><li>可以通过类名或实例来调用静态方法，但通常通过类名调用。</li><li>适用于那些不需要访问实例或类属性的方法。</li></ul><h5 id="classmethod"><a class="markdownIt-Anchor" href="#classmethod"></a> @classmethod</h5><p><code>@classmethod</code> 装饰器用于将一个方法声明为类方法。类方法第一个参数是类本身（通常命名为 <code>cls</code>），而不是实例对象。类方法通常用于访问类属性或修改类状态，而不是实例状态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">increment_count</span>(<span class="params">cls</span>):</span><br><span class="line">        cls.count += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Count: <span class="subst">&#123;cls.count&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 调用类方法</span></span><br><span class="line">MyClass.increment_count()  <span class="comment"># 输出: Count: 1</span></span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>类方法不需要类的实例，可以通过类本身直接调用。</li><li>类方法第一个参数是类 <code>cls</code>，而不是实例 <code>self</code>。</li><li>类方法适用于操作类级别的数据或状态。</li></ul><h5 id="property"><a class="markdownIt-Anchor" href="#property"></a> @property</h5><p><code>@property</code> 装饰器用于将一个方法定义为属性。这意味着你可以像访问属性一样访问这个方法，而无需显式调用它。<code>@property</code> 是一种将类的方法转换为只读属性的方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, radius</span>):</span><br><span class="line">        self._radius = radius</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">radius</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._radius</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @radius.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">radius</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;Radius cannot be negative.&quot;</span>)</span><br><span class="line">        self._radius = value</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * self._radius * self._radius</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建圆对象</span></span><br><span class="line">circle = Circle(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(circle.area)  <span class="comment"># 输出: 78.5</span></span><br><span class="line">circle.radius = <span class="number">10</span>  <span class="comment"># 使用setter修改半径</span></span><br><span class="line"><span class="built_in">print</span>(circle.area)  <span class="comment"># 输出: 314.0</span></span><br></pre></td></tr></table></figure><p><strong>特点</strong></p><ul><li><code>@property</code> 使方法像属性一样访问。</li><li>可以使用 <code>@property</code> 和 <code>@property.setter</code> 来定义可读和可写的属性。</li><li>用于将计算逻辑封装成属性访问的形式。</li></ul><h5 id="abstractmethod"><a class="markdownIt-Anchor" href="#abstractmethod"></a> @abstractmethod</h5><p>详见上文</p><h3 id="魔法方法"><a class="markdownIt-Anchor" href="#魔法方法"></a> 魔法方法</h3><h4 id="重要的魔法方法"><a class="markdownIt-Anchor" href="#重要的魔法方法"></a> 重要的魔法方法</h4><p>在 Python 中，<strong>魔法方法</strong>（Magic Methods）又称为 <strong>特殊方法</strong>（Special Methods），是类中以双下划线 <code>__</code> 开头和结尾的方法。这些方法允许你对对象进行特定的操作或赋予对象特殊行为，从而让你可以定制 Python 对象的内建操作，比如加法、字符串表示、索引操作等。</p><p>魔法方法使得 Python 对象能够参与各种语言层面的操作，如算术运算、比较运算、类型转换、函数调用等，通常这些方法被 Python 内部调用，但你也可以自定义实现它们以修改对象行为。</p><p><strong><code>__new__(cls)</code></strong>：</p><ul><li>用于创建对象实例的方法。它通常与 <code>__init__</code> 一起使用，在实例化对象时首先被调用。<code>__new__</code> 返回一个新的对象实例，而 <code>__init__</code> 则用来初始化该实例。</li><li>当你继承 <code>__new__</code> 方法时，你可以控制对象创建的过程。</li></ul><p><strong><code>__init__(self, ...)</code></strong>：</p><ul><li>构造器，用于初始化对象实例。<code>__init__</code> 在 <code>__new__</code> 方法之后调用，并且在对象实例创建后立即执行。</li><li>它允许你在对象创建时设置初始属性。</li></ul><p><strong><code>__str__(self)</code></strong>：</p><ul><li>用于定义对象的字符串表示。当使用 <code>print()</code> 打印对象或使用 <code>str()</code> 函数时，<code>__str__</code> 方法被调用。</li><li>这个方法应该返回一个友好的、可读性强的字符串，用于展示对象的内容。</li></ul><p><strong><code>__getitem__(self, key)</code></strong>：</p><ul><li>用于定义对象的索引访问（例如 <code>obj[key]</code>）。<br /><strong><code>__setitem__(self, key, value)</code></strong>：</li><li>用于定义对象的索引赋值（例如 <code>obj[key] = value</code>）。<br /><strong><code>__delitem__(self, key)</code></strong>：</li><li>用于定义删除索引元素（例如 <code>del obj[key]</code>）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.data = data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data[index]</span><br><span class="line"></span><br><span class="line">my_list = MyList([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">1</span>])  <span class="comment"># 输出: 2</span></span><br></pre></td></tr></table></figure><p><strong><code>__call__(self, ...)</code></strong>：</p><ul><li>使对象成为可调用的（例如 <code>obj()</code>）。当对象像函数一样被调用时，Python 会调用 <code>obj.__call__()</code> 方法。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Adder</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> self.value + x</span><br><span class="line"></span><br><span class="line">add_five = Adder(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(add_five(<span class="number">3</span>))  <span class="comment"># 输出: 8</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>__enter__(self)</code></strong>：<ul><li>用于定义进入 <code>with</code> 语句时的行为。</li></ul></li><li><strong><code>__exit__(self, exc_type, exc_val, exc_tb)</code></strong>：<ul><li>用于定义退出 <code>with</code> 语句时的行为，处理异常等。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyContextManager</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Entering the context&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Exiting the context&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> exc_type:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Exception: <span class="subst">&#123;exc_val&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> MyContextManager():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Inside the context&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="类的参数下划线前缀"><a class="markdownIt-Anchor" href="#类的参数下划线前缀"></a> 类的参数下划线前缀</h3><h4 id="单下划线-_-前缀"><a class="markdownIt-Anchor" href="#单下划线-_-前缀"></a> 单下划线 <code>_</code> 前缀</h4><p>单下划线是 Python 的一种约定，用来标识一个变量或方法是“内部使用的”，即它不应该被外部直接访问。这种标识并不影响属性或方法的访问权限，但它是对其他开发者的一种提醒，告诉他们这些属性或方法是属于类的实现细节，应该尽量避免直接使用。</p><h4 id="双下划线-__-前缀"><a class="markdownIt-Anchor" href="#双下划线-__-前缀"></a> 双下划线 <code>__</code> 前缀</h4><p>双下划线前缀通常用于表示变量或方法是类的“私有”成员。它使得这些属性或方法不会被外部直接访问，而是通过名称修饰（name mangling）进行修改，使其在外部不可直接访问。这种命名约定旨在避免类的子类或外部代码意外覆盖或访问这些“私有”成员。</p><p><strong>用途：</strong></p><ul><li>强制私有化（name mangling）——Python 在名称前加上 <code>_ClassName</code>，使得外部不容易访问这些变量或方法。</li><li>通过这种方式，Python 希望防止类的外部代码直接访问和修改这些变量，但仍然允许子类通过继承来访问和修改这些变量。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__private_value = <span class="number">100</span>  <span class="comment"># 私有属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__private_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This is a private method.&quot;</span>)</span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line"><span class="built_in">print</span>(obj.__private_value)  <span class="comment"># 报错: AttributeError</span></span><br><span class="line">obj.__private_method()  <span class="comment"># 报错: AttributeError</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍一下Python类的装饰器和魔法方法，以及参数的下划线前缀&lt;/p&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
  <entry>
    <title>局域网访问服务器Docker下psql数据库的若干问题</title>
    <link href="https://atffang.github.io/2025/03/29/%E5%B1%80%E5%9F%9F%E7%BD%91%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8Docker%E4%B8%8Bpsql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/"/>
    <id>https://atffang.github.io/2025/03/29/%E5%B1%80%E5%9F%9F%E7%BD%91%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8Docker%E4%B8%8Bpsql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/</id>
    <published>2025-03-29T15:45:34.000Z</published>
    <updated>2025-03-30T01:41:37.613Z</updated>
    
    <content type="html"><![CDATA[<p>瞎捣鼓</p><span id="more"></span><p>最近有在实验室服务器的docker上部署服务的需求，将数据注入psql数据库并在docker环境中访问一切正常，然而在局域网下其他设备访问数据时，出现了一些问题，遂简单记录。</p><p>首先，由于postgresql数据库的默认端口为5432，然而docker仅仅预留了几个映射端口与外部通信，因此，需要修改psql的运行端口，这里我选择的映射端口为25002:2002。在 Docker 中，端口映射的格式通常是 host_port:container_port，即 宿主机端口:容器内端口。因此，首先需要修改psql的运行端口为2002。</p><p>找到<code>/etc/postgresql/14/main/postgresql.conf</code>配置文件，将<code>port = 5432</code>修改为制定端口，我这里为2002。</p><p>并添加：<code>listen_addresses = '*'</code>开启远程访问。</p><p>随后修改<code>/etc/postgresql/14/main/pg_hba.conf</code>来设置放行ip。设置规则为在实验室局域网下的ip全部放行，那么添加规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host    all             all             192.168.41.0/24          md5</span><br></pre></td></tr></table></figure><p>最后，重启服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/postgresql restart</span><br></pre></td></tr></table></figure><p>那么通过局域网下其他设备访问服务器的25002端口即可访问数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql -h 192.168.41.56 -p 25002 -U postgres -d shanghaipoidb</span><br></pre></td></tr></table></figure><p>尝试在命令行中远程连接，并未发生什么问题，但在pgadmin中连接却提示错误为一个172.x.x.x的ip被拒绝访问，如果出现这种情况，意味着 Docker 容器内的 PostgreSQL 服务绑定的是容器的内部网络 IP（例如 <code>172.x.x.x</code>），而不是宿主机的 IP 地址（例如 <code>192.x.x.x</code>）。当你使用 pgAdmin 连接时，pgAdmin 可能尝试直接连接容器的内部 IP 地址，而不是宿主机的地址，因此连接被拒绝。只需将改ip使用上面相同的方式加入放行ip即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;瞎捣鼓&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Entropy and Cross Entropy</title>
    <link href="https://atffang.github.io/2025/03/15/Entropy%20and%20Cross%20Entropy/"/>
    <id>https://atffang.github.io/2025/03/15/Entropy%20and%20Cross%20Entropy/</id>
    <published>2025-03-15T07:50:46.000Z</published>
    <updated>2025-03-15T07:54:54.142Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍一下熵与交叉熵</p><span id="more"></span><img src="https://atffang.github.io/2025/03/15/Entropy and Cross Entropy/Entropy and Cross Entropy.png"/>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单介绍一下熵与交叉熵&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>3D Guassian Splatting</title>
    <link href="https://atffang.github.io/2025/03/12/3D%20Guassian%20Splatting/"/>
    <id>https://atffang.github.io/2025/03/12/3D%20Guassian%20Splatting/</id>
    <published>2025-03-12T15:12:43.000Z</published>
    <updated>2025-03-14T14:20:08.440Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/graphdeco-inria/gaussian-splatting">https://github.com/graphdeco-inria/gaussian-splatting</a> 复现</p><span id="more"></span><h3 id="环境构建"><a class="markdownIt-Anchor" href="#环境构建"></a> 环境构建</h3><p>首先clone仓库<a href="https://github.com/graphdeco-inria/gaussian-splatting">https://github.com/graphdeco-inria/gaussian-splatting</a></p><p>理论上应该按照源码提供的environment.yml文件创建环境，即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env create --file environment.<span class="property">yml</span></span><br></pre></td></tr></table></figure><p>然而，实验室服务器CUDA版本为12.2，environment.yml中指定的python和pytorch版本过低，因此，选择自己配置环境python3.10, cuda12.1对应的pytorch（适用于12.2）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">conda create -n gaussian_splatting python=<span class="number">3.10</span></span><br><span class="line">conda activate gaussian_splatting</span><br><span class="line">pip3 install torch torchvision torchaudio --index-url <span class="attr">https</span>:<span class="comment">//download.pytorch.org/whl/cu121</span></span><br><span class="line"></span><br><span class="line">pip install submodules\diff-gaussian-rasterization</span><br><span class="line">pip install submodules\simple-knn</span><br><span class="line">pip install plyfile</span><br><span class="line">pip install tqdm</span><br><span class="line">pip install opencv-python</span><br><span class="line">pip install joblib</span><br></pre></td></tr></table></figure><h3 id="数据前期处理程序"><a class="markdownIt-Anchor" href="#数据前期处理程序"></a> 数据前期处理程序</h3><p>都是在Windows端下载。</p><p>下载ffmep <a href="http://www.gyan.dev/ffmpeg/builds/">www.gyan.dev/ffmpeg/builds/</a></p><p>将文件夹重命名为ffmep，将bin文件路径加入系统变量</p><p>下载COLMAP</p><p><a href="https://github.com/colmap/colmap/releases">https://github.com/colmap/colmap/releases</a></p><p>将文件夹重命名为COLMAP，将bin文件路径加入系统变量</p><p>下载ImageMagick</p><h3 id="训练流程"><a class="markdownIt-Anchor" href="#训练流程"></a> 训练流程</h3><ul><li>Step1：录制视频，使用ffmep进行抽帧</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.<span class="property">mp4</span> -vf <span class="string">&quot;setpts=0.2*PTS&quot;</span> input/input_%4d.<span class="property">jpg</span></span><br></pre></td></tr></table></figure><p>-i input.mp4：指定输入视频文件为 input.mp4。<br />-vf “setpts=0.2 PTS”：这是一个视频过滤器选项，其中 setpts 指令用来设置帧的时间戳（Presentation TimeStamps）。这里的表达式 0.2PTS 表示将当前帧的时间戳乘以0.2，这意味着抽取出来的帧之间的间隔被拉长了5倍，所以生成的图像序列将以视频原始速度的五分之一进行播放。<br />input/input_%4d.jpg：这是输出文件格式及路径，其中 %4d 是一个格式化占位符，它会被自增的整数所替换，确保每个输出文件名是唯一的。例如，输出的第一帧将会被保存为 input/input_0001.jpg，第二帧为 input/input_0002.jpg，依此类推。同时，输出目录被指定为 input/ 目录下。</p><ul><li>Step2：使用3D Guassian Splatting仓库中包含的convert.py完成图像数据转换。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python convert.<span class="property">py</span> -s &lt;location&gt; [--resize]</span><br></pre></td></tr></table></figure><p>location：代表需要转化的图像位置，图像必须被放在一个input文件夹下，location则为其父文件夹。<br />[–resize]：表示是否变化图像尺寸，可选</p><ul><li>Step3：将转换完成的图像，包括images和sparse两个文件夹，放在一个父文件夹下作为输入数据，进行训练。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train.py -s &lt;location&gt;</span><br></pre></td></tr></table></figure><p>location：代表数据路径</p><h3 id="结果预览"><a class="markdownIt-Anchor" href="#结果预览"></a> 结果预览</h3><p>拉取代码：<a href="https://github.com/kishimisu/Gaussian-Splatting-WebGL.git%EF%BC%8C%E5%9C%A8live">https://github.com/kishimisu/Gaussian-Splatting-WebGL.git，在live</a> server中打开网页，上传ply数据：<br /><img src="https://atffang.github.io/2025/03/12/3D Guassian Splatting/try.png"/></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/graphdeco-inria/gaussian-splatting&quot;&gt;https://github.com/graphdeco-inria/gaussian-splatting&lt;/a&gt; 复现&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>GNNWR</title>
    <link href="https://atffang.github.io/2025/03/06/GNNWR/"/>
    <id>https://atffang.github.io/2025/03/06/GNNWR/</id>
    <published>2025-03-06T06:47:14.000Z</published>
    <updated>2025-03-06T11:57:51.840Z</updated>
    
    <content type="html"><![CDATA[<p>Geographically neural network weighted regression for the accurate estimation of spatial non-stationarity</p><span id="more"></span><img src="https://atffang.github.io/2025/03/06/GNNWR/GNNWR.png">]]></content>
    
    
    <summary type="html">&lt;p&gt;Geographically neural network weighted regression for the accurate estimation of spatial non-stationarity&lt;/p&gt;</summary>
    
    
    
    <category term="空间分析与GIS算法" scheme="https://atffang.github.io/categories/%E7%A9%BA%E9%97%B4%E5%88%86%E6%9E%90%E4%B8%8EGIS%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>threading or multiprocessing?</title>
    <link href="https://atffang.github.io/2025/02/26/threading%20or%20multiprocessing/"/>
    <id>https://atffang.github.io/2025/02/26/threading%20or%20multiprocessing/</id>
    <published>2025-02-26T02:06:23.000Z</published>
    <updated>2025-05-09T02:35:29.499Z</updated>
    
    <content type="html"><![CDATA[<p>Python  两种并发机制</p><span id="more"></span><h4 id="threading"><a class="markdownIt-Anchor" href="#threading"></a> Threading</h4><p><strong>threading（线程编程）</strong> 是一种通过在程序中创建多个执行单元（线程），来实现并发执行的技术。线程共享同一个进程的内存空间，并且可以并行处理任务，因此能够更好地利用多核CPU资源。</p><p><strong>线程</strong>是进程中的一个轻量级执行单元，一个进程可以包含多个线程。这些线程共享相同的内存和资源（如文件句柄），但每个线程有自己的栈和指令指针。由于共享内存，线程间通信非常快速，但也更容易出现竞争条件、死锁等同步问题。</p><p><strong>threading经典应用场景</strong></p><ul><li><strong>I/O操作</strong>：在等待I/O操作完成（如文件读写、网络请求）时，其他线程可以继续执行任务，提高程序响应速度。</li><li><strong>并发任务</strong>：例如图形界面的响应式编程、并行数据处理。</li></ul><p><strong>An Example</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_data</span>(<span class="params">url</span>):</span><br><span class="line">response = request.get(url)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;response.status_code&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">urls = [url1, url2……]</span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">t = threading.Thread(target=fetch_data, args=(url,))</span><br><span class="line">threads.append(t)</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">t.join()</span><br></pre></td></tr></table></figure><p>多进程虽然能够处理并行任务，但每个进程的上下文切换会有额外的开销，这会影响程序的性能。因此，此类简单的请求工作更加适合使用多线程。</p><p><strong>optimize</strong>：<br />concurrent 是 Python 标准库中的一个模块，专门用于支持 <strong>并发编程</strong>。它提供了高层次的接口来管理多个任务的并发执行，主要包括线程和进程池的管理。<br />如果存在大量需要访问的url，可以使用concurrent.futures进行线程池创建。通过线程池，可以控制同时运行的线程数，避免一次性创建过多的线程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 任务函数：访问URL</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_data</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Finished download from: <span class="subst">&#123;url&#125;</span>, Status Code: <span class="subst">&#123;response.status_code&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> requests.RequestException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error downloading <span class="subst">&#123;url&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># URL列表（假设有1000个）</span></span><br><span class="line">urls = [<span class="string">&quot;http://example.com&quot;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用ThreadPoolExecutor</span></span><br><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">20</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    <span class="comment"># 提交所有任务</span></span><br><span class="line">    futures = [executor.submit(fetch_data, url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等待任务完成</span></span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> concurrent.futures.as_completed(futures):</span><br><span class="line">        future.result()  <span class="comment"># 可以获取返回结果，若不关心结果，可以省略这行</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;All downloads complete.&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="multiprocessing"><a class="markdownIt-Anchor" href="#multiprocessing"></a> Multiprocessing</h4><p><strong>multiprocessing（多进程编程）</strong> 是通过在程序中创建多个独立的进程，每个进程都有自己的内存空间、资源和执行单元，以实现并行处理。多进程能够避免线程竞争带来的问题，因为各个进程之间是独立的。</p><p><strong>进程</strong>是操作系统中资源分配的基本单位。每个进程都有自己的地址空间、文件句柄、栈、堆等资源。不同于线程，进程之间不共享内存，这意味着它们更加安全，但也需要更复杂的通信方式（如管道、消息队列）来进行数据交换。</p><p><strong>multiprocessing的典型应用场景：</strong></p><ul><li><strong>高可靠性任务</strong>：当某些任务必须完全隔离，不能因为其他任务的崩溃而被干扰时（如服务器进程、数据库进程等）。</li><li><strong>CPU密集型任务</strong>：需要大量的计算资源时（如图像处理、科学计算），使用多进程可以充分利用多核CPU的性能。</li></ul><p>关于multiprocessing的基础应用，在之前的文章《python并行运算》中做过大致介绍。<br /><strong>An Example</strong><br />并行矩阵运算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义矩阵计算任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">matrix_square</span>(<span class="params">matrix</span>):</span><br><span class="line">    <span class="keyword">return</span> np.dot(matrix, matrix)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 创建一个随机矩阵</span></span><br><span class="line">    matrices = [np.random.rand(<span class="number">1000</span>, <span class="number">1000</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用进程池进行并行计算</span></span><br><span class="line">    <span class="keyword">with</span> mp.Pool(processes=<span class="number">4</span>) <span class="keyword">as</span> pool:</span><br><span class="line">        results = pool.<span class="built_in">map</span>(matrix_square, matrices)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Matrix calculations completed.&quot;</span>)</span><br></pre></td></tr></table></figure><p>并行蒙特卡洛模拟：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义蒙特卡罗模拟任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">monte_carlo_pi</span>(<span class="params">num_samples</span>):</span><br><span class="line">    inside_circle = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_samples):</span><br><span class="line">        x, y = random.random(), random.random()</span><br><span class="line">        <span class="keyword">if</span> x**<span class="number">2</span> + y**<span class="number">2</span> &lt;= <span class="number">1</span>:</span><br><span class="line">            inside_circle += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> inside_circle / num_samples * <span class="number">4</span>  <span class="comment"># 估算π值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 每个进程处理100万次采样</span></span><br><span class="line">    num_samples = <span class="number">1000000</span></span><br><span class="line">    num_processes = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用进程池并行运行蒙特卡罗模拟</span></span><br><span class="line">    <span class="keyword">with</span> mp.Pool(processes=num_processes) <span class="keyword">as</span> pool:</span><br><span class="line">        pi_estimates = pool.<span class="built_in">map</span>(monte_carlo_pi, [num_samples] * num_processes)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算平均值</span></span><br><span class="line">    pi_average = <span class="built_in">sum</span>(pi_estimates) / num_processes</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Estimated Pi: <span class="subst">&#123;pi_average&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>optimize</strong>：<br />concurrent.futures的ProcessPoolExecutor ，类似于multiprocessing.Pool</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义蒙特卡罗模拟任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">monte_carlo_pi</span>(<span class="params">num_samples</span>):</span><br><span class="line">    inside_circle = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_samples):</span><br><span class="line">        x, y = random.random(), random.random()</span><br><span class="line">        <span class="keyword">if</span> x**<span class="number">2</span> + y**<span class="number">2</span> &lt;= <span class="number">1</span>:</span><br><span class="line">            inside_circle += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> inside_circle / num_samples * <span class="number">4</span>  <span class="comment"># 估算π值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    num_samples = <span class="number">1000000</span>  <span class="comment"># 每个进程采样的数量</span></span><br><span class="line">    num_processes = <span class="number">4</span>      <span class="comment"># 进程数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用 ProcessPoolExecutor 并行执行任务</span></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ProcessPoolExecutor(max_workers=num_processes) <span class="keyword">as</span> executor:</span><br><span class="line">        futures = [executor.submit(monte_carlo_pi, num_samples) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_processes)]</span><br><span class="line">        pi_estimates = [f.result() <span class="keyword">for</span> f <span class="keyword">in</span> concurrent.futures.as_completed(futures)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算平均估算值</span></span><br><span class="line">    pi_average = <span class="built_in">sum</span>(pi_estimates) / num_processes</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Estimated Pi: <span class="subst">&#123;pi_average&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="concurrentfeatures优势"><a class="markdownIt-Anchor" href="#concurrentfeatures优势"></a> concurrent.features优势</h4><ol><li><p><strong>统一接口</strong>：无论是使用 ThreadPoolExecutor 还是 ProcessPoolExecutor，它们的 API 是统一的，可以很方便地根据任务类型选择是使用线程还是进程。</p></li><li><p><strong>简化代码</strong>：相比 multiprocessing.Pool，concurrent.futures 提供了更高层的接口，如 submit() 和 as_completed()，减少了复杂度。</p></li><li><p><strong>Future 对象</strong>：submit() 方法返回 Future 对象，允许在任务完成后方便地获取结果、检查任务状态或处理异常。</p></li><li><p><strong>自动资源管理</strong>：concurrent.futures 支持上下文管理（with 语句），能够自动管理进程或线程池的生命周期，避免资源泄漏。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;Python  两种并发机制&lt;/p&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript异步机制浅析</title>
    <link href="https://atffang.github.io/2025/02/22/JavaScript%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/"/>
    <id>https://atffang.github.io/2025/02/22/JavaScript%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/</id>
    <published>2025-02-22T02:02:54.000Z</published>
    <updated>2025-02-22T02:02:54.948Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>asyncio浅析</title>
    <link href="https://atffang.github.io/2025/02/21/asyncio%E6%B5%85%E6%9E%90/"/>
    <id>https://atffang.github.io/2025/02/21/asyncio%E6%B5%85%E6%9E%90/</id>
    <published>2025-02-21T02:10:09.000Z</published>
    <updated>2025-05-09T02:35:09.879Z</updated>
    
    <content type="html"><![CDATA[<p>Python  asyncio机制</p><span id="more"></span><h4 id="event-loop"><a class="markdownIt-Anchor" href="#event-loop"></a> Event Loop</h4><p>Python 的事件循环（Event Loop）是异步编程中的核心概念，通常与 <code>asyncio</code> 库（Python3.5引入）一起使用。事件循环负责管理和调度异步任务，确保这些任务在适当的时机运行，而不会阻塞主线程。事件循环是基于“协程”的模型，它允许 Python 程序在进行 I/O 操作或等待某些事件时不会阻塞其他操作，从而提高程序的效率。<br /><strong>event loop</strong>的基本流程：</p><ul><li><strong>定义协程（coroutines）</strong>: 协程是 Python 中的异步函数（Asynchronous Functions），通常用 <code>async def</code> 定义，执行时不会立即执行，而是返回一个 “awaitable” 对象。</li><li><strong>创建事件循环</strong>: <code>asyncio.get_event_loop()</code> 创建一个事件循环，它负责管理和调度所有异步任务。</li><li><strong>运行事件循环</strong>: 使用 <code>loop.run_until_complete()</code> 来启动事件循环，直到指定的任务完成。</li><li><strong>任务调度</strong>: 事件循环会根据任务的状态（是否可以执行）决定哪个任务应该被调度执行。</li></ul><h4 id="asyncio-的基本使用规范"><a class="markdownIt-Anchor" href="#asyncio-的基本使用规范"></a> asyncio 的基本使用规范</h4><p>异步函数是使用 <code>async def</code> 语法定义的，它们返回一个协程对象，而不是直接执行函数体。当你调用这个函数时，实际上返回的是一个尚未完成的协程对象，需要通过事件循环来执行。<br />定义一个异步函数如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">my_coroutine</span>():</span><br><span class="line"><span class="keyword">await</span> asynico.sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><strong><code>await</code></strong> 用于挂起协程的执行，等待一个异步操作完成后再继续执行。</p><p><code>asyncio</code> 提供了事件循环来调度异步任务。事件循环负责执行异步任务，并管理任务的调度。</p><ul><li><strong><code>asyncio.run()</code></strong>：用于运行一个顶层的异步函数。它创建一个事件循环并运行直到协程执行完成，最后关闭事件循环。通常用于程序的入口。</li><li><strong><code>asyncio.run(main())</code></strong>：该方法会运行 <code>main()</code> 协程，并在执行完毕后关闭事件循环。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 asyncio.run() 启动事件循环</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">await</span> my_coroutine()</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><ul><li><strong><code>asyncio.gather()</code></strong>：用于并发执行多个协程，等到所有协程都完成后，才继续执行后面的代码。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">another_coroutine</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始执行另一个协程&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;另一个协程执行结束&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(my_coroutine(), another_coroutine())  <span class="comment"># 并发执行</span></span><br></pre></td></tr></table></figure><p>除了 <code>asyncio.run()</code>，还可以手动管理事件循环和任务，使用 <code>loop.create_task()</code> 和 <code>loop.run_until_complete()</code> 来调度任务。</p><ul><li><strong><code>loop.create_task()</code></strong>：用于创建一个协程任务，返回一个任务对象。</li><li><strong><code>loop.run_until_complete()</code></strong>：用于启动事件循环并直到某个任务完成。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">task1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务 1 开始&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务 1 完成&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">task2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务 2 开始&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务 2 完成&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动创建事件循环并执行任务</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">tasks = [loop.create_task(task1()), loop.create_task(task2())]</span><br><span class="line">loop.run_until_complete(asyncio.gather(*tasks))</span><br></pre></td></tr></table></figure><ul><li>在协程中使用 <code>try...except</code> 来捕获异常。</li><li>异常会在协程执行过程中抛出并传播，直到被捕获为止。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">my_coroutine</span>():</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;发生错误&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> my_coroutine()</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;捕获异常: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><ul><li>事件循环会在程序执行完毕后自动关闭，但如果需要提前停止，可以调用 <code>loop.stop()</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始任务&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;结束任务&quot;</span>)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(main())</span><br><span class="line">loop.stop()  <span class="comment"># 关闭事件循环</span></span><br></pre></td></tr></table></figure><h4 id="简单的上手"><a class="markdownIt-Anchor" href="#简单的上手"></a> 简单的上手</h4><p>以下代码请在python3.7及以上运行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#这是一个coroutine</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="comment">#await将asyncio.sleep(delay)这个coroutine转化为task</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="built_in">print</span>(what)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;start at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment">#await将say_after()这个coroutine转化为task，并告知Event Loop</span></span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">2</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finish at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start at 15:46:50</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">finish at 15:46:53</span><br></pre></td></tr></table></figure><p>花费三秒。整个事件过程为：<br />asyncio.run将main()包装为了一个task，然后加入Event Loop。Event Loop中此时只有一个task即main，随即运行main()，控制权交付于main。<br />随后，main将控制权交给say_after，运行say_after(1, “hello”)这个coroutine function得到一个coroutine object（代码并不会在这里阻塞），而await将coroutine object转化为task，放到Event Loop中，并告知需要等待这个sleep，控制权交给sleep。<br />1s后，sleep这个task完成，Event Loop将控制权交还给main，main运行下一个task，重复上述步骤。</p><p>但是这样并没有意义，运行的事件并没有缩短。因此，我们改变策略为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="built_in">print</span>(what)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">task1 = asyncio.create_task(say_after(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>))</span><br><span class="line">task2 = asyncio.create_task(say_after(<span class="number">2</span>, <span class="string">&quot;world&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;start at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finish at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start at 16:23:01</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">finish at 16:23:03</span><br></pre></td></tr></table></figure><p>这次，我们预先包装了两个task，在其放到Event Loop后，Event Loop并不会将控制权交由task，从而实现串行。</p><p>如何返回task的值？<br />最简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">await</span> task1</span><br></pre></td></tr></table></figure><p>使用gather:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">await</span> asyncio.gather(task1, taske)</span><br></pre></td></tr></table></figure><p>gather还有一个好处，可以不需要包装为task再输入，可以直接读取coroutine：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">say_after(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>), </span><br><span class="line">say_after(<span class="number">2</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Python  asyncio机制&lt;/p&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
  <entry>
    <title>2025年终总结</title>
    <link href="https://atffang.github.io/2024/12/13/2025%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://atffang.github.io/2024/12/13/2025%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</id>
    <published>2024-12-13T08:00:49.000Z</published>
    <updated>2025-01-12T05:56:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>2025年终总结</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">即使您达不到幸福的境地，您也应该永远记住，您走的路是正确的，千万不要从这条路上离开。</span><br><span class="line">（陀《卡拉马佐夫兄弟》）</span><br></pre></td></tr></table></figure><p>坐在周六早上的咖啡店里，呼啸的冷风使遮阳伞不停浮动。杂七杂八的事情使我突然意识到这一年真的要结束了，即使这一过渡的时刻仅仅具有象征意义，我也想挣扎着写下年终的总结，由此钉下一颗锲子。很抱歉我无法详细的捕捉过去一年发生的所有事情，组成流水账式的记录，也无法坦率的将自己一切想法开诚布公，似乎最能够接受的方法是记录下这一年里发生的一些事。<br><br />四月，度过了自己第二十二个生日。虽然很恬不知耻，但我真的一直以为自己还没有二十岁。印象深刻的是买了个巴斯克蛋糕，却没比巴掌大多少，五个人分着吃了，显的有点局促。<br><br />毕业前，和yu去日本玩了一周。没有跟团，只是自己瞎走，我英语一般，日本人则更差。不过加上些比比划划大概能交流，大体上没有出什么纰漏。在东京落地，坐火车到伊东，往北到镰仓，再继续向北回东京，一路上一直是令人微笑的风光和中学生男男女女，不得不感叹非常值得一去。<br><br />6月19日，在闷热的体育馆听完毕业典礼，又在学衡路上吃了药膳鸡，匆匆忙忙花完红跑车（一家很不错的面包店）储值卡里的钱。回到宿舍将海量的私人物品一半打包，一半丢掉，陆续得知同学离开或即将离开的消息。毕业是2024年最重要的时刻，似乎在重要的时刻总是在做次要的事情。但因为这些次要的时刻，我会永远怀念南京。<br><br />暑假刚开始，买了把吉他。断断续续练了几个月，虽然称不上勤恳但也算坚持下来了，总算能嗯嗯啊啊边弹边唱一点，虽然不好听。<br><br />9月5日我来到上海，对新学校的一切都感到陌生。学校位于闵行区的最南端，再往南就是长江…没有人会对这个选址满意，更何况四周都是叮叮哐哐漫天扬尘的工地。令人宽慰的是我工作的大楼是较新且明亮的，而厕所也值得单独拿出来赞扬。过去的四个月间我并没有做出什么成果，也几乎没有看文章学习，忙碌于一些断断续续的开发工作，代码能力的确提升了一些。唯二骄傲的是给朋友的论文提供了一些帮助，以及用一个通宵换来了数学建模二等奖，至少不用发愁毕业要求了。<br><br />国庆回家，去常熟的养老院看望了卧病在床的爷爷。实际上他已身体僵硬，几乎不能动弹，帮他翻身的时候感觉就像搬弄风干的肉块。我们告别时，眼泪滑落在他因疾病而蜷缩的脸上，衰老的具象表达使我意识到在一个家庭中，成长和衰老是并行的。圣诞节，爷爷的母亲去世了，2024年的最后一个晚上，久病的爷爷突然恶化，进了icu。<br><br />十月中旬，在回南京作报告的前一个礼拜，收到了期刊的拒稿。其实我对结果并没有太多意外，只是希望晚点收到消息，好让我抱有幻想。我在这篇文章上倾注了许多时间和精力，也从中受益匪浅，但其中存在问题之巨使我始终无法说服自己这是一篇正确的文章，拖延回避到现在。<br /><br><br />十一月底，去苏州听了张悬的演唱会。这一年听了好几场live，这是印象最深的一场。也买了不少唱片，自然是花了不少钱，有机会整理一下。<br><br />就写到这吧，总之2024年算是结束了。应该怎么形容？可以说在碌碌无为中度过了人生重要的节点，可以说是平凡中存在伟大的光芒。我不喜欢这些宏大的词汇，但没有具体的例子可以指向我思维中的挣扎和变化。长期以来我一直是一个缺乏驱动力的人，在生活上事业上还是情感上都缺乏驱动力。内驱力的缺乏和偶发的热情交替控制自己，我几乎陷入了永不休止的圆周性思考，回答然后又反驳关于未来的问题。不过这样也好，矛盾人的才是具体的人，只是希望在2025年，一条明晰的道路能够浮现。<br /><br><br />再见！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2025年终总结&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>基于三维网格码LAS点云网格化存储与可视化方案介绍</title>
    <link href="https://atffang.github.io/2024/12/12/%E5%9F%BA%E4%BA%8E%E4%B8%89%E7%BB%B4%E7%BD%91%E6%A0%BC%E7%A0%81LAS%E7%82%B9%E4%BA%91%E7%BD%91%E6%A0%BC%E5%8C%96%E5%AD%98%E5%82%A8%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%A1%88%E4%BB%8B%E7%BB%8D/"/>
    <id>https://atffang.github.io/2024/12/12/%E5%9F%BA%E4%BA%8E%E4%B8%89%E7%BB%B4%E7%BD%91%E6%A0%BC%E7%A0%81LAS%E7%82%B9%E4%BA%91%E7%BD%91%E6%A0%BC%E5%8C%96%E5%AD%98%E5%82%A8%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%A1%88%E4%BB%8B%E7%BB%8D/</id>
    <published>2024-12-12T07:54:35.000Z</published>
    <updated>2024-12-12T08:16:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>三维网格码计算思路分享02。</p><span id="more"></span><p>基于上一篇博文中网格码正反算的方法和代码，写了一些基础控件以完成基于LAS三维点云的网格化计算以及数据预览，具体内容请看下图。</p><img src="https://atffang.github.io/2024/12/12/基于三维网格码LAS点云网格化存储与可视化方案介绍/WorkFlow.png"/>]]></content>
    
    
    <summary type="html">&lt;p&gt;三维网格码计算思路分享02。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>地球空间网格编码正反算实现</title>
    <link href="https://atffang.github.io/2024/12/11/%E5%9C%B0%E7%90%83%E7%A9%BA%E9%97%B4%E7%BD%91%E6%A0%BC%E7%BC%96%E7%A0%81%E6%AD%A3%E5%8F%8D%E7%AE%97%E5%AE%9E%E7%8E%B0/"/>
    <id>https://atffang.github.io/2024/12/11/%E5%9C%B0%E7%90%83%E7%A9%BA%E9%97%B4%E7%BD%91%E6%A0%BC%E7%BC%96%E7%A0%81%E6%AD%A3%E5%8F%8D%E7%AE%97%E5%AE%9E%E7%8E%B0/</id>
    <published>2024-12-11T11:41:43.000Z</published>
    <updated>2024-12-12T08:12:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>三维网格码计算思路分享。</p><span id="more"></span><p>似乎这两年低空经济成为了潮流方向，多了一些政策倾斜。前阵子刚有公司来交流相关事宜，16日华师大又要新成立低空经济研究中心，这两天组里为了这些事情鞍前马后，竟然有些仿佛过年的热闹。我负责的工作是探索其中一小个部分，也是一个非常小众的应用方向：地球空间网格码，该工作目前的理论基础为国标<strong>GBT 40087-2021 地球空间网格编码规则</strong>。<br />地球空间网格基于 GeoSOT(Geographical coordinate global Subdivision based on One-dimensioninteger and Two ton&quot;power)地球剖分模型,将地球空间统一剖分成不同尺度的网格单元,并按统一编码规则进行标识和表达,构建了网格化的地球空间数据组织参考框架。该框架支持地球表面空间和地球立体空间与地理空间信息的聚合,可有效解决物联网、大数据、云计算中海量空间信息在标识和表达上的唯一性、可读性、尺度性、关联性的瓶颈,实现了多源,多尺度数据网格化高效组织、处理和应用,突破了地理空间信息跨行业应用的技术壁垒,推动地球系统科学的发展。<br />具体来说，网格剖分分为经纬度的水平面剖分和高程的垂直剖分。具体过程相对复杂，参见上述国家标准，本文仅分享一些实现步骤。</p><h4 id="1-经纬度网格剖分"><a class="markdownIt-Anchor" href="#1-经纬度网格剖分"></a> 1. 经纬度网格剖分</h4><p>根据国标，经纬度剖分的步骤如下所示：</p><ol><li>将该点经、纬度坐标表示成GB/T16831规定的形式,即A’B’C.D&quot;;</li><li>将该点的坐标按度、分、秒、秒小数部分分别转换为二进制数。即将度|A|由十进制数转换成8 bit 定长二进制数(A)2, 将分B由一进制数转换成6bit定长二进制数(B)2, 将秒C由十进制数转换成6bit定长二进制数©2, 将秒以下数D由一进制数转换成11bit定长二进制数(D)2;</li><li>分别将经、纬度坐标度、分、秒及秒以下二进制数(A)2、(B)2、©2、(D)2直接拼接成31 bit定长二进制数(E)2, 即(E)2=(A)2(B)2©2(D)2, 分别得到两个 31 bit定长数经度(EL)2, 和纬度(EB)2;</li><li>将纬度(EB)2,前置、经度(EL)2后置, 采用莫顿交叉的方式生成62bit的混合代码(F)2, 例如若(EB)2为100111 ,(EL)2为011010, 则(EB)2在前, (EL)2在后的莫顿交叉运算结果为(F)2为 100101101110;</li><li>将二进制混合代码(F)2转成四进制编码(F)4;</li><li>根据待求网格的级别m, 将(F)4中后32-m位四进制的码元去掉得到(F’)4;</li><li>根据经度和纬度,前加上G0、G1、G2或G3即可得到网格代码。</li></ol><p>代码实现步骤如下：<br />定义一个类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WGS84coordinate</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, latitude, longitude, elevation</span>):</span><br><span class="line">        self.latitude = latitude</span><br><span class="line">        self.longitude = longitude</span><br><span class="line">        self.elevation = elevation</span><br></pre></td></tr></table></figure><p>实现步骤1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 将该点经、纬度坐标表示成GB/T16831规定的形式,即A&#x27;B&#x27;C.D&quot;;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decimal2dms</span>(<span class="params">self, decimal</span>):</span><br><span class="line">        degrees = <span class="built_in">int</span>(decimal)</span><br><span class="line">        minutes = <span class="built_in">int</span>((<span class="built_in">abs</span>(decimal) - <span class="built_in">abs</span>(degrees)) * <span class="number">60</span>)</span><br><span class="line">        seconds = (<span class="built_in">abs</span>(decimal) - <span class="built_in">abs</span>(degrees)) * <span class="number">60</span></span><br><span class="line">        seconds = (seconds - minutes) * <span class="number">60</span></span><br><span class="line">        seconds_fractional, seconds_integer = math.modf(seconds)</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">int</span>(degrees), <span class="built_in">int</span>(minutes), <span class="built_in">int</span>(seconds_integer), seconds_fractional]</span><br></pre></td></tr></table></figure><p>实现步骤2,3：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 将该点的坐标按度、分、秒、秒小数部分分别转换为二进制数, 拼为31 bit定长数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dms2bit</span>(<span class="params">self, dms</span>):</span><br><span class="line">        <span class="comment"># dms = [degrees, seconds_fractional, seconds_integer]</span></span><br><span class="line">        degrees, minutes, seconds_integer, seconds_fractional = dms</span><br><span class="line">        <span class="comment"># print(f&quot;度：&#123;degrees&#125;, 分：&#123;minutes&#125;, 秒整数：&#123;seconds_integer&#125;，秒小数：&#123;seconds_fractional&#125;&quot;)</span></span><br><span class="line">        degrees_bin, minutes_bin, seconds_integer_bin = <span class="string">f&quot;<span class="subst">&#123;degrees:08b&#125;</span>&quot;</span>, <span class="string">f&quot;<span class="subst">&#123;minutes:06b&#125;</span>&quot;</span>, <span class="string">f&quot;<span class="subst">&#123;seconds_integer:06b&#125;</span>&quot;</span></span><br><span class="line">        seconds_fractional_scaled = <span class="built_in">int</span>(seconds_fractional * <span class="number">2048</span>)</span><br><span class="line">        seconds_fractional_bin = <span class="string">f&quot;<span class="subst">&#123;seconds_fractional_scaled:011b&#125;</span>&quot;</span></span><br><span class="line">        <span class="comment"># print(f&quot;度：&#123;degrees_bin&#125;, 分：&#123;minutes_bin&#125;, 秒整数：&#123;seconds_integer_bin&#125;，秒小数：&#123;seconds_fractional_bin&#125;&quot;)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([degrees_bin, minutes_bin, seconds_integer_bin, seconds_fractional_bin])</span><br></pre></td></tr></table></figure><p>实现步骤4,5：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3. 将经纬度的编码莫顿交叉,转为四进制编码</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mortoncross</span>(<span class="params">self</span>):</span><br><span class="line">        latbit = self.dms2bit(self.decimal2dms(self.latitude))</span><br><span class="line">        lonbit = self.dms2bit(self.decimal2dms(self.longitude))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(latbit) == <span class="number">31</span> <span class="keyword">and</span> <span class="built_in">len</span>(lonbit) == <span class="number">31</span>, <span class="string">&quot;Both binary strings must be 31 bits long.&quot;</span></span><br><span class="line">        interleaved_bits = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>):</span><br><span class="line">            interleaved_bits.append(latbit[i])</span><br><span class="line">            interleaved_bits.append(lonbit[i])</span><br><span class="line">        bit2 = <span class="string">&#x27;&#x27;</span>.join(interleaved_bits)</span><br><span class="line">        bit4 = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">str</span>(<span class="built_in">int</span>(bit2[i:i+<span class="number">2</span>], <span class="number">2</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(bit2), <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bit4</span><br></pre></td></tr></table></figure><p>实现步骤6,7：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. 根据待求网格的级别m,将(F)中后32-m位四进制的码元去掉得到(F);</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gridcode</span>(<span class="params">self, m</span>):</span><br><span class="line">        bit4 = self.mortoncross()</span><br><span class="line">        gridcode = bit4[:m-<span class="number">32</span>]</span><br><span class="line"></span><br><span class="line">        gridcode = <span class="string">&quot;G0&quot;</span> + gridcode</span><br><span class="line">        <span class="comment"># 高度码实现下面讲。</span></span><br><span class="line">        elevationcode = self.elevationcode(m)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [gridcode, elevationcode]</span><br></pre></td></tr></table></figure><h4 id="2-高程网格剖分"><a class="markdownIt-Anchor" href="#2-高程网格剖分"></a> 2. 高程网格剖分</h4><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>n</mi><mo>=</mo><mfrac><msub><mi>θ</mi><mn>0</mn></msub><mi>θ</mi></mfrac><msub><mo><mi>log</mi><mo>⁡</mo></mo><mrow><mn>1</mn><mo>+</mo><msub><mi>θ</mi><mn>0</mn></msub></mrow></msub><mrow><mo fence="true">(</mo><mfrac><mrow><mi>H</mi><mo>+</mo><msub><mi>r</mi><mn>0</mn></msub></mrow><msub><mi>r</mi><mn>0</mn></msub></mfrac><mo fence="true">)</mo></mrow></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(5)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">n = \frac{\theta_0}{\theta} \log_{1 + \theta_0} \left( \frac{H + r_0}{r_0} \right) \tag{5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.24196799999999996em;"><span style="top:-2.45586em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.02778em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34424em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span><span class="tag"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">5</span></span><span class="mord">)</span></span></span></span></span></span></p><p>其中：</p><ul><li>( n ) —— 从地面向上（或向下）数第n层立体网格，n为整数，地面以上n大于等于0，地面以下 n &lt; 0；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\theta_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>—— 初始划分范围定义的基础网格（1°网格）对应的经（纬）跨度差，单位为弧度（rad）<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>0</mn></msub><mo>=</mo><mfrac><mi>π</mi><mn>180</mn></mfrac></mrow><annotation encoding="application/x-tex">\theta_0 = \frac{\pi}{180}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">8</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> —— 该网格对应的经（纬）跨度差，单位为弧度（rad）；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">r_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> —— 地球长半轴，单位为米（m），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mn>0</mn></msub><mo>=</mo><mn>6</mn><mtext> </mtext><mn>378</mn><mtext> </mtext><mn>137</mn></mrow><annotation encoding="application/x-tex">r_0 = 6\,378\,137</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">7</span><span class="mord">8</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mord">7</span></span></span></span>；<br />去掉层数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 高位的 0 形成的编码即为高度域编码。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算高度的网格码</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">elevationcode</span>(<span class="params">self, m</span>):</span><br><span class="line">        theta_0 = math.pi / <span class="number">180</span></span><br><span class="line">        theta = GridSpanlist[m-<span class="number">1</span>] * math.pi / <span class="number">180</span></span><br><span class="line">        H = self.elevation</span><br><span class="line">        r_0 = <span class="number">6378137</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 计算公式</span></span><br><span class="line">        n = (theta_0 / theta) * math.log((H + r_0) / r_0, (<span class="number">1</span> + theta_0))</span><br><span class="line">        n = math.floor(n)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            n = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">str</span>(<span class="built_in">bin</span>(n)[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(n) &lt; m:</span><br><span class="line">            n = <span class="string">&#x27;0&#x27;</span> * (m - <span class="built_in">len</span>(n)) + n</span><br><span class="line">        n = <span class="string">&quot;H&quot;</span> + n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure><h4 id="3-网格码反算"><a class="markdownIt-Anchor" href="#3-网格码反算"></a> 3. 网格码反算</h4><p>这一部分的具体求解国标并没有提及，因此只能尝试自行求解，代码准确性为止，仅供参考：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GridCode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, grid_code, elevation_code, m</span>):</span><br><span class="line">        self.grid_code = grid_code</span><br><span class="line">        self.elevation_code = elevation_code</span><br><span class="line">        self.m = m</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;格网编码：<span class="subst">&#123;self.grid_code, self.elevation_code&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">degridcode_bit2dms</span>(<span class="params">self, binary_str</span>):</span><br><span class="line">        degrees_bin = binary_str[<span class="number">0</span>:<span class="number">8</span>]    <span class="comment"># 前8位是度</span></span><br><span class="line">        minutes_bin = binary_str[<span class="number">8</span>:<span class="number">14</span>]   <span class="comment"># 接下来的6位是分</span></span><br><span class="line">        seconds_integer_bin = binary_str[<span class="number">14</span>:<span class="number">20</span>]  <span class="comment"># 接下来的6位是秒的整数部分</span></span><br><span class="line">        seconds_fractional_bin = binary_str[<span class="number">20</span>:<span class="number">31</span>]  <span class="comment"># 最后的11位是秒的小数部分</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将每个二进制子串转换回整数</span></span><br><span class="line">        degrees = <span class="built_in">int</span>(degrees_bin, <span class="number">2</span>)</span><br><span class="line">        minutes = <span class="built_in">int</span>(minutes_bin, <span class="number">2</span>)</span><br><span class="line">        seconds_integer = <span class="built_in">int</span>(seconds_integer_bin, <span class="number">2</span>)</span><br><span class="line">        seconds_fractional_scaled = <span class="built_in">int</span>(seconds_fractional_bin, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将秒的小数部分恢复为原来的小数值</span></span><br><span class="line">        seconds_fractional = seconds_fractional_scaled / <span class="number">2048</span></span><br><span class="line">        total_seconds = seconds_integer + seconds_fractional</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将秒数转换为分的部分（秒/60）</span></span><br><span class="line">        total_minutes = minutes + total_seconds / <span class="number">60</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将分数转换为度的部分（分/60）</span></span><br><span class="line">        decimal = <span class="built_in">abs</span>(degrees) + total_minutes / <span class="number">60</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> decimal</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 编码反算</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">degridcode</span>(<span class="params">self</span>):</span><br><span class="line">        gridcode = self.grid_code</span><br><span class="line">        gridcode = gridcode[<span class="number">2</span>:]</span><br><span class="line">        gridcode = gridcode.ljust(<span class="number">31</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        bit2 = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">bin</span>(<span class="built_in">int</span>(c, <span class="number">4</span>))[<span class="number">2</span>:].zfill(<span class="number">2</span>) <span class="keyword">for</span> c <span class="keyword">in</span> gridcode)</span><br><span class="line"></span><br><span class="line">        latbit = []</span><br><span class="line">        lonbit = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">32</span>):</span><br><span class="line">            latbit.append(bit2[i * <span class="number">2</span> - <span class="number">2</span>])</span><br><span class="line">            lonbit.append(bit2[i * <span class="number">2</span> - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        latcode = <span class="string">&#x27;&#x27;</span>.join(latbit)</span><br><span class="line">        loncode = <span class="string">&#x27;&#x27;</span>.join(lonbit)</span><br><span class="line"></span><br><span class="line">        lat = self.degridcode_bit2dms(latcode)</span><br><span class="line">        lon = self.degridcode_bit2dms(loncode)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> lat, lon</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 高度码反算</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deelevationcode</span>(<span class="params">self</span>):</span><br><span class="line">        n_binary, m = self.elevation_code, self.m</span><br><span class="line"></span><br><span class="line">        theta_0 = math.pi / <span class="number">180</span></span><br><span class="line">        theta = GridSpanlist[m-<span class="number">1</span>] * math.pi / <span class="number">180</span></span><br><span class="line">        r_0 = <span class="number">6378137</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 高度码反算</span></span><br><span class="line">        n_binary = n_binary[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将二进制的 n 转换回整数</span></span><br><span class="line">        n = <span class="built_in">int</span>(n_binary, <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 根据公式反向解码，恢复 H</span></span><br><span class="line">        H = r_0 * (math.exp((n * theta) / theta_0 * math.log(<span class="number">1</span> + theta_0)) - <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> H</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 整体反算：</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params">self</span>):</span><br><span class="line">        lat, lon = self.degridcode()</span><br><span class="line">        H = self.deelevationcode()</span><br><span class="line">        <span class="keyword">return</span> lat, lon, H</span><br></pre></td></tr></table></figure><p>这样做的目的是为了得到网格码的代表性坐标，但是这个坐标到底具体代表了网格码六面体的哪个位置，不得而知。本文仅代表个人的一些探索，代码并不一定正确。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;三维网格码计算思路分享。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>DTDC2024</title>
    <link href="https://atffang.github.io/2024/11/28/DTDC2024/"/>
    <id>https://atffang.github.io/2024/11/28/DTDC2024/</id>
    <published>2024-11-28T14:42:00.000Z</published>
    <updated>2024-11-28T14:52:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>华东师范大学李响老师课题组参加DTDC2024会议。</p><span id="more"></span><p>感谢老师！<br /><img src="https://atffang.github.io/2024/11/28/DTDC2024/DTDC2024_1.jpg"/></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;华东师范大学李响老师课题组参加DTDC2024会议。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>2024中国研究生数学建模竞赛</title>
    <link href="https://atffang.github.io/2024/11/25/2024%E4%B8%AD%E5%9B%BD%E7%A0%94%E7%A9%B6%E7%94%9F%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AB%9E%E8%B5%9B/"/>
    <id>https://atffang.github.io/2024/11/25/2024%E4%B8%AD%E5%9B%BD%E7%A0%94%E7%A9%B6%E7%94%9F%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AB%9E%E8%B5%9B/</id>
    <published>2024-11-25T04:44:51.000Z</published>
    <updated>2024-11-25T05:36:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>D题大数据驱动的地理综合问题国二。</p><span id="more"></span><p>文档全文请在PC端查看。<br /><strong>D题大数据驱动的地理综合问题</strong>，题干如下：</p><ol><li><p>在众多描述地理环境的变量中，一些简单的指标背后蕴藏了深厚的内涵，对人类的生存发展具有重大深远的影响，如大气中二氧化碳的浓度、全球年平均气温等。降水量是一个连续变化的变量，而土地利用/土地覆被类型则是一个存在突变和离散分布的变量。同时，它们都具有时空分布不均匀的特征。请从附件数据中选取相关数据集，为这两个变量分别构建一套描述性统计方法，用1<sub>3个较为简洁的统计指标或统计图表，对这两个变量在1990</sub>2020年间中国范围内的时空演化特征进行描述和总结。</p></li><li><p>近年来，以暴雨为代表的极端天气事件对人类的生产生活造成了越来越难以忽视的影响。请结合附件中所给的数据，建立数学模型，说明地形-气候相互作用在极端天气形成过程中的作用。</p></li><li><p>降雨、地形和土地利用对于暴雨等极端天气灾害的形成都具有不可忽视的影响。这其中，降雨的时空变异性和不可控性都最强；土地利用作为自然条件和人类活动的综合结果，虽然也随时空演化，但具有一定可控性；地形是最为稳定、不易改变的因素。请考虑第2问所反映的从“暴雨”到“灾害”中上述三方面因素的角色及其交互作用，确定暴雨成灾的临界条件；并结合第1问中降雨量和土地利用/土地覆被变化的历史时空演化特征，对2025~2035年间中国境内应对暴雨灾害能力最为脆弱的地区进行预测。请以地图的形式呈现你们的预测结果。</p></li><li><p>在中国级别的尺度上，描述自然地理特征的地形可以概括为“三级阶梯”，而降水中具有标志性意义的“800mm等降水量线”则与区分我国南北方的“秦岭—淮河”一线大体重合；描述人文地理特征的人口分布及其社会经济活动总量等指标，则被由连接黑龙江黑河与云南腾冲的“胡焕庸线”清晰地划分成东密西疏的两部分。那么，对于自然地理和人文地理交汇点的土地利用/土地覆被情况，结合其在前三问中描述、估计和预测任务中的“特性”，利用地理大数据，建立相应的数学模型，对数据进行简化和综合，描述中国土地利用变化的特征与结构。从准确性和有用性两个方面解释验证你们的总结。</p></li></ol><p>下面为解题文档，请在PC端查看：</p><div class="pdfobject-container" data-target="https://atffang.github.io/2024/11/25/2024中国研究生数学建模竞赛/D24102690011.pdf" data-height="500px"></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;D题大数据驱动的地理综合问题国二。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>IWGMS2024</title>
    <link href="https://atffang.github.io/2024/11/25/IWGMS2024/"/>
    <id>https://atffang.github.io/2024/11/25/IWGMS2024/</id>
    <published>2024-11-25T03:00:56.000Z</published>
    <updated>2024-11-25T04:42:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>mark一下自己的第一次汇报<sup>-</sup></p><span id="more"></span><p>感谢张海平老师给我这次机会，在3rd InternationalWorkshop on Geographic Modeling and Simulation做了人生第一次汇报，虽然没什么人听，但也怪紧张的。本次会议主题为Modeling and Simulation for a Sustainable World，主办单位是南师大。<br />秋天的南京真的好美，和闵行的肃杀相比，我越来越怀念南师大随园绿色的草坪与金色的树。<br />张海平老师负责的分会场Title为Process-oriented Geographical Analysis and Simulation，组里的汇报包括：<br />Haiping Zhang; Socio-Geographic Process Model: Theory, Methods, andApplications<br />Tianyao Fang; Spatiotemporal process simulation model for cultural transmission and acculturation<br />Nuozhou Shen; Multiscale Process Simulation for Infectious Disease Transmission<br />Yushu Xu; Intercity human dynamics during holiday weeks throughout theCovid-19 pandemic: A perspective of hybrid physical-virtual space<br />Xingxing Zhou; Spatiotemporally contiguous clustering of origin-destination flowsweighted by interaction strength to reveal interregional association pattems<br />Jinzhao Guo; Measuring spatial association in geographical processes with spatial time-series data<br /><img src="https://atffang.github.io/2024/11/25/IWGMS2024/IWGM2024_1.jpg" width="300"/><br />还见到了好久没见的朋友们。</p><img src="https://atffang.github.io/2024/11/25/IWGMS2024/IWGM2024_2.jpg" width="200"/><img src="https://atffang.github.io/2024/11/25/IWGMS2024/IWGM2024_3.jpg" width="300"/>]]></content>
    
    
    <summary type="html">&lt;p&gt;mark一下自己的第一次汇报&lt;sup&gt;-&lt;/sup&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>百度指数爬取02 年均值爬取</title>
    <link href="https://atffang.github.io/2024/10/29/%E7%99%BE%E5%BA%A6%E6%8C%87%E6%95%B0%E7%88%AC%E5%8F%9602-%E5%B9%B4%E5%9D%87%E5%80%BC%E7%88%AC%E5%8F%96/"/>
    <id>https://atffang.github.io/2024/10/29/%E7%99%BE%E5%BA%A6%E6%8C%87%E6%95%B0%E7%88%AC%E5%8F%9602-%E5%B9%B4%E5%9D%87%E5%80%BC%E7%88%AC%E5%8F%96/</id>
    <published>2024-10-29T12:26:15.000Z</published>
    <updated>2024-10-29T12:47:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>程序设计需求：爬取百度指数目标城市的年均值。</p><span id="more"></span><p>  该程序使用抓包方法获取百度指数对应搜索目标的年均值数据。通过观察百度指数网页的api调用情况，百度指数像后端请求的api构成应当为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://index.baidu.com/api/SearchApi/index?area=&#123;area&#125;&amp;word=&#123;words&#125;&amp;startDate=&#123;startDate&#125;&amp;endDate=&#123;endDate&#125;</span><br></pre></td></tr></table></figure><p>其中，area为搜索发起地，words为搜索关键字，至多包含5个，startDate和endDate分别为起始时间与结束时间。<br />这些变量的构建方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">words = [[&#123;<span class="string">&quot;name&quot;</span>: key, <span class="string">&quot;wordType&quot;</span>: <span class="number">1</span>&#125;] <span class="keyword">for</span> key <span class="keyword">in</span> keys]</span><br><span class="line"></span><br><span class="line">words = <span class="built_in">str</span>(words).replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;&#x27;&quot;</span>, <span class="string">&quot;\&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">startDate = <span class="string">f&quot;<span class="subst">&#123;year&#125;</span>-01-01&quot;</span></span><br><span class="line"></span><br><span class="line">endDate = <span class="string">f&quot;<span class="subst">&#123;year&#125;</span>-12-31&quot;</span></span><br></pre></td></tr></table></figure><p>其中，keys是搜索的各对象。</p><p>通过request构建请求头，并使用get方法请求数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;Connection&quot;</span>: <span class="string">&quot;keep-alive&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;application/json, text/plain, */*&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;Sec-Fetch-Site&quot;</span>: <span class="string">&quot;same-origin&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;Sec-Fetch-Mode&quot;</span>: <span class="string">&quot;cors&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;Sec-Fetch-Dest&quot;</span>: <span class="string">&quot;empty&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;Cipher-Text&quot;</span>: <span class="string">&quot;1698156005330_1698238860769_ZPrC2QTaXriysBT+5sgXcnbTX3/lW65av4zgu9uR1usPy82bArEg4m9deebXm7/O5g6QWhRxEd9/r/hqHad2WnVFVVWybHPFg3YZUUCKMTIYFeSUIn23C6HdTT1SI8mxsG5mhO4X9nnD6NGI8hF8L5/G+a5cxq+b21PADOpt/XB5eu/pWxNdwfa12krVNuYI1E8uHQ7TFIYjCzLX9MoJzPU6prjkgJtbi3v0X7WGKDJw9hwnd5Op4muW0vWKMuo7pbxUNfEW8wPRmSQjIgW0z5p7GjNpsg98rc3FtHpuhG5JFU0kZ6tHgU8+j6ekZW7+JljdyHUMwEoBOh131bGl+oIHR8vw8Ijtg8UXr0xZqcZbMEagEBzWiiKkEAfibCui59hltAgW5LG8IOtBDqp8RJkbK+IL5GcFkNaXaZfNMpI=&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;Referer&quot;</span>: <span class="string">&quot;https://index.baidu.com/v2/main/index.html&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;Accept-Language&quot;</span>: <span class="string">&quot;zh-CN,zh;q=0.9&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;Cookie&#x27;</span>: cookie&#125;</span><br><span class="line"></span><br><span class="line">    res = requests.get(url, headers=headers)</span><br><span class="line"></span><br><span class="line">    res_json = res.json()</span><br></pre></td></tr></table></figure><p>返回的年均值与请求关键词如下两个列表所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">retuen_keys_num = <span class="built_in">len</span>(res_json[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;generalRatio&#x27;</span>])</span><br><span class="line"></span><br><span class="line">avg_list = [res_json[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;generalRatio&#x27;</span>][i][<span class="string">&#x27;all&#x27;</span>][<span class="string">&#x27;avg&#x27;</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(retuen_keys_num)]</span><br><span class="line"></span><br><span class="line">destination_list = [res_json[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;generalRatio&#x27;</span>][i][<span class="string">&#x27;word&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;name&#x27;</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(retuen_keys_num)]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;程序设计需求：爬取百度指数目标城市的年均值。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>flask提供python脚本api查询数据库</title>
    <link href="https://atffang.github.io/2023/12/28/flask%E6%8F%90%E4%BE%9Bpython%E8%84%9A%E6%9C%ACapi%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://atffang.github.io/2023/12/28/flask%E6%8F%90%E4%BE%9Bpython%E8%84%9A%E6%9C%ACapi%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2023-12-28T02:55:33.000Z</published>
    <updated>2023-12-28T07:18:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>利用python的Flask库将脚本打包成api，实现通过url实现前端sql查询，访问数据库</p><span id="more"></span><p>起因是《GIS综合实验》这门课要求一个大作业，其中一项为WebGIS开发。对于接受了过多地学原理性课程教学而疏于计算机水平训练的学生来说，即使简单的Web开发也是一件比较头疼的事情，况且为了必须使用一个国产平台，在众多服务与文档中饶了很久的圈子。原本以为，将postgis数据库部署到平台上后，通过REST请求或者是WFS协议能够方便地实现增删改查，至少GET数据不是一件难事，但实现与设想相去甚远。和工作人员交流才知道，该平台上传的postgis数据库一般作为一个数据源为发布文件型的工作空间服务，直接查询该数据库是非常规的操作。这让我非常郁闷，原本实现的逻辑中包括读取数据库中几十万个点数据，通过deck.gl为mapbox开发的高效率点图层渲染到底图上，以及使用postgis特有的一些空间查询语句等等，如果不能直接访问数据库，那么这些设计好的逻辑、代码都要修改甚至报废。无奈之下，只能自己上手连接后端数据库，下面是实现的过程。<br />不知道答辩的时候能不能耍小聪明，堂而皇之的告诉评委这是用该国产平台实现的。<br />Flask 是一个轻量级的 Python Web 框架，用于构建 Web 应用程序，使用 Flask 可以通过定义路由来映射 URL 到相应的处理函数。这使得开发者能够轻松地构建 Web 应用的不同页面和功能（GPT语）首先在后端代码定义一个类Database，因为我的需求中暂时不需要对数据库的增删改，因此仅在该类中定义基础的打开关闭与查询功能。<a href="http://xn--api-th2el20d.py">创建api.py</a>，引入依赖库并进行基础定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> psql.postsqlConnect <span class="keyword">import</span> Database</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> flask_cors <span class="keyword">import</span> CORS</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">CORS(app, supports_credentials=<span class="literal">True</span>)</span><br><span class="line">app.config[<span class="string">&#x27;JSON_AS_ASCII&#x27;</span>] = <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>其中Database是我预先写好的数据库查询类，<code>CORS(app, supports_credentials=True)</code>是为了保障跨端口调用时不出现浏览器安全协议问题，而<code>app.config['JSON_AS_ASCII'] = False</code>用于约束查询返回的json不以二进制的形式出现。<br />接下来我们定义一个sql查询，在url中加入m_id, area_id, rating三个约束字段，以查询数据库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/api/sqlSearch&#x27;</span>, methods = [<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sqlSearch</span>():</span><br><span class="line">    m_id = request.args.get(<span class="string">&#x27;m_id&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    area_id = request.args.get(<span class="string">&#x27;area_id&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    rating = request.args.get(<span class="string">&#x27;rating&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    DB = Database(name=<span class="string">&quot;restaurant&quot;</span>, username=<span class="string">&quot;postgres&quot;</span>, password=<span class="string">&quot;20020405&quot;</span>, host=<span class="string">&quot;10.20.72.101&quot;</span>, port=<span class="string">&quot;5432&quot;</span>)</span><br><span class="line">    DB.connect()</span><br><span class="line"></span><br><span class="line">    baseSql = <span class="string">&quot;SELECT id, ST_X(geom) AS lon, ST_Y(geom) AS lat FROM public.shanghai_restaurants&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> m_id != <span class="string">&quot;&quot;</span> <span class="keyword">or</span> area_id != <span class="string">&quot;&quot;</span> <span class="keyword">or</span> rating != <span class="string">&quot;&quot;</span>:</span><br><span class="line">        m_idSql, area_idSql, ratingSql = <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> m_id != <span class="string">&quot;&quot;</span>:</span><br><span class="line">            m_idSql = <span class="string">&quot;m_id = &quot;</span> + <span class="built_in">str</span>(m_id)</span><br><span class="line">        <span class="keyword">if</span> area_id != <span class="string">&quot;&quot;</span>:</span><br><span class="line">            area_idSql = <span class="string">&quot;area_id = &quot;</span> + <span class="built_in">str</span>(area_id)</span><br><span class="line">        <span class="keyword">if</span> rating != <span class="string">&quot;&quot;</span>:</span><br><span class="line">            <span class="keyword">match</span> = re.<span class="keyword">match</span>(<span class="string">r&quot;\((\d+),(\d+)\)&quot;</span>, rating)</span><br><span class="line">            a, b = <span class="built_in">map</span>(<span class="built_in">str</span>, <span class="keyword">match</span>.groups())</span><br><span class="line">            ratingSql = <span class="string">f&quot;rating BETWEEN <span class="subst">&#123;a&#125;</span> AND <span class="subst">&#123;b&#125;</span>&quot;</span></span><br><span class="line">            </span><br><span class="line">        whereSql = <span class="string">&quot; WHERE &quot;</span>+<span class="string">&#x27; AND &#x27;</span>.join(s <span class="keyword">for</span> s <span class="keyword">in</span> [m_idSql, area_idSql, ratingSql] <span class="keyword">if</span> s)</span><br><span class="line">        finalSql = baseSql + whereSql</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        finalSql = baseSql</span><br><span class="line">        </span><br><span class="line">    json_data = DB.select(finalSql)</span><br><span class="line">    DB.close()</span><br><span class="line">    <span class="keyword">return</span> json_data</span><br></pre></td></tr></table></figure><p>由于我的需求仅限于查找，因此在定义时设置的是 methods = [‘GET’]，如果需要增删改，那么请使用POST请求。对于这个功能，我们定义的基础的url是端口+/api/sqlSearch，其中api是我这个python脚本的文件名，sqlSearch是我接下来要定义的函数名。<br />在sqlSearch函数中，首先通过request.args.get方法获取url中的参数，随后连接数据库，将这些参数解析为sql语句并提交查找，返回json文件。<br />运行该程序，会返回给你一个端口，例如我的终端提示为：<code>Running on http://127.0.0.1:5000</code>。在这个url后面再加上<code>/api/sqlSearch</code>，浏览器就会返回数据库所有记录的json。在<code>Running on http://127.0.0.1:5000/api/sqlSearch</code>后用<code>?</code>（英文）拼接查询语句，可以实现sql查询，其固定句式为<code>?参数一=x&amp;参数二=y</code>，当然，不写某个参数（数据库里的字段）的查询条件也可以，这完全取决于上面的查询函数中是如何定义的，<code>parameter = request.args.get('参数一','')</code>获取的就是上述url中的x，一般来说，可以设计为当x非空时，加入sql查询中的WHERE语句。<br />运行程序开启服务后，在web中输入url：<code>http://127.0.0.1:5000/api/sqlSearch?m_id=116&amp;area_id=3&amp;rating=(3,3)</code>,返回的页面如下所示：<br /><img align="center" width=100% src="https://s2.loli.net/2023/12/28/zaARsTgGNEPtIOc.png" style="margin-right: 20px;margin-top: 10px;margin-buttom:20px;"><br />在JavaScript中，只需解析用户输入的参数为url，就可渐变快速地查询访问数据库，使用deck.gl渲染在底图上：<br /><img width=50% src="https://s2.loli.net/2023/12/28/nefamgV3FP5xdqL.png" style="margin-right: 20px;margin-top: 10px;margin-buttom:20px;"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;利用python的Flask库将脚本打包成api，实现通过url实现前端sql查询，访问数据库&lt;/p&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
  <entry>
    <title>python并行运算</title>
    <link href="https://atffang.github.io/2023/11/12/python%E5%B9%B6%E8%A1%8C%E8%BF%90%E7%AE%97/"/>
    <id>https://atffang.github.io/2023/11/12/python%E5%B9%B6%E8%A1%8C%E8%BF%90%E7%AE%97/</id>
    <published>2023-11-12T05:33:09.000Z</published>
    <updated>2023-11-12T06:38:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用multiprocessing函数在python中实现并行运算。</p><span id="more"></span><p>python中自带的 <a href="https://docs.python.org/zh-cn/3/library/multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code>multiprocessing</code></a> 包同时提供了本地和远程并发操作，允许程序员充分利用设备上的多个处理器。本文主要介绍之中的Pool对象，它提供了一种快捷的方法，赋予函数并行化处理一系列输入值的能力，可以将输入数据分配给不同进程处理（数据并行）。在官方文档中的例子是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> Pool(<span class="number">5</span>) <span class="keyword">as</span> p:</span><br><span class="line">        <span class="built_in">print</span>(p.<span class="built_in">map</span>(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br></pre></td></tr></table></figure><p>本文将简单演示并行运算在处理数据中带来的性能提升。我将使用Pool函数实现并行遍历一个包含一百万条数据的csv文件并进行一些简单的运算，以对比我的设备在不同的进程数量下处理数据的速度。<br />代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool  </span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_csv_chunk</span>(<span class="params">file_chunk</span>):  </span><br><span class="line">    df0 = pd.read_csv(file_chunk)  </span><br><span class="line">    <span class="keyword">return</span> df0  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 简单读取运算一下数据  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">df0</span>):  </span><br><span class="line">    result_sum = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> index, row <span class="keyword">in</span> df0.iterrows():  </span><br><span class="line">        result_sum += row[<span class="number">5</span>] * row[<span class="number">0</span>]  </span><br><span class="line">    <span class="keyword">return</span> result_sum  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 并行运算  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deal_csv_parallel</span>(<span class="params">df0, times</span>):  </span><br><span class="line">    result_sum = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">if</span> times == <span class="number">0</span>:  </span><br><span class="line">        <span class="keyword">for</span> index, row <span class="keyword">in</span> df0.iterrows():  </span><br><span class="line">            result_sum += row[<span class="number">5</span>] * row[<span class="number">0</span>]  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> result_sum  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> times != <span class="number">0</span>:  </span><br><span class="line">        chunk_size = <span class="built_in">len</span>(df0) // times  </span><br><span class="line">        chunks = [df[i:i + chunk_size] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(df), chunk_size)]  </span><br><span class="line">        <span class="keyword">with</span> Pool(times) <span class="keyword">as</span> p:  </span><br><span class="line">            results = p.<span class="built_in">map</span>(f, chunks)  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(results)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">      </span><br><span class="line">    <span class="comment"># 文件路径  </span></span><br><span class="line">    file_path = <span class="string">&#x27;output.csv&#x27;</span>  </span><br><span class="line">  </span><br><span class="line">    df = read_csv_chunk(file_path)  </span><br><span class="line">  </span><br><span class="line">    Pool_size = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>)]  </span><br><span class="line">    run_time = []  </span><br><span class="line">    run_time_multiple = []  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> Pool_size:  </span><br><span class="line">        start_time = time.time()  </span><br><span class="line">  </span><br><span class="line">        deal_csv_parallel(df, i)  </span><br><span class="line">  </span><br><span class="line">        end_time = time.time()  </span><br><span class="line">  </span><br><span class="line">        t = end_time - start_time  </span><br><span class="line">  </span><br><span class="line">        run_time.append(t)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> run_time:  </span><br><span class="line">        run_time_multiple.append(<span class="string">f&quot;<span class="subst">&#123;run_time[<span class="number">0</span>]/item*<span class="number">100</span>&#125;</span>%&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">    data = &#123;<span class="string">&#x27;并行数&#x27;</span>: Pool_size, <span class="string">&#x27;运行时间&#x27;</span>: run_time, <span class="string">&#x27;效率比&#x27;</span>: run_time_multiple&#125;   </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">print</span>(df_out)</span><br></pre></td></tr></table></figure><p>其中，<code>chunks = [df[i:i + chunk_size] for i in range(0, len(df), chunk_size)]</code>负责将表格拆分成和进程数相等的几个部分，随后通用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> Pool(times) <span class="keyword">as</span> p:  </span><br><span class="line">    results = p.<span class="built_in">map</span>(f, chunks) </span><br></pre></td></tr></table></figure><p>进行并行运算。代码运行的结果为：</p><table><thead><tr><th style="text-align:center">进程数</th><th style="text-align:center">运行时间</th><th style="text-align:center">效率比</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">30.298478</td><td style="text-align:center">100.0%</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">30.566270</td><td style="text-align:center">99.12389630201749%</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">15.768265</td><td style="text-align:center">192.14846418175512%</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">10.124307</td><td style="text-align:center">299.26471386481404%</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">7.879102</td><td style="text-align:center">384.5422643570513%</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">7.495068</td><td style="text-align:center">404.24552340989857%</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">6.015692</td><td style="text-align:center">503.65742377427705%</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">5.712452</td><td style="text-align:center">530.3935987002207%</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">5.440717</td><td style="text-align:center">556.8838978332274%</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">5.770803</td><td style="text-align:center">525.030563530312%</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">5.318123</td><td style="text-align:center">569.7212889333297%</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">5.124458</td><td style="text-align:center">591.2523645483335%</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">5.040725</td><td style="text-align:center">601.0737603013101%</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">5.147555</td><td style="text-align:center">588.5993925729343%</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">4.993004</td><td style="text-align:center">606.8185840078334%</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">5.116237</td><td style="text-align:center">592.2023776071396%</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">5.017882</td><td style="text-align:center">603.8101404027773%</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">5.150956</td><td style="text-align:center">588.2107286306572%</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">5.068639</td><td style="text-align:center">597.7636351261095%</td></tr><tr><td style="text-align:center">19</td><td style="text-align:center">4.979399</td><td style="text-align:center">608.4766411595016%</td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">5.103571</td><td style="text-align:center">593.6720989778112%</td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">5.076162</td><td style="text-align:center">596.8777272425182%</td></tr><tr><td style="text-align:center">22</td><td style="text-align:center">5.401071</td><td style="text-align:center">560.9716614488367%</td></tr><tr><td style="text-align:center">23</td><td style="text-align:center">5.360952</td><td style="text-align:center">565.1697690343107%</td></tr><tr><td style="text-align:center">24</td><td style="text-align:center">5.318242</td><td style="text-align:center">569.7085696153763%</td></tr><tr><td style="text-align:center">25</td><td style="text-align:center">5.748274</td><td style="text-align:center">527.088308186721%</td></tr></tbody></table><div style="width: 90%;margin: 0 auto">    <canvas id="chart4944" style="height: 300px"></canvas></div><script src="https://cdn.jsdelivr.net/npm/chart.js@2.9.3/dist/Chart.min.js"></script><script type="text/javascript">    var ctx = document.getElementById('chart4944').getContext('2d');    var options =       {      type: 'line',      data: {      labels: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25'],      datasets: [{          label: '运行速度',          borderColor: 'rgb(255, 99, 132)',          data: [30.298478, 30.566270, 15.768265, 10.124307, 7.879102, 7.495068, 6.015692, 5.712452, 5.440717, 5.770803, 5.318123, 5.124458, 5.040725, 5.147555, 4.993004, 5.116237, 5.017882, 5.150956, 5.068639, 4.979399, 5.103571, 5.076162, 5.401071, 5.360952, 5.318242, 5.748274]          }]      },      options: {          responsive: true,          title: {          display: true,          text: '进程数与运行速度'          }      }  }  ;    new Chart(ctx, options);</script><p>可以看到，在进程数大于对于4后程序运行速度下降开始收敛，并维持在一定水平。速度最低点较非并行运算节约了5/6的时间，可见并行预算对这种背景下的数据处理带来的收益之大。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用multiprocessing函数在python中实现并行运算。&lt;/p&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
</feed>
