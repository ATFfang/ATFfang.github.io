<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ATField&#39; s BLOG</title>
  
  <subtitle>ATField</subtitle>
  <link href="https://atffang.github.io/atom.xml" rel="self"/>
  
  <link href="https://atffang.github.io/"/>
  <updated>2025-03-06T11:29:13.299Z</updated>
  <id>https://atffang.github.io/</id>
  
  <author>
    <name>FangTianYao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GNNWR</title>
    <link href="https://atffang.github.io/2025/03/06/GNNWR/"/>
    <id>https://atffang.github.io/2025/03/06/GNNWR/</id>
    <published>2025-03-06T06:47:14.000Z</published>
    <updated>2025-03-06T11:29:13.299Z</updated>
    
    <content type="html"><![CDATA[<p>Geographically neural network weighted regression for the accurate estimation of spatial non-stationarity</p><span id="more"></span><h3 id="1-spatial-non-stationarity"><a class="markdownIt-Anchor" href="#1-spatial-non-stationarity"></a> 1. Spatial Non-stationarity</h3><p>空间非平稳性（Spatial Non-stationarity）是指在地理空间中，变量之间的关系随着地理位置的不同而发生变化的现象。具体来说，它意味着在不同的空间位置，同一组变量之间的统计关系（如回归系数）可能会有所不同。这种非平稳性反映了地理现象在空间上的异质性，即不同地区的地理过程和机制可能存在显著差异。</p><p>传统的回归模型无法捕捉到这种空间非平稳性，因此，A. Stewart Fotheringham在1996年首次提出了地理加权回归（Geographically Weighted Regression, GWR）。是一种空间分析方法，用于分析地理数据中变量之间的局部关系。它通过为每个地理位置进行单独的回归分析，GWR允许回归系数在空间上变化，从而捕捉到空间异质性。这与传统回归模型（如普通最小二乘回归，OLS）假设全局关系不变不同。</p><p>为了理解GWR，我们先从OLS开始。普通最小二乘回归的模型形式为：</p><p align="center"><img src="https://latex.codecogs.com/gif.latex?y_i%20=%20\beta_0%20+%20\beta_1%20x_{i1}%20+%20\beta_2%20x_{i2}%20+%20\cdots%20+%20\beta_p%20x_{ip}%20+%20\epsilon_i"></p><p>其中， <img src="https://latex.codecogs.com/gif.latex?y_i"> 是因变量，<img src="https://latex.codecogs.com/gif.latex?x_{ij}"> 是自变量，<img src="https://latex.codecogs.com/gif.latex?\beta_j"> 是回归系数，<img src="https://latex.codecogs.com/gif.latex?\epsilon_i"> 是误差项。</p><p>在GWR中，回归系数 <img src="https://latex.codecogs.com/gif.latex?\beta_j"> 被允许在空间上变化，即每个地理位置都有自己的一组回归系数。GWR的模型形式为：</p><p align="center"><img src="https://latex.codecogs.com/gif.latex?y_i%20=%20\beta_0(u_i,%20v_i)%20+%20\beta_1(u_i,%20v_i)%20x_{i1}%20+%20\beta_2(u_i,%20v_i)%20x_{i2}%20+%20\cdots%20+%20\beta_p(u_i,%20v_i)%20x_{ip}%20+%20\epsilon_i"></p><p>其中，<img src="https://latex.codecogs.com/gif.latex?\beta_p(u_i,%20v_i)%20x_{ip}"> 是依赖于地理位置 <img src="https://latex.codecogs.com/gif.latex?(u_i,%20v_i)%20x_{ip}"> 的回归系数，意味着不同地理位置可能有不同的线性关系。</p><p>在OLS的求解中，我们先使用矩阵表示：</p><p align="center"><img src="https://latex.codecogs.com/gif.latex?\mathbf{y}%20=%20\mathbf{X}%20\boldsymbol{\beta}%20+%20\boldsymbol{\varepsilon}"></p><p>其中：</p><ul><li><p><img src="https://latex.codecogs.com/gif.latex?\mathbf{y}"> 是 <img src="https://latex.codecogs.com/gif.latex?n%20\times%201"> 的因变量向量。</p></li><li><p><img src="https://latex.codecogs.com/gif.latex?\mathbf{X}"> 是 <img src="https://latex.codecogs.com/gif.latex?n%20\times%20(p+1)"> 的设计矩阵。</p></li><li><p><img src="https://latex.codecogs.com/gif.latex?\boldsymbol{\beta}"> 是 <img src="https://latex.codecogs.com/gif.latex?(p+1)%20\times%201"> 的回归系数向量。</p></li><li><p><img src="https://latex.codecogs.com/gif.latex?\boldsymbol{\varepsilon}"> 是 <img src="https://latex.codecogs.com/gif.latex?n%20\times%201"> 的误差向量。</p></li></ul><p>在最小二乘法中，我们希望通过找到回归系数𝛽来最小化目标函数：</p><p align="center"><img src="https://latex.codecogs.com/gif.latex?\text{RSS}%20=%20\|y%20-%20X\beta\|^2"></p><p align="center"><img src="https://latex.codecogs.com/gif.latex?\text{RSS}%20=%20(y%20-%20X\beta)^T(y%20-%20X\beta)"></p><p align="center"><img src="https://latex.codecogs.com/gif.latex?\text{RSS}%20=%20y^T%20y%20-%20y^T%20X%20\beta%20-%20\beta^T%20X^T%20y%20+%20\beta^T%20X^T%20X%20\beta"></p><p>由于 <img src="https://latex.codecogs.com/gif.latex?y^T%20X%20\beta"> 和 <img src="https://latex.codecogs.com/gif.latex?\beta^T%20X^T%20y"> 是标量，互为转置，因此它们相等，可以简化为：<p align="center"><img src="https://latex.codecogs.com/gif.latex?\text{RSS}%20=%20y^T%20y%20-%202%20\beta^T%20X^T%20y%20+%20\beta^T%20X^T%20X%20\beta"></p></p><p>对 <img src="https://latex.codecogs.com/gif.latex?\beta"> 求导，并令导数（目标函数的梯度）为零，得到：</p><p align="center"><img src="https://latex.codecogs.com/gif.latex?\frac{\partial%20\text{RSS}}{\partial%20\beta}%20=%20-2X^T%20y%20+%202X^T%20X%20\beta%20=%200"></p><p align="center"><img src="https://latex.codecogs.com/gif.latex?X^T%20X%20\beta%20=%20X^T%20y"></p><p align="center"><img src="https://latex.codecogs.com/gif.latex?\beta%20=%20(X^T%20X)^{-1}%20X^T%20y"></p><p>OLS模型的参数估计为：</p><p align="center"><img src="https://latex.codecogs.com/gif.latex?\hat{\boldsymbol{\beta}}%20=%20(\mathbf{X}^T%20\mathbf{X})^{-1}%20\mathbf{X}^T%20\mathbf{y}"></p><p>这里，<img src="https://latex.codecogs.com/gif.latex?\hat{\boldsymbol{\beta}}"> 是通过最小化残差平方和得到的回归系数的估计值。</p><p>将GWR的权重矩阵引入。为了估计每个地理位置的局部回归系数，GWR对每个点分配一个权重矩阵<img src="https://latex.codecogs.com/gif.latex?W(u_i,%20v_i)">用于表示与其他点的地理邻近关系。距离越近的点权重越大，距离远的点权重越小。回归系数可以通过加权最小二乘法来估计：</p><p align="center"><img src="https://latex.codecogs.com/gif.latex?\hat{\beta}(u_i,%20v_i)%20=%20(X^T%20W(u_i,%20v_i)%20X)^{-1}%20X^T%20W(u_i,%20v_i)%20y"></p><p>GWR 的目标函数是对每个观测点单独进行回归。权重矩阵 <img src="https://latex.codecogs.com/gif.latex?W(u_i,%20v_i)"> 表示为：</p><p align="center"><img src="https://latex.codecogs.com/gif.latex?W(u_i,%20v_i)%20=%20\begin{pmatrix}w_{i1}%20&amp;%200%20&amp;%200%20&amp;%20\dots%20&amp;%200%20\\0%20&amp;%20w_{i2}%20&amp;%200%20&amp;%20\dots%20&amp;%200%20\\0%20&amp;%200%20&amp;%20w_{i3}%20&amp;%20\dots%20&amp;%200%20\\\vdots%20&amp;%20\vdots%20&amp;%20\vdots%20&amp;%20\ddots%20&amp;%200%20\\0%20&amp;%200%20&amp;%200%20&amp;%20\dots%20&amp;%20w_{in}\end{pmatrix}"></p><p>权重<img src="https://latex.codecogs.com/gif.latex?wij">通常是通过某种距离衰减函数来计算的，常见的是高斯核函数：</p><p align="center"><img src="https://latex.codecogs.com/gif.latex?w_{ij}%20=%20\exp\left(-\frac{d_{ij}^2}{2b^2}\right)"></p><p>其中：</p><ul><li><p><img src="https://latex.codecogs.com/gif.latex?w_{ij}"> 是观测点 <img src="https://latex.codecogs.com/gif.latex?i"> 与观测点 <img src="https://latex.codecogs.com/gif.latex?j"> 之间的权重，</p></li><li><p><img src="https://latex.codecogs.com/gif.latex?d_{ij}"> 是观测点 <img src="https://latex.codecogs.com/gif.latex?i"> 和 <img src="https://latex.codecogs.com/gif.latex?j"> 之间的空间距离，</p></li><li><p><img src="https://latex.codecogs.com/gif.latex?b"> 是带宽参数。带宽参数 <img src="https://latex.codecogs.com/gif.latex?b"> 控制了权重函数的衰减速度，较大的带宽意味着更远的点也会对回归系数产生影响，而较小的带宽则意味着只有邻近的点才会对回归系数产生影响。</p></li></ul><p>也就是说，在GWR模型中，局部系数的估计是基于已知点的数据，而不是目标观测点的数据。对于每个待遇测点，我们选择一个包含目标点及其邻近点的数据集，然后在这个数据集上进行回归分析，得到该点的局部回归系数。这个过程会重复进行，直到所有待测点的局部回归系数都被估计出来。</p><h3 id="2-gnnwr-model"><a class="markdownIt-Anchor" href="#2-gnnwr-model"></a> 2. GNNWR model</h3><p>GNNWR模型通过引入神经网络来动态计算空间权重矩阵<img src="https://latex.codecogs.com/gif.latex?W(u_i,%20v_i)">，从而更灵活地捕捉空间非平稳性。</p><p align="center"><img src="https://latex.codecogs.com/gif.latex?\mathbf{W}(u_i,%20v_i)%20=%20\text{SWNN}(d_{i1},%20d_{i2},%20\ldots,%20d_{in})"></p><p>其中，SWNN是一个是一个神经网络，输入是目标位置与所有其他位置之间的距离向量<img src="https://latex.codecogs.com/gif.latex?d_{i1},%20d_{i2},%20\ldots,%20d_{in}">，输出是权重矩阵<img src="https://latex.codecogs.com/gif.latex?W(u_i,%20v_i)">。</p><p>GNNWR通过两项指标进行模型诊断：</p><ul><li>Goodness of Fit检验</li></ul><p align="center"><img src="https://latex.codecogs.com/gif.latex?F_1%20=%20\frac{RSS_G%20/%20\delta_1}{RSS_0%20/%20(n%20-%20p%20-%201)}"></p><p>其中，<img src="https://latex.codecogs.com/gif.latex?RSS_G">是GNNWR模型的残差平方和，<img src="https://latex.codecogs.com/gif.latex?RSS_0">是OLS模型的残差平方和，<img src="https://latex.codecogs.com/gif.latex?\delta_1">是GNNWR模型中使用的带宽参数。</p><ul><li>变量的空间变化检验</li></ul><p align="center"><img src="https://latex.codecogs.com/gif.latex?V_k^2%20=%20\frac{1}{n}%20\sum_{i=1}^{n}%20\left(%20\hat{\beta}_{ik}%20-%20\frac{1}{n}%20\sum_{i=1}^{n}%20\hat{\beta}_{ik}%20\right)^2"></p><p align="center"><img src="https://latex.codecogs.com/gif.latex?F_2(k)%20=%20\frac{V_k^2%20/%20\gamma_1}{\hat{\sigma}^2}"></p><p>实际上，GNNWR模型使用神经网络替代了GWR中的距离衰减核函数，从而能够捕捉更复杂的空间关系。文章使用训练集数据来训练SWNN，优化网络权重和偏差。训练过程使用最小化均方误差（MSE）作为损失函数：</p><p align="center"><img src="https://latex.codecogs.com/gif.latex?\text{MSE}%20=%20\frac{1}{n}%20\sum_{i=1}^{n}%20(y_i%20-%20\hat{y}_i)^2"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Geographically neural network weighted regression for the accurate estimation of spatial non-stationarity&lt;/p&gt;</summary>
    
    
    
    <category term="空间分析与GIS算法" scheme="https://atffang.github.io/categories/%E7%A9%BA%E9%97%B4%E5%88%86%E6%9E%90%E4%B8%8EGIS%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>threading or multiprocessing?</title>
    <link href="https://atffang.github.io/2025/02/26/threading%20or%20multiprocessing/"/>
    <id>https://atffang.github.io/2025/02/26/threading%20or%20multiprocessing/</id>
    <published>2025-02-26T02:06:23.000Z</published>
    <updated>2025-02-26T03:18:10.861Z</updated>
    
    <content type="html"><![CDATA[<p>Python  两种并发机制</p><span id="more"></span><h4 id="threading"><a class="markdownIt-Anchor" href="#threading"></a> Threading</h4><p><strong>threading（线程编程）</strong> 是一种通过在程序中创建多个执行单元（线程），来实现并发执行的技术。线程共享同一个进程的内存空间，并且可以并行处理任务，因此能够更好地利用多核CPU资源。</p><p><strong>线程</strong>是进程中的一个轻量级执行单元，一个进程可以包含多个线程。这些线程共享相同的内存和资源（如文件句柄），但每个线程有自己的栈和指令指针。由于共享内存，线程间通信非常快速，但也更容易出现竞争条件、死锁等同步问题。</p><p><strong>threading经典应用场景</strong></p><ul><li><strong>I/O操作</strong>：在等待I/O操作完成（如文件读写、网络请求）时，其他线程可以继续执行任务，提高程序响应速度。</li><li><strong>并发任务</strong>：例如图形界面的响应式编程、并行数据处理。</li></ul><p><strong>An Example</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_data</span>(<span class="params">url</span>):</span><br><span class="line">response = request.get(url)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;response.status_code&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">urls = [url1, url2……]</span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">t = threading.Thread(target=fetch_data, args=(url,))</span><br><span class="line">threads.append(t)</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">t.join()</span><br></pre></td></tr></table></figure><p>多进程虽然能够处理并行任务，但每个进程的上下文切换会有额外的开销，这会影响程序的性能。因此，此类简单的请求工作更加适合使用多线程。</p><p><strong>optimize</strong>：<br />concurrent 是 Python 标准库中的一个模块，专门用于支持 <strong>并发编程</strong>。它提供了高层次的接口来管理多个任务的并发执行，主要包括线程和进程池的管理。<br />如果存在大量需要访问的url，可以使用concurrent.futures进行线程池创建。通过线程池，可以控制同时运行的线程数，避免一次性创建过多的线程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 任务函数：访问URL</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_data</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Finished download from: <span class="subst">&#123;url&#125;</span>, Status Code: <span class="subst">&#123;response.status_code&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> requests.RequestException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error downloading <span class="subst">&#123;url&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># URL列表（假设有1000个）</span></span><br><span class="line">urls = [<span class="string">&quot;http://example.com&quot;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用ThreadPoolExecutor</span></span><br><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">20</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    <span class="comment"># 提交所有任务</span></span><br><span class="line">    futures = [executor.submit(fetch_data, url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等待任务完成</span></span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> concurrent.futures.as_completed(futures):</span><br><span class="line">        future.result()  <span class="comment"># 可以获取返回结果，若不关心结果，可以省略这行</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;All downloads complete.&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="multiprocessing"><a class="markdownIt-Anchor" href="#multiprocessing"></a> Multiprocessing</h4><p><strong>multiprocessing（多进程编程）</strong> 是通过在程序中创建多个独立的进程，每个进程都有自己的内存空间、资源和执行单元，以实现并行处理。多进程能够避免线程竞争带来的问题，因为各个进程之间是独立的。</p><p><strong>进程</strong>是操作系统中资源分配的基本单位。每个进程都有自己的地址空间、文件句柄、栈、堆等资源。不同于线程，进程之间不共享内存，这意味着它们更加安全，但也需要更复杂的通信方式（如管道、消息队列）来进行数据交换。</p><p><strong>multiprocessing的典型应用场景：</strong></p><ul><li><strong>高可靠性任务</strong>：当某些任务必须完全隔离，不能因为其他任务的崩溃而被干扰时（如服务器进程、数据库进程等）。</li><li><strong>CPU密集型任务</strong>：需要大量的计算资源时（如图像处理、科学计算），使用多进程可以充分利用多核CPU的性能。</li></ul><p>关于multiprocessing的基础应用，在之前的文章《python并行运算》中做过大致介绍。<br /><strong>An Example</strong><br />并行矩阵运算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义矩阵计算任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">matrix_square</span>(<span class="params">matrix</span>):</span><br><span class="line">    <span class="keyword">return</span> np.dot(matrix, matrix)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 创建一个随机矩阵</span></span><br><span class="line">    matrices = [np.random.rand(<span class="number">1000</span>, <span class="number">1000</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用进程池进行并行计算</span></span><br><span class="line">    <span class="keyword">with</span> mp.Pool(processes=<span class="number">4</span>) <span class="keyword">as</span> pool:</span><br><span class="line">        results = pool.<span class="built_in">map</span>(matrix_square, matrices)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Matrix calculations completed.&quot;</span>)</span><br></pre></td></tr></table></figure><p>并行蒙特卡洛模拟：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义蒙特卡罗模拟任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">monte_carlo_pi</span>(<span class="params">num_samples</span>):</span><br><span class="line">    inside_circle = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_samples):</span><br><span class="line">        x, y = random.random(), random.random()</span><br><span class="line">        <span class="keyword">if</span> x**<span class="number">2</span> + y**<span class="number">2</span> &lt;= <span class="number">1</span>:</span><br><span class="line">            inside_circle += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> inside_circle / num_samples * <span class="number">4</span>  <span class="comment"># 估算π值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 每个进程处理100万次采样</span></span><br><span class="line">    num_samples = <span class="number">1000000</span></span><br><span class="line">    num_processes = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用进程池并行运行蒙特卡罗模拟</span></span><br><span class="line">    <span class="keyword">with</span> mp.Pool(processes=num_processes) <span class="keyword">as</span> pool:</span><br><span class="line">        pi_estimates = pool.<span class="built_in">map</span>(monte_carlo_pi, [num_samples] * num_processes)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算平均值</span></span><br><span class="line">    pi_average = <span class="built_in">sum</span>(pi_estimates) / num_processes</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Estimated Pi: <span class="subst">&#123;pi_average&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>optimize</strong>：<br />concurrent.futures的ProcessPoolExecutor ，类似于multiprocessing.Pool</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义蒙特卡罗模拟任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">monte_carlo_pi</span>(<span class="params">num_samples</span>):</span><br><span class="line">    inside_circle = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_samples):</span><br><span class="line">        x, y = random.random(), random.random()</span><br><span class="line">        <span class="keyword">if</span> x**<span class="number">2</span> + y**<span class="number">2</span> &lt;= <span class="number">1</span>:</span><br><span class="line">            inside_circle += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> inside_circle / num_samples * <span class="number">4</span>  <span class="comment"># 估算π值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    num_samples = <span class="number">1000000</span>  <span class="comment"># 每个进程采样的数量</span></span><br><span class="line">    num_processes = <span class="number">4</span>      <span class="comment"># 进程数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用 ProcessPoolExecutor 并行执行任务</span></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ProcessPoolExecutor(max_workers=num_processes) <span class="keyword">as</span> executor:</span><br><span class="line">        futures = [executor.submit(monte_carlo_pi, num_samples) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_processes)]</span><br><span class="line">        pi_estimates = [f.result() <span class="keyword">for</span> f <span class="keyword">in</span> concurrent.futures.as_completed(futures)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算平均估算值</span></span><br><span class="line">    pi_average = <span class="built_in">sum</span>(pi_estimates) / num_processes</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Estimated Pi: <span class="subst">&#123;pi_average&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="concurrentfeatures优势"><a class="markdownIt-Anchor" href="#concurrentfeatures优势"></a> concurrent.features优势</h4><ol><li><p><strong>统一接口</strong>：无论是使用 ThreadPoolExecutor 还是 ProcessPoolExecutor，它们的 API 是统一的，可以很方便地根据任务类型选择是使用线程还是进程。</p></li><li><p><strong>简化代码</strong>：相比 multiprocessing.Pool，concurrent.futures 提供了更高层的接口，如 submit() 和 as_completed()，减少了复杂度。</p></li><li><p><strong>Future 对象</strong>：submit() 方法返回 Future 对象，允许在任务完成后方便地获取结果、检查任务状态或处理异常。</p></li><li><p><strong>自动资源管理</strong>：concurrent.futures 支持上下文管理（with 语句），能够自动管理进程或线程池的生命周期，避免资源泄漏。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;Python  两种并发机制&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript异步机制浅析</title>
    <link href="https://atffang.github.io/2025/02/22/JavaScript%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/"/>
    <id>https://atffang.github.io/2025/02/22/JavaScript%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/</id>
    <published>2025-02-22T02:02:54.000Z</published>
    <updated>2025-02-22T02:02:54.948Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>asyncio浅析</title>
    <link href="https://atffang.github.io/2025/02/21/asyncio%E6%B5%85%E6%9E%90/"/>
    <id>https://atffang.github.io/2025/02/21/asyncio%E6%B5%85%E6%9E%90/</id>
    <published>2025-02-21T02:10:09.000Z</published>
    <updated>2025-02-25T05:42:15.452Z</updated>
    
    <content type="html"><![CDATA[<p>Python  asyncio机制</p><span id="more"></span><h4 id="event-loop"><a class="markdownIt-Anchor" href="#event-loop"></a> Event Loop</h4><p>Python 的事件循环（Event Loop）是异步编程中的核心概念，通常与 <code>asyncio</code> 库（Python3.5引入）一起使用。事件循环负责管理和调度异步任务，确保这些任务在适当的时机运行，而不会阻塞主线程。事件循环是基于“协程”的模型，它允许 Python 程序在进行 I/O 操作或等待某些事件时不会阻塞其他操作，从而提高程序的效率。<br /><strong>event loop</strong>的基本流程：</p><ul><li><strong>定义协程（coroutines）</strong>: 协程是 Python 中的异步函数（Asynchronous Functions），通常用 <code>async def</code> 定义，执行时不会立即执行，而是返回一个 “awaitable” 对象。</li><li><strong>创建事件循环</strong>: <code>asyncio.get_event_loop()</code> 创建一个事件循环，它负责管理和调度所有异步任务。</li><li><strong>运行事件循环</strong>: 使用 <code>loop.run_until_complete()</code> 来启动事件循环，直到指定的任务完成。</li><li><strong>任务调度</strong>: 事件循环会根据任务的状态（是否可以执行）决定哪个任务应该被调度执行。</li></ul><h4 id="asyncio-的基本使用规范"><a class="markdownIt-Anchor" href="#asyncio-的基本使用规范"></a> asyncio 的基本使用规范</h4><p>异步函数是使用 <code>async def</code> 语法定义的，它们返回一个协程对象，而不是直接执行函数体。当你调用这个函数时，实际上返回的是一个尚未完成的协程对象，需要通过事件循环来执行。<br />定义一个异步函数如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">my_coroutine</span>():</span><br><span class="line"><span class="keyword">await</span> asynico.sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><strong><code>await</code></strong> 用于挂起协程的执行，等待一个异步操作完成后再继续执行。</p><p><code>asyncio</code> 提供了事件循环来调度异步任务。事件循环负责执行异步任务，并管理任务的调度。</p><ul><li><strong><code>asyncio.run()</code></strong>：用于运行一个顶层的异步函数。它创建一个事件循环并运行直到协程执行完成，最后关闭事件循环。通常用于程序的入口。</li><li><strong><code>asyncio.run(main())</code></strong>：该方法会运行 <code>main()</code> 协程，并在执行完毕后关闭事件循环。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 asyncio.run() 启动事件循环</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">await</span> my_coroutine()</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><ul><li><strong><code>asyncio.gather()</code></strong>：用于并发执行多个协程，等到所有协程都完成后，才继续执行后面的代码。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">another_coroutine</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始执行另一个协程&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;另一个协程执行结束&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(my_coroutine(), another_coroutine())  <span class="comment"># 并发执行</span></span><br></pre></td></tr></table></figure><p>除了 <code>asyncio.run()</code>，还可以手动管理事件循环和任务，使用 <code>loop.create_task()</code> 和 <code>loop.run_until_complete()</code> 来调度任务。</p><ul><li><strong><code>loop.create_task()</code></strong>：用于创建一个协程任务，返回一个任务对象。</li><li><strong><code>loop.run_until_complete()</code></strong>：用于启动事件循环并直到某个任务完成。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">task1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务 1 开始&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务 1 完成&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">task2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务 2 开始&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务 2 完成&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动创建事件循环并执行任务</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">tasks = [loop.create_task(task1()), loop.create_task(task2())]</span><br><span class="line">loop.run_until_complete(asyncio.gather(*tasks))</span><br></pre></td></tr></table></figure><ul><li>在协程中使用 <code>try...except</code> 来捕获异常。</li><li>异常会在协程执行过程中抛出并传播，直到被捕获为止。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">my_coroutine</span>():</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;发生错误&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> my_coroutine()</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;捕获异常: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><ul><li>事件循环会在程序执行完毕后自动关闭，但如果需要提前停止，可以调用 <code>loop.stop()</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始任务&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;结束任务&quot;</span>)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(main())</span><br><span class="line">loop.stop()  <span class="comment"># 关闭事件循环</span></span><br></pre></td></tr></table></figure><h4 id="简单的上手"><a class="markdownIt-Anchor" href="#简单的上手"></a> 简单的上手</h4><p>以下代码请在python3.7及以上运行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#这是一个coroutine</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="comment">#await将asyncio.sleep(delay)这个coroutine转化为task</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="built_in">print</span>(what)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;start at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment">#await将say_after()这个coroutine转化为task，并告知Event Loop</span></span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">2</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finish at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start at 15:46:50</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">finish at 15:46:53</span><br></pre></td></tr></table></figure><p>花费三秒。整个事件过程为：<br />asyncio.run将main()包装为了一个task，然后加入Event Loop。Event Loop中此时只有一个task即main，随即运行main()，控制权交付于main。<br />随后，main将控制权交给say_after，运行say_after(1, “hello”)这个coroutine function得到一个coroutine object（代码并不会在这里阻塞），而await将coroutine object转化为task，放到Event Loop中，并告知需要等待这个sleep，控制权交给sleep。<br />1s后，sleep这个task完成，Event Loop将控制权交还给main，main运行下一个task，重复上述步骤。</p><p>但是这样并没有意义，运行的事件并没有缩短。因此，我们改变策略为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="built_in">print</span>(what)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">task1 = asyncio.create_task(say_after(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>))</span><br><span class="line">task2 = asyncio.create_task(say_after(<span class="number">2</span>, <span class="string">&quot;world&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;start at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finish at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start at 16:23:01</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">finish at 16:23:03</span><br></pre></td></tr></table></figure><p>这次，我们预先包装了两个task，在其放到Event Loop后，Event Loop并不会将控制权交由task，从而实现串行。</p><p>如何返回task的值？<br />最简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">await</span> task1</span><br></pre></td></tr></table></figure><p>使用gather:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">await</span> asyncio.gather(task1, taske)</span><br></pre></td></tr></table></figure><p>gather还有一个好处，可以不需要包装为task再输入，可以直接读取coroutine：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">say_after(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>), </span><br><span class="line">say_after(<span class="number">2</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Python  asyncio机制&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>2025年终总结</title>
    <link href="https://atffang.github.io/2024/12/13/2025%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://atffang.github.io/2024/12/13/2025%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</id>
    <published>2024-12-13T08:00:49.000Z</published>
    <updated>2025-01-12T05:56:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>2025年终总结</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">即使您达不到幸福的境地，您也应该永远记住，您走的路是正确的，千万不要从这条路上离开。</span><br><span class="line">（陀《卡拉马佐夫兄弟》）</span><br></pre></td></tr></table></figure><p>坐在周六早上的咖啡店里，呼啸的冷风使遮阳伞不停浮动。杂七杂八的事情使我突然意识到这一年真的要结束了，即使这一过渡的时刻仅仅具有象征意义，我也想挣扎着写下年终的总结，由此钉下一颗锲子。很抱歉我无法详细的捕捉过去一年发生的所有事情，组成流水账式的记录，也无法坦率的将自己一切想法开诚布公，似乎最能够接受的方法是记录下这一年里发生的一些事。<br><br />四月，度过了自己第二十二个生日。虽然很恬不知耻，但我真的一直以为自己还没有二十岁。印象深刻的是买了个巴斯克蛋糕，却没比巴掌大多少，五个人分着吃了，显的有点局促。<br><br />毕业前，和yu去日本玩了一周。没有跟团，只是自己瞎走，我英语一般，日本人则更差。不过加上些比比划划大概能交流，大体上没有出什么纰漏。在东京落地，坐火车到伊东，往北到镰仓，再继续向北回东京，一路上一直是令人微笑的风光和中学生男男女女，不得不感叹非常值得一去。<br><br />6月19日，在闷热的体育馆听完毕业典礼，又在学衡路上吃了药膳鸡，匆匆忙忙花完红跑车（一家很不错的面包店）储值卡里的钱。回到宿舍将海量的私人物品一半打包，一半丢掉，陆续得知同学离开或即将离开的消息。毕业是2024年最重要的时刻，似乎在重要的时刻总是在做次要的事情。但因为这些次要的时刻，我会永远怀念南京。<br><br />暑假刚开始，买了把吉他。断断续续练了几个月，虽然称不上勤恳但也算坚持下来了，总算能嗯嗯啊啊边弹边唱一点，虽然不好听。<br><br />9月5日我来到上海，对新学校的一切都感到陌生。学校位于闵行区的最南端，再往南就是长江…没有人会对这个选址满意，更何况四周都是叮叮哐哐漫天扬尘的工地。令人宽慰的是我工作的大楼是较新且明亮的，而厕所也值得单独拿出来赞扬。过去的四个月间我并没有做出什么成果，也几乎没有看文章学习，忙碌于一些断断续续的开发工作，代码能力的确提升了一些。唯二骄傲的是给朋友的论文提供了一些帮助，以及用一个通宵换来了数学建模二等奖，至少不用发愁毕业要求了。<br><br />国庆回家，去常熟的养老院看望了卧病在床的爷爷。实际上他已身体僵硬，几乎不能动弹，帮他翻身的时候感觉就像搬弄风干的肉块。我们告别时，眼泪滑落在他因疾病而蜷缩的脸上，衰老的具象表达使我意识到在一个家庭中，成长和衰老是并行的。圣诞节，爷爷的母亲去世了，2024年的最后一个晚上，久病的爷爷突然恶化，进了icu。<br><br />十月中旬，在回南京作报告的前一个礼拜，收到了期刊的拒稿。其实我对结果并没有太多意外，只是希望晚点收到消息，好让我抱有幻想。我在这篇文章上倾注了许多时间和精力，也从中受益匪浅，但其中存在问题之巨使我始终无法说服自己这是一篇正确的文章，拖延回避到现在。<br /><br><br />十一月底，去苏州听了张悬的演唱会。这一年听了好几场live，这是印象最深的一场。也买了不少唱片，自然是花了不少钱，有机会整理一下。<br><br />就写到这吧，总之2024年算是结束了。应该怎么形容？可以说在碌碌无为中度过了人生重要的节点，可以说是平凡中存在伟大的光芒。我不喜欢这些宏大的词汇，但没有具体的例子可以指向我思维中的挣扎和变化。长期以来我一直是一个缺乏驱动力的人，在生活上事业上还是情感上都缺乏驱动力。内驱力的缺乏和偶发的热情交替控制自己，我几乎陷入了永不休止的圆周性思考，回答然后又反驳关于未来的问题。不过这样也好，矛盾人的才是具体的人，只是希望在2025年，一条明晰的道路能够浮现。<br /><br><br />再见！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2025年终总结&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>基于三维网格码LAS点云网格化存储与可视化方案介绍</title>
    <link href="https://atffang.github.io/2024/12/12/%E5%9F%BA%E4%BA%8E%E4%B8%89%E7%BB%B4%E7%BD%91%E6%A0%BC%E7%A0%81LAS%E7%82%B9%E4%BA%91%E7%BD%91%E6%A0%BC%E5%8C%96%E5%AD%98%E5%82%A8%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%A1%88%E4%BB%8B%E7%BB%8D/"/>
    <id>https://atffang.github.io/2024/12/12/%E5%9F%BA%E4%BA%8E%E4%B8%89%E7%BB%B4%E7%BD%91%E6%A0%BC%E7%A0%81LAS%E7%82%B9%E4%BA%91%E7%BD%91%E6%A0%BC%E5%8C%96%E5%AD%98%E5%82%A8%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%A1%88%E4%BB%8B%E7%BB%8D/</id>
    <published>2024-12-12T07:54:35.000Z</published>
    <updated>2024-12-12T08:16:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>三维网格码计算思路分享02。</p><span id="more"></span><p>基于上一篇博文中网格码正反算的方法和代码，写了一些基础控件以完成基于LAS三维点云的网格化计算以及数据预览，具体内容请看下图。</p><img src="https://atffang.github.io/2024/12/12/基于三维网格码LAS点云网格化存储与可视化方案介绍/WorkFlow.png"/>]]></content>
    
    
    <summary type="html">&lt;p&gt;三维网格码计算思路分享02。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>地球空间网格编码正反算实现</title>
    <link href="https://atffang.github.io/2024/12/11/%E5%9C%B0%E7%90%83%E7%A9%BA%E9%97%B4%E7%BD%91%E6%A0%BC%E7%BC%96%E7%A0%81%E6%AD%A3%E5%8F%8D%E7%AE%97%E5%AE%9E%E7%8E%B0/"/>
    <id>https://atffang.github.io/2024/12/11/%E5%9C%B0%E7%90%83%E7%A9%BA%E9%97%B4%E7%BD%91%E6%A0%BC%E7%BC%96%E7%A0%81%E6%AD%A3%E5%8F%8D%E7%AE%97%E5%AE%9E%E7%8E%B0/</id>
    <published>2024-12-11T11:41:43.000Z</published>
    <updated>2024-12-12T08:12:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>三维网格码计算思路分享。</p><span id="more"></span><p>似乎这两年低空经济成为了潮流方向，多了一些政策倾斜。前阵子刚有公司来交流相关事宜，16日华师大又要新成立低空经济研究中心，这两天组里为了这些事情鞍前马后，竟然有些仿佛过年的热闹。我负责的工作是探索其中一小个部分，也是一个非常小众的应用方向：地球空间网格码，该工作目前的理论基础为国标<strong>GBT 40087-2021 地球空间网格编码规则</strong>。<br />地球空间网格基于 GeoSOT(Geographical coordinate global Subdivision based on One-dimensioninteger and Two ton&quot;power)地球剖分模型,将地球空间统一剖分成不同尺度的网格单元,并按统一编码规则进行标识和表达,构建了网格化的地球空间数据组织参考框架。该框架支持地球表面空间和地球立体空间与地理空间信息的聚合,可有效解决物联网、大数据、云计算中海量空间信息在标识和表达上的唯一性、可读性、尺度性、关联性的瓶颈,实现了多源,多尺度数据网格化高效组织、处理和应用,突破了地理空间信息跨行业应用的技术壁垒,推动地球系统科学的发展。<br />具体来说，网格剖分分为经纬度的水平面剖分和高程的垂直剖分。具体过程相对复杂，参见上述国家标准，本文仅分享一些实现步骤。</p><h4 id="1-经纬度网格剖分"><a class="markdownIt-Anchor" href="#1-经纬度网格剖分"></a> 1. 经纬度网格剖分</h4><p>根据国标，经纬度剖分的步骤如下所示：</p><ol><li>将该点经、纬度坐标表示成GB/T16831规定的形式,即A’B’C.D&quot;;</li><li>将该点的坐标按度、分、秒、秒小数部分分别转换为二进制数。即将度|A|由十进制数转换成8 bit 定长二进制数(A)2, 将分B由一进制数转换成6bit定长二进制数(B)2, 将秒C由十进制数转换成6bit定长二进制数©2, 将秒以下数D由一进制数转换成11bit定长二进制数(D)2;</li><li>分别将经、纬度坐标度、分、秒及秒以下二进制数(A)2、(B)2、©2、(D)2直接拼接成31 bit定长二进制数(E)2, 即(E)2=(A)2(B)2©2(D)2, 分别得到两个 31 bit定长数经度(EL)2, 和纬度(EB)2;</li><li>将纬度(EB)2,前置、经度(EL)2后置, 采用莫顿交叉的方式生成62bit的混合代码(F)2, 例如若(EB)2为100111 ,(EL)2为011010, 则(EB)2在前, (EL)2在后的莫顿交叉运算结果为(F)2为 100101101110;</li><li>将二进制混合代码(F)2转成四进制编码(F)4;</li><li>根据待求网格的级别m, 将(F)4中后32-m位四进制的码元去掉得到(F’)4;</li><li>根据经度和纬度,前加上G0、G1、G2或G3即可得到网格代码。</li></ol><p>代码实现步骤如下：<br />定义一个类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WGS84coordinate</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, latitude, longitude, elevation</span>):</span><br><span class="line">        self.latitude = latitude</span><br><span class="line">        self.longitude = longitude</span><br><span class="line">        self.elevation = elevation</span><br></pre></td></tr></table></figure><p>实现步骤1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 将该点经、纬度坐标表示成GB/T16831规定的形式,即A&#x27;B&#x27;C.D&quot;;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decimal2dms</span>(<span class="params">self, decimal</span>):</span><br><span class="line">        degrees = <span class="built_in">int</span>(decimal)</span><br><span class="line">        minutes = <span class="built_in">int</span>((<span class="built_in">abs</span>(decimal) - <span class="built_in">abs</span>(degrees)) * <span class="number">60</span>)</span><br><span class="line">        seconds = (<span class="built_in">abs</span>(decimal) - <span class="built_in">abs</span>(degrees)) * <span class="number">60</span></span><br><span class="line">        seconds = (seconds - minutes) * <span class="number">60</span></span><br><span class="line">        seconds_fractional, seconds_integer = math.modf(seconds)</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">int</span>(degrees), <span class="built_in">int</span>(minutes), <span class="built_in">int</span>(seconds_integer), seconds_fractional]</span><br></pre></td></tr></table></figure><p>实现步骤2,3：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 将该点的坐标按度、分、秒、秒小数部分分别转换为二进制数, 拼为31 bit定长数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dms2bit</span>(<span class="params">self, dms</span>):</span><br><span class="line">        <span class="comment"># dms = [degrees, seconds_fractional, seconds_integer]</span></span><br><span class="line">        degrees, minutes, seconds_integer, seconds_fractional = dms</span><br><span class="line">        <span class="comment"># print(f&quot;度：&#123;degrees&#125;, 分：&#123;minutes&#125;, 秒整数：&#123;seconds_integer&#125;，秒小数：&#123;seconds_fractional&#125;&quot;)</span></span><br><span class="line">        degrees_bin, minutes_bin, seconds_integer_bin = <span class="string">f&quot;<span class="subst">&#123;degrees:08b&#125;</span>&quot;</span>, <span class="string">f&quot;<span class="subst">&#123;minutes:06b&#125;</span>&quot;</span>, <span class="string">f&quot;<span class="subst">&#123;seconds_integer:06b&#125;</span>&quot;</span></span><br><span class="line">        seconds_fractional_scaled = <span class="built_in">int</span>(seconds_fractional * <span class="number">2048</span>)</span><br><span class="line">        seconds_fractional_bin = <span class="string">f&quot;<span class="subst">&#123;seconds_fractional_scaled:011b&#125;</span>&quot;</span></span><br><span class="line">        <span class="comment"># print(f&quot;度：&#123;degrees_bin&#125;, 分：&#123;minutes_bin&#125;, 秒整数：&#123;seconds_integer_bin&#125;，秒小数：&#123;seconds_fractional_bin&#125;&quot;)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([degrees_bin, minutes_bin, seconds_integer_bin, seconds_fractional_bin])</span><br></pre></td></tr></table></figure><p>实现步骤4,5：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3. 将经纬度的编码莫顿交叉,转为四进制编码</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mortoncross</span>(<span class="params">self</span>):</span><br><span class="line">        latbit = self.dms2bit(self.decimal2dms(self.latitude))</span><br><span class="line">        lonbit = self.dms2bit(self.decimal2dms(self.longitude))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(latbit) == <span class="number">31</span> <span class="keyword">and</span> <span class="built_in">len</span>(lonbit) == <span class="number">31</span>, <span class="string">&quot;Both binary strings must be 31 bits long.&quot;</span></span><br><span class="line">        interleaved_bits = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>):</span><br><span class="line">            interleaved_bits.append(latbit[i])</span><br><span class="line">            interleaved_bits.append(lonbit[i])</span><br><span class="line">        bit2 = <span class="string">&#x27;&#x27;</span>.join(interleaved_bits)</span><br><span class="line">        bit4 = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">str</span>(<span class="built_in">int</span>(bit2[i:i+<span class="number">2</span>], <span class="number">2</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(bit2), <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bit4</span><br></pre></td></tr></table></figure><p>实现步骤6,7：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. 根据待求网格的级别m,将(F)中后32-m位四进制的码元去掉得到(F);</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gridcode</span>(<span class="params">self, m</span>):</span><br><span class="line">        bit4 = self.mortoncross()</span><br><span class="line">        gridcode = bit4[:m-<span class="number">32</span>]</span><br><span class="line"></span><br><span class="line">        gridcode = <span class="string">&quot;G0&quot;</span> + gridcode</span><br><span class="line">        <span class="comment"># 高度码实现下面讲。</span></span><br><span class="line">        elevationcode = self.elevationcode(m)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [gridcode, elevationcode]</span><br></pre></td></tr></table></figure><h4 id="2-高程网格剖分"><a class="markdownIt-Anchor" href="#2-高程网格剖分"></a> 2. 高程网格剖分</h4><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>n</mi><mo>=</mo><mfrac><msub><mi>θ</mi><mn>0</mn></msub><mi>θ</mi></mfrac><msub><mo><mi>log</mi><mo>⁡</mo></mo><mrow><mn>1</mn><mo>+</mo><msub><mi>θ</mi><mn>0</mn></msub></mrow></msub><mrow><mo fence="true">(</mo><mfrac><mrow><mi>H</mi><mo>+</mo><msub><mi>r</mi><mn>0</mn></msub></mrow><msub><mi>r</mi><mn>0</mn></msub></mfrac><mo fence="true">)</mo></mrow></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(5)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">n = \frac{\theta_0}{\theta} \log_{1 + \theta_0} \left( \frac{H + r_0}{r_0} \right) \tag{5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.24196799999999996em;"><span style="top:-2.45586em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.02778em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34424em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span><span class="tag"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">5</span></span><span class="mord">)</span></span></span></span></span></span></p><p>其中：</p><ul><li>( n ) —— 从地面向上（或向下）数第n层立体网格，n为整数，地面以上n大于等于0，地面以下 n &lt; 0；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\theta_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>—— 初始划分范围定义的基础网格（1°网格）对应的经（纬）跨度差，单位为弧度（rad）<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>0</mn></msub><mo>=</mo><mfrac><mi>π</mi><mn>180</mn></mfrac></mrow><annotation encoding="application/x-tex">\theta_0 = \frac{\pi}{180}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">8</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> —— 该网格对应的经（纬）跨度差，单位为弧度（rad）；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">r_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> —— 地球长半轴，单位为米（m），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mn>0</mn></msub><mo>=</mo><mn>6</mn><mtext> </mtext><mn>378</mn><mtext> </mtext><mn>137</mn></mrow><annotation encoding="application/x-tex">r_0 = 6\,378\,137</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">7</span><span class="mord">8</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mord">7</span></span></span></span>；<br />去掉层数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 高位的 0 形成的编码即为高度域编码。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算高度的网格码</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">elevationcode</span>(<span class="params">self, m</span>):</span><br><span class="line">        theta_0 = math.pi / <span class="number">180</span></span><br><span class="line">        theta = GridSpanlist[m-<span class="number">1</span>] * math.pi / <span class="number">180</span></span><br><span class="line">        H = self.elevation</span><br><span class="line">        r_0 = <span class="number">6378137</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 计算公式</span></span><br><span class="line">        n = (theta_0 / theta) * math.log((H + r_0) / r_0, (<span class="number">1</span> + theta_0))</span><br><span class="line">        n = math.floor(n)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            n = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">str</span>(<span class="built_in">bin</span>(n)[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(n) &lt; m:</span><br><span class="line">            n = <span class="string">&#x27;0&#x27;</span> * (m - <span class="built_in">len</span>(n)) + n</span><br><span class="line">        n = <span class="string">&quot;H&quot;</span> + n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure><h4 id="3-网格码反算"><a class="markdownIt-Anchor" href="#3-网格码反算"></a> 3. 网格码反算</h4><p>这一部分的具体求解国标并没有提及，因此只能尝试自行求解，代码准确性为止，仅供参考：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GridCode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, grid_code, elevation_code, m</span>):</span><br><span class="line">        self.grid_code = grid_code</span><br><span class="line">        self.elevation_code = elevation_code</span><br><span class="line">        self.m = m</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;格网编码：<span class="subst">&#123;self.grid_code, self.elevation_code&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">degridcode_bit2dms</span>(<span class="params">self, binary_str</span>):</span><br><span class="line">        degrees_bin = binary_str[<span class="number">0</span>:<span class="number">8</span>]    <span class="comment"># 前8位是度</span></span><br><span class="line">        minutes_bin = binary_str[<span class="number">8</span>:<span class="number">14</span>]   <span class="comment"># 接下来的6位是分</span></span><br><span class="line">        seconds_integer_bin = binary_str[<span class="number">14</span>:<span class="number">20</span>]  <span class="comment"># 接下来的6位是秒的整数部分</span></span><br><span class="line">        seconds_fractional_bin = binary_str[<span class="number">20</span>:<span class="number">31</span>]  <span class="comment"># 最后的11位是秒的小数部分</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将每个二进制子串转换回整数</span></span><br><span class="line">        degrees = <span class="built_in">int</span>(degrees_bin, <span class="number">2</span>)</span><br><span class="line">        minutes = <span class="built_in">int</span>(minutes_bin, <span class="number">2</span>)</span><br><span class="line">        seconds_integer = <span class="built_in">int</span>(seconds_integer_bin, <span class="number">2</span>)</span><br><span class="line">        seconds_fractional_scaled = <span class="built_in">int</span>(seconds_fractional_bin, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将秒的小数部分恢复为原来的小数值</span></span><br><span class="line">        seconds_fractional = seconds_fractional_scaled / <span class="number">2048</span></span><br><span class="line">        total_seconds = seconds_integer + seconds_fractional</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将秒数转换为分的部分（秒/60）</span></span><br><span class="line">        total_minutes = minutes + total_seconds / <span class="number">60</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将分数转换为度的部分（分/60）</span></span><br><span class="line">        decimal = <span class="built_in">abs</span>(degrees) + total_minutes / <span class="number">60</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> decimal</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 编码反算</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">degridcode</span>(<span class="params">self</span>):</span><br><span class="line">        gridcode = self.grid_code</span><br><span class="line">        gridcode = gridcode[<span class="number">2</span>:]</span><br><span class="line">        gridcode = gridcode.ljust(<span class="number">31</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        bit2 = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">bin</span>(<span class="built_in">int</span>(c, <span class="number">4</span>))[<span class="number">2</span>:].zfill(<span class="number">2</span>) <span class="keyword">for</span> c <span class="keyword">in</span> gridcode)</span><br><span class="line"></span><br><span class="line">        latbit = []</span><br><span class="line">        lonbit = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">32</span>):</span><br><span class="line">            latbit.append(bit2[i * <span class="number">2</span> - <span class="number">2</span>])</span><br><span class="line">            lonbit.append(bit2[i * <span class="number">2</span> - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        latcode = <span class="string">&#x27;&#x27;</span>.join(latbit)</span><br><span class="line">        loncode = <span class="string">&#x27;&#x27;</span>.join(lonbit)</span><br><span class="line"></span><br><span class="line">        lat = self.degridcode_bit2dms(latcode)</span><br><span class="line">        lon = self.degridcode_bit2dms(loncode)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> lat, lon</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 高度码反算</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deelevationcode</span>(<span class="params">self</span>):</span><br><span class="line">        n_binary, m = self.elevation_code, self.m</span><br><span class="line"></span><br><span class="line">        theta_0 = math.pi / <span class="number">180</span></span><br><span class="line">        theta = GridSpanlist[m-<span class="number">1</span>] * math.pi / <span class="number">180</span></span><br><span class="line">        r_0 = <span class="number">6378137</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 高度码反算</span></span><br><span class="line">        n_binary = n_binary[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将二进制的 n 转换回整数</span></span><br><span class="line">        n = <span class="built_in">int</span>(n_binary, <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 根据公式反向解码，恢复 H</span></span><br><span class="line">        H = r_0 * (math.exp((n * theta) / theta_0 * math.log(<span class="number">1</span> + theta_0)) - <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> H</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 整体反算：</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params">self</span>):</span><br><span class="line">        lat, lon = self.degridcode()</span><br><span class="line">        H = self.deelevationcode()</span><br><span class="line">        <span class="keyword">return</span> lat, lon, H</span><br></pre></td></tr></table></figure><p>这样做的目的是为了得到网格码的代表性坐标，但是这个坐标到底具体代表了网格码六面体的哪个位置，不得而知。本文仅代表个人的一些探索，代码并不一定正确。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;三维网格码计算思路分享。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>DTDC2024</title>
    <link href="https://atffang.github.io/2024/11/28/DTDC2024/"/>
    <id>https://atffang.github.io/2024/11/28/DTDC2024/</id>
    <published>2024-11-28T14:42:00.000Z</published>
    <updated>2024-11-28T14:52:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>华东师范大学李响老师课题组参加DTDC2024会议。</p><span id="more"></span><p>感谢老师！<br /><img src="https://atffang.github.io/2024/11/28/DTDC2024/DTDC2024_1.jpg"/></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;华东师范大学李响老师课题组参加DTDC2024会议。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>2024中国研究生数学建模竞赛</title>
    <link href="https://atffang.github.io/2024/11/25/2024%E4%B8%AD%E5%9B%BD%E7%A0%94%E7%A9%B6%E7%94%9F%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AB%9E%E8%B5%9B/"/>
    <id>https://atffang.github.io/2024/11/25/2024%E4%B8%AD%E5%9B%BD%E7%A0%94%E7%A9%B6%E7%94%9F%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AB%9E%E8%B5%9B/</id>
    <published>2024-11-25T04:44:51.000Z</published>
    <updated>2024-11-25T05:36:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>D题大数据驱动的地理综合问题国二。</p><span id="more"></span><p>文档全文请在PC端查看。<br /><strong>D题大数据驱动的地理综合问题</strong>，题干如下：</p><ol><li><p>在众多描述地理环境的变量中，一些简单的指标背后蕴藏了深厚的内涵，对人类的生存发展具有重大深远的影响，如大气中二氧化碳的浓度、全球年平均气温等。降水量是一个连续变化的变量，而土地利用/土地覆被类型则是一个存在突变和离散分布的变量。同时，它们都具有时空分布不均匀的特征。请从附件数据中选取相关数据集，为这两个变量分别构建一套描述性统计方法，用1<sub>3个较为简洁的统计指标或统计图表，对这两个变量在1990</sub>2020年间中国范围内的时空演化特征进行描述和总结。</p></li><li><p>近年来，以暴雨为代表的极端天气事件对人类的生产生活造成了越来越难以忽视的影响。请结合附件中所给的数据，建立数学模型，说明地形-气候相互作用在极端天气形成过程中的作用。</p></li><li><p>降雨、地形和土地利用对于暴雨等极端天气灾害的形成都具有不可忽视的影响。这其中，降雨的时空变异性和不可控性都最强；土地利用作为自然条件和人类活动的综合结果，虽然也随时空演化，但具有一定可控性；地形是最为稳定、不易改变的因素。请考虑第2问所反映的从“暴雨”到“灾害”中上述三方面因素的角色及其交互作用，确定暴雨成灾的临界条件；并结合第1问中降雨量和土地利用/土地覆被变化的历史时空演化特征，对2025~2035年间中国境内应对暴雨灾害能力最为脆弱的地区进行预测。请以地图的形式呈现你们的预测结果。</p></li><li><p>在中国级别的尺度上，描述自然地理特征的地形可以概括为“三级阶梯”，而降水中具有标志性意义的“800mm等降水量线”则与区分我国南北方的“秦岭—淮河”一线大体重合；描述人文地理特征的人口分布及其社会经济活动总量等指标，则被由连接黑龙江黑河与云南腾冲的“胡焕庸线”清晰地划分成东密西疏的两部分。那么，对于自然地理和人文地理交汇点的土地利用/土地覆被情况，结合其在前三问中描述、估计和预测任务中的“特性”，利用地理大数据，建立相应的数学模型，对数据进行简化和综合，描述中国土地利用变化的特征与结构。从准确性和有用性两个方面解释验证你们的总结。</p></li></ol><p>下面为解题文档，请在PC端查看：</p><div class="pdfobject-container" data-target="https://atffang.github.io/2024/11/25/2024中国研究生数学建模竞赛/D24102690011.pdf" data-height="500px"></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;D题大数据驱动的地理综合问题国二。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>IWGMS2024</title>
    <link href="https://atffang.github.io/2024/11/25/IWGMS2024/"/>
    <id>https://atffang.github.io/2024/11/25/IWGMS2024/</id>
    <published>2024-11-25T03:00:56.000Z</published>
    <updated>2024-11-25T04:42:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>mark一下自己的第一次汇报<sup>-</sup></p><span id="more"></span><p>感谢张海平老师给我这次机会，在3rd InternationalWorkshop on Geographic Modeling and Simulation做了人生第一次汇报，虽然没什么人听，但也怪紧张的。本次会议主题为Modeling and Simulation for a Sustainable World，主办单位是南师大。<br />秋天的南京真的好美，和闵行的肃杀相比，我越来越怀念南师大随园绿色的草坪与金色的树。<br />张海平老师负责的分会场Title为Process-oriented Geographical Analysis and Simulation，组里的汇报包括：<br />Haiping Zhang; Socio-Geographic Process Model: Theory, Methods, andApplications<br />Tianyao Fang; Spatiotemporal process simulation model for cultural transmission and acculturation<br />Nuozhou Shen; Multiscale Process Simulation for Infectious Disease Transmission<br />Yushu Xu; Intercity human dynamics during holiday weeks throughout theCovid-19 pandemic: A perspective of hybrid physical-virtual space<br />Xingxing Zhou; Spatiotemporally contiguous clustering of origin-destination flowsweighted by interaction strength to reveal interregional association pattems<br />Jinzhao Guo; Measuring spatial association in geographical processes with spatial time-series data<br /><img src="https://atffang.github.io/2024/11/25/IWGMS2024/IWGM2024_1.jpg" width="300"/><br />还见到了好久没见的朋友们。</p><img src="https://atffang.github.io/2024/11/25/IWGMS2024/IWGM2024_2.jpg" width="200"/><img src="https://atffang.github.io/2024/11/25/IWGMS2024/IWGM2024_3.jpg" width="300"/>]]></content>
    
    
    <summary type="html">&lt;p&gt;mark一下自己的第一次汇报&lt;sup&gt;-&lt;/sup&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>百度指数爬取02 年均值爬取</title>
    <link href="https://atffang.github.io/2024/10/29/%E7%99%BE%E5%BA%A6%E6%8C%87%E6%95%B0%E7%88%AC%E5%8F%9602-%E5%B9%B4%E5%9D%87%E5%80%BC%E7%88%AC%E5%8F%96/"/>
    <id>https://atffang.github.io/2024/10/29/%E7%99%BE%E5%BA%A6%E6%8C%87%E6%95%B0%E7%88%AC%E5%8F%9602-%E5%B9%B4%E5%9D%87%E5%80%BC%E7%88%AC%E5%8F%96/</id>
    <published>2024-10-29T12:26:15.000Z</published>
    <updated>2024-10-29T12:47:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>程序设计需求：爬取百度指数目标城市的年均值。</p><span id="more"></span><p>  该程序使用抓包方法获取百度指数对应搜索目标的年均值数据。通过观察百度指数网页的api调用情况，百度指数像后端请求的api构成应当为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://index.baidu.com/api/SearchApi/index?area=&#123;area&#125;&amp;word=&#123;words&#125;&amp;startDate=&#123;startDate&#125;&amp;endDate=&#123;endDate&#125;</span><br></pre></td></tr></table></figure><p>其中，area为搜索发起地，words为搜索关键字，至多包含5个，startDate和endDate分别为起始时间与结束时间。<br />这些变量的构建方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">words = [[&#123;<span class="string">&quot;name&quot;</span>: key, <span class="string">&quot;wordType&quot;</span>: <span class="number">1</span>&#125;] <span class="keyword">for</span> key <span class="keyword">in</span> keys]</span><br><span class="line"></span><br><span class="line">words = <span class="built_in">str</span>(words).replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;&#x27;&quot;</span>, <span class="string">&quot;\&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">startDate = <span class="string">f&quot;<span class="subst">&#123;year&#125;</span>-01-01&quot;</span></span><br><span class="line"></span><br><span class="line">endDate = <span class="string">f&quot;<span class="subst">&#123;year&#125;</span>-12-31&quot;</span></span><br></pre></td></tr></table></figure><p>其中，keys是搜索的各对象。</p><p>通过request构建请求头，并使用get方法请求数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;Connection&quot;</span>: <span class="string">&quot;keep-alive&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;application/json, text/plain, */*&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;Sec-Fetch-Site&quot;</span>: <span class="string">&quot;same-origin&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;Sec-Fetch-Mode&quot;</span>: <span class="string">&quot;cors&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;Sec-Fetch-Dest&quot;</span>: <span class="string">&quot;empty&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;Cipher-Text&quot;</span>: <span class="string">&quot;1698156005330_1698238860769_ZPrC2QTaXriysBT+5sgXcnbTX3/lW65av4zgu9uR1usPy82bArEg4m9deebXm7/O5g6QWhRxEd9/r/hqHad2WnVFVVWybHPFg3YZUUCKMTIYFeSUIn23C6HdTT1SI8mxsG5mhO4X9nnD6NGI8hF8L5/G+a5cxq+b21PADOpt/XB5eu/pWxNdwfa12krVNuYI1E8uHQ7TFIYjCzLX9MoJzPU6prjkgJtbi3v0X7WGKDJw9hwnd5Op4muW0vWKMuo7pbxUNfEW8wPRmSQjIgW0z5p7GjNpsg98rc3FtHpuhG5JFU0kZ6tHgU8+j6ekZW7+JljdyHUMwEoBOh131bGl+oIHR8vw8Ijtg8UXr0xZqcZbMEagEBzWiiKkEAfibCui59hltAgW5LG8IOtBDqp8RJkbK+IL5GcFkNaXaZfNMpI=&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;Referer&quot;</span>: <span class="string">&quot;https://index.baidu.com/v2/main/index.html&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;Accept-Language&quot;</span>: <span class="string">&quot;zh-CN,zh;q=0.9&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;Cookie&#x27;</span>: cookie&#125;</span><br><span class="line"></span><br><span class="line">    res = requests.get(url, headers=headers)</span><br><span class="line"></span><br><span class="line">    res_json = res.json()</span><br></pre></td></tr></table></figure><p>返回的年均值与请求关键词如下两个列表所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">retuen_keys_num = <span class="built_in">len</span>(res_json[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;generalRatio&#x27;</span>])</span><br><span class="line"></span><br><span class="line">avg_list = [res_json[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;generalRatio&#x27;</span>][i][<span class="string">&#x27;all&#x27;</span>][<span class="string">&#x27;avg&#x27;</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(retuen_keys_num)]</span><br><span class="line"></span><br><span class="line">destination_list = [res_json[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;generalRatio&#x27;</span>][i][<span class="string">&#x27;word&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;name&#x27;</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(retuen_keys_num)]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;程序设计需求：爬取百度指数目标城市的年均值。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>flask提供python脚本api查询数据库</title>
    <link href="https://atffang.github.io/2023/12/28/flask%E6%8F%90%E4%BE%9Bpython%E8%84%9A%E6%9C%ACapi%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://atffang.github.io/2023/12/28/flask%E6%8F%90%E4%BE%9Bpython%E8%84%9A%E6%9C%ACapi%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2023-12-28T02:55:33.000Z</published>
    <updated>2023-12-28T07:18:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>利用python的Flask库将脚本打包成api，实现通过url实现前端sql查询，访问数据库</p><span id="more"></span><p>起因是《GIS综合实验》这门课要求一个大作业，其中一项为WebGIS开发。对于接受了过多地学原理性课程教学而疏于计算机水平训练的学生来说，即使简单的Web开发也是一件比较头疼的事情，况且为了必须使用一个国产平台，在众多服务与文档中饶了很久的圈子。原本以为，将postgis数据库部署到平台上后，通过REST请求或者是WFS协议能够方便地实现增删改查，至少GET数据不是一件难事，但实现与设想相去甚远。和工作人员交流才知道，该平台上传的postgis数据库一般作为一个数据源为发布文件型的工作空间服务，直接查询该数据库是非常规的操作。这让我非常郁闷，原本实现的逻辑中包括读取数据库中几十万个点数据，通过deck.gl为mapbox开发的高效率点图层渲染到底图上，以及使用postgis特有的一些空间查询语句等等，如果不能直接访问数据库，那么这些设计好的逻辑、代码都要修改甚至报废。无奈之下，只能自己上手连接后端数据库，下面是实现的过程。<br />不知道答辩的时候能不能耍小聪明，堂而皇之的告诉评委这是用该国产平台实现的。<br />Flask 是一个轻量级的 Python Web 框架，用于构建 Web 应用程序，使用 Flask 可以通过定义路由来映射 URL 到相应的处理函数。这使得开发者能够轻松地构建 Web 应用的不同页面和功能（GPT语）首先在后端代码定义一个类Database，因为我的需求中暂时不需要对数据库的增删改，因此仅在该类中定义基础的打开关闭与查询功能。<a href="http://xn--api-th2el20d.py">创建api.py</a>，引入依赖库并进行基础定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> psql.postsqlConnect <span class="keyword">import</span> Database</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> flask_cors <span class="keyword">import</span> CORS</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">CORS(app, supports_credentials=<span class="literal">True</span>)</span><br><span class="line">app.config[<span class="string">&#x27;JSON_AS_ASCII&#x27;</span>] = <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>其中Database是我预先写好的数据库查询类，<code>CORS(app, supports_credentials=True)</code>是为了保障跨端口调用时不出现浏览器安全协议问题，而<code>app.config['JSON_AS_ASCII'] = False</code>用于约束查询返回的json不以二进制的形式出现。<br />接下来我们定义一个sql查询，在url中加入m_id, area_id, rating三个约束字段，以查询数据库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/api/sqlSearch&#x27;</span>, methods = [<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sqlSearch</span>():</span><br><span class="line">    m_id = request.args.get(<span class="string">&#x27;m_id&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    area_id = request.args.get(<span class="string">&#x27;area_id&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    rating = request.args.get(<span class="string">&#x27;rating&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    DB = Database(name=<span class="string">&quot;restaurant&quot;</span>, username=<span class="string">&quot;postgres&quot;</span>, password=<span class="string">&quot;20020405&quot;</span>, host=<span class="string">&quot;10.20.72.101&quot;</span>, port=<span class="string">&quot;5432&quot;</span>)</span><br><span class="line">    DB.connect()</span><br><span class="line"></span><br><span class="line">    baseSql = <span class="string">&quot;SELECT id, ST_X(geom) AS lon, ST_Y(geom) AS lat FROM public.shanghai_restaurants&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> m_id != <span class="string">&quot;&quot;</span> <span class="keyword">or</span> area_id != <span class="string">&quot;&quot;</span> <span class="keyword">or</span> rating != <span class="string">&quot;&quot;</span>:</span><br><span class="line">        m_idSql, area_idSql, ratingSql = <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> m_id != <span class="string">&quot;&quot;</span>:</span><br><span class="line">            m_idSql = <span class="string">&quot;m_id = &quot;</span> + <span class="built_in">str</span>(m_id)</span><br><span class="line">        <span class="keyword">if</span> area_id != <span class="string">&quot;&quot;</span>:</span><br><span class="line">            area_idSql = <span class="string">&quot;area_id = &quot;</span> + <span class="built_in">str</span>(area_id)</span><br><span class="line">        <span class="keyword">if</span> rating != <span class="string">&quot;&quot;</span>:</span><br><span class="line">            <span class="keyword">match</span> = re.<span class="keyword">match</span>(<span class="string">r&quot;\((\d+),(\d+)\)&quot;</span>, rating)</span><br><span class="line">            a, b = <span class="built_in">map</span>(<span class="built_in">str</span>, <span class="keyword">match</span>.groups())</span><br><span class="line">            ratingSql = <span class="string">f&quot;rating BETWEEN <span class="subst">&#123;a&#125;</span> AND <span class="subst">&#123;b&#125;</span>&quot;</span></span><br><span class="line">            </span><br><span class="line">        whereSql = <span class="string">&quot; WHERE &quot;</span>+<span class="string">&#x27; AND &#x27;</span>.join(s <span class="keyword">for</span> s <span class="keyword">in</span> [m_idSql, area_idSql, ratingSql] <span class="keyword">if</span> s)</span><br><span class="line">        finalSql = baseSql + whereSql</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        finalSql = baseSql</span><br><span class="line">        </span><br><span class="line">    json_data = DB.select(finalSql)</span><br><span class="line">    DB.close()</span><br><span class="line">    <span class="keyword">return</span> json_data</span><br></pre></td></tr></table></figure><p>由于我的需求仅限于查找，因此在定义时设置的是 methods = [‘GET’]，如果需要增删改，那么请使用POST请求。对于这个功能，我们定义的基础的url是端口+/api/sqlSearch，其中api是我这个python脚本的文件名，sqlSearch是我接下来要定义的函数名。<br />在sqlSearch函数中，首先通过request.args.get方法获取url中的参数，随后连接数据库，将这些参数解析为sql语句并提交查找，返回json文件。<br />运行该程序，会返回给你一个端口，例如我的终端提示为：<code>Running on http://127.0.0.1:5000</code>。在这个url后面再加上<code>/api/sqlSearch</code>，浏览器就会返回数据库所有记录的json。在<code>Running on http://127.0.0.1:5000/api/sqlSearch</code>后用<code>?</code>（英文）拼接查询语句，可以实现sql查询，其固定句式为<code>?参数一=x&amp;参数二=y</code>，当然，不写某个参数（数据库里的字段）的查询条件也可以，这完全取决于上面的查询函数中是如何定义的，<code>parameter = request.args.get('参数一','')</code>获取的就是上述url中的x，一般来说，可以设计为当x非空时，加入sql查询中的WHERE语句。<br />运行程序开启服务后，在web中输入url：<code>http://127.0.0.1:5000/api/sqlSearch?m_id=116&amp;area_id=3&amp;rating=(3,3)</code>,返回的页面如下所示：<br /><img align="center" width=100% src="https://s2.loli.net/2023/12/28/zaARsTgGNEPtIOc.png" style="margin-right: 20px;margin-top: 10px;margin-buttom:20px;"><br />在JavaScript中，只需解析用户输入的参数为url，就可渐变快速地查询访问数据库，使用deck.gl渲染在底图上：<br /><img width=50% src="https://s2.loli.net/2023/12/28/nefamgV3FP5xdqL.png" style="margin-right: 20px;margin-top: 10px;margin-buttom:20px;"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;利用python的Flask库将脚本打包成api，实现通过url实现前端sql查询，访问数据库&lt;/p&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
  <entry>
    <title>python并行运算</title>
    <link href="https://atffang.github.io/2023/11/12/python%E5%B9%B6%E8%A1%8C%E8%BF%90%E7%AE%97/"/>
    <id>https://atffang.github.io/2023/11/12/python%E5%B9%B6%E8%A1%8C%E8%BF%90%E7%AE%97/</id>
    <published>2023-11-12T05:33:09.000Z</published>
    <updated>2023-11-12T06:38:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用multiprocessing函数在python中实现并行运算。</p><span id="more"></span><p>python中自带的 <a href="https://docs.python.org/zh-cn/3/library/multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code>multiprocessing</code></a> 包同时提供了本地和远程并发操作，允许程序员充分利用设备上的多个处理器。本文主要介绍之中的Pool对象，它提供了一种快捷的方法，赋予函数并行化处理一系列输入值的能力，可以将输入数据分配给不同进程处理（数据并行）。在官方文档中的例子是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> Pool(<span class="number">5</span>) <span class="keyword">as</span> p:</span><br><span class="line">        <span class="built_in">print</span>(p.<span class="built_in">map</span>(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br></pre></td></tr></table></figure><p>本文将简单演示并行运算在处理数据中带来的性能提升。我将使用Pool函数实现并行遍历一个包含一百万条数据的csv文件并进行一些简单的运算，以对比我的设备在不同的进程数量下处理数据的速度。<br />代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool  </span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_csv_chunk</span>(<span class="params">file_chunk</span>):  </span><br><span class="line">    df0 = pd.read_csv(file_chunk)  </span><br><span class="line">    <span class="keyword">return</span> df0  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 简单读取运算一下数据  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">df0</span>):  </span><br><span class="line">    result_sum = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> index, row <span class="keyword">in</span> df0.iterrows():  </span><br><span class="line">        result_sum += row[<span class="number">5</span>] * row[<span class="number">0</span>]  </span><br><span class="line">    <span class="keyword">return</span> result_sum  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 并行运算  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deal_csv_parallel</span>(<span class="params">df0, times</span>):  </span><br><span class="line">    result_sum = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">if</span> times == <span class="number">0</span>:  </span><br><span class="line">        <span class="keyword">for</span> index, row <span class="keyword">in</span> df0.iterrows():  </span><br><span class="line">            result_sum += row[<span class="number">5</span>] * row[<span class="number">0</span>]  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> result_sum  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> times != <span class="number">0</span>:  </span><br><span class="line">        chunk_size = <span class="built_in">len</span>(df0) // times  </span><br><span class="line">        chunks = [df[i:i + chunk_size] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(df), chunk_size)]  </span><br><span class="line">        <span class="keyword">with</span> Pool(times) <span class="keyword">as</span> p:  </span><br><span class="line">            results = p.<span class="built_in">map</span>(f, chunks)  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(results)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">      </span><br><span class="line">    <span class="comment"># 文件路径  </span></span><br><span class="line">    file_path = <span class="string">&#x27;output.csv&#x27;</span>  </span><br><span class="line">  </span><br><span class="line">    df = read_csv_chunk(file_path)  </span><br><span class="line">  </span><br><span class="line">    Pool_size = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>)]  </span><br><span class="line">    run_time = []  </span><br><span class="line">    run_time_multiple = []  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> Pool_size:  </span><br><span class="line">        start_time = time.time()  </span><br><span class="line">  </span><br><span class="line">        deal_csv_parallel(df, i)  </span><br><span class="line">  </span><br><span class="line">        end_time = time.time()  </span><br><span class="line">  </span><br><span class="line">        t = end_time - start_time  </span><br><span class="line">  </span><br><span class="line">        run_time.append(t)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> run_time:  </span><br><span class="line">        run_time_multiple.append(<span class="string">f&quot;<span class="subst">&#123;run_time[<span class="number">0</span>]/item*<span class="number">100</span>&#125;</span>%&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">    data = &#123;<span class="string">&#x27;并行数&#x27;</span>: Pool_size, <span class="string">&#x27;运行时间&#x27;</span>: run_time, <span class="string">&#x27;效率比&#x27;</span>: run_time_multiple&#125;   </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">print</span>(df_out)</span><br></pre></td></tr></table></figure><p>其中，<code>chunks = [df[i:i + chunk_size] for i in range(0, len(df), chunk_size)]</code>负责将表格拆分成和进程数相等的几个部分，随后通用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> Pool(times) <span class="keyword">as</span> p:  </span><br><span class="line">    results = p.<span class="built_in">map</span>(f, chunks) </span><br></pre></td></tr></table></figure><p>进行并行运算。代码运行的结果为：</p><table><thead><tr><th style="text-align:center">进程数</th><th style="text-align:center">运行时间</th><th style="text-align:center">效率比</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">30.298478</td><td style="text-align:center">100.0%</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">30.566270</td><td style="text-align:center">99.12389630201749%</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">15.768265</td><td style="text-align:center">192.14846418175512%</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">10.124307</td><td style="text-align:center">299.26471386481404%</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">7.879102</td><td style="text-align:center">384.5422643570513%</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">7.495068</td><td style="text-align:center">404.24552340989857%</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">6.015692</td><td style="text-align:center">503.65742377427705%</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">5.712452</td><td style="text-align:center">530.3935987002207%</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">5.440717</td><td style="text-align:center">556.8838978332274%</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">5.770803</td><td style="text-align:center">525.030563530312%</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">5.318123</td><td style="text-align:center">569.7212889333297%</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">5.124458</td><td style="text-align:center">591.2523645483335%</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">5.040725</td><td style="text-align:center">601.0737603013101%</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">5.147555</td><td style="text-align:center">588.5993925729343%</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">4.993004</td><td style="text-align:center">606.8185840078334%</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">5.116237</td><td style="text-align:center">592.2023776071396%</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">5.017882</td><td style="text-align:center">603.8101404027773%</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">5.150956</td><td style="text-align:center">588.2107286306572%</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">5.068639</td><td style="text-align:center">597.7636351261095%</td></tr><tr><td style="text-align:center">19</td><td style="text-align:center">4.979399</td><td style="text-align:center">608.4766411595016%</td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">5.103571</td><td style="text-align:center">593.6720989778112%</td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">5.076162</td><td style="text-align:center">596.8777272425182%</td></tr><tr><td style="text-align:center">22</td><td style="text-align:center">5.401071</td><td style="text-align:center">560.9716614488367%</td></tr><tr><td style="text-align:center">23</td><td style="text-align:center">5.360952</td><td style="text-align:center">565.1697690343107%</td></tr><tr><td style="text-align:center">24</td><td style="text-align:center">5.318242</td><td style="text-align:center">569.7085696153763%</td></tr><tr><td style="text-align:center">25</td><td style="text-align:center">5.748274</td><td style="text-align:center">527.088308186721%</td></tr></tbody></table><div style="width: 90%;margin: 0 auto">    <canvas id="chart6683" style="height: 300px"></canvas></div><script src="https://cdn.jsdelivr.net/npm/chart.js@2.9.3/dist/Chart.min.js"></script><script type="text/javascript">    var ctx = document.getElementById('chart6683').getContext('2d');    var options =       {      type: 'line',      data: {      labels: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25'],      datasets: [{          label: '运行速度',          borderColor: 'rgb(255, 99, 132)',          data: [30.298478, 30.566270, 15.768265, 10.124307, 7.879102, 7.495068, 6.015692, 5.712452, 5.440717, 5.770803, 5.318123, 5.124458, 5.040725, 5.147555, 4.993004, 5.116237, 5.017882, 5.150956, 5.068639, 4.979399, 5.103571, 5.076162, 5.401071, 5.360952, 5.318242, 5.748274]          }]      },      options: {          responsive: true,          title: {          display: true,          text: '进程数与运行速度'          }      }  }  ;    new Chart(ctx, options);</script><p>可以看到，在进程数大于对于4后程序运行速度下降开始收敛，并维持在一定水平。速度最低点较非并行运算节约了5/6的时间，可见并行预算对这种背景下的数据处理带来的收益之大。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用multiprocessing函数在python中实现并行运算。&lt;/p&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
  <entry>
    <title>树莓派服务器搭建01：一个内网访问的云服务器</title>
    <link href="https://atffang.github.io/2023/11/11/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA01%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%86%85%E7%BD%91%E8%AE%BF%E9%97%AE%E7%9A%84%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://atffang.github.io/2023/11/11/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA01%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%86%85%E7%BD%91%E8%AE%BF%E9%97%AE%E7%9A%84%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2023-11-11T02:04:14.000Z</published>
    <updated>2023-11-12T03:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>瞎捣鼓:)</p><span id="more"></span><p>上个月一时兴起，购入了一块树莓派4B。</p><p><img src=https://s2.loli.net/2023/11/12/4XA5YE8GZDuNbOg.png  width=60%/> 到手后烧录了带GUI的Raspberry Pi系统，换源、安装了一些依赖并外接了键鼠小屏幕后，就因为面试的事搁置了。直到现在才想到将它好好利用起来。搁置的这段时间只零零散散部署过一些爬虫，但是由于部署程序时，我只通过filezilla完成主机与树莓派服务器之间的数据传输，再把数据传给实验室其他人，过程略显繁琐。因此，这次我打算直接将树莓派服务器作为实验室内网下的云存储平台使用。<br />在修改前，首先要解决一个问题：在同一局域网下，我的主机无法ping通树莓派服务器，但是在同一手机热点下确可以。解决方法是在主机(Windows)中修改防火墙高级允许入站、出站规则中的<strong>文件和打印机共享</strong></p><p><img src=https://s2.loli.net/2023/11/12/DU1ShQJ6c7vky89.png  width=60% align="center"/>这个问题煞是令我费解。因为在手机热点下电脑可以ping通服务器，但在WiFi下却需要修改防火墙设置，不知道背后的逻辑是什么。<br />确认机器间的连接通畅后，就可以开始设置树莓派了。为了安全起见，我首先在root下新建了一个账号，将共享的文件置于该账号下。首先更新一下源：<br /><code>sudo apt-get update</code><br />安装samba程序。Samba(Server Message Block)是一个开源的软件套件，用于实现基于SMB/CIFS协议的文件和打印服务，使得不同操作系统的计算机能够在局域网上共享文件和打印机。<br /><code>sudo apt-get install samba samba-common-bin</code><br />随后修改配置文件：<br /><code>sudo vi /etc/samba/smb.conf</code><br />在share definitions一章将read only = yes改为=no，使得其他用户得以修改共享的文件。保存编辑并重启samba服务：<br /><code>sudo /etc/init.d/smbd restart</code><br />添加默认用户：<br /><code>sudo smbpasswd -a 刚刚新建的用户名</code><br />在文件资源管理器中打开地址：<code>\\树莓派ip地址\用户名</code>，按要求输入账号密码（就是刚才创建与添加的），即可访问：<br /><img src=https://s2.loli.net/2023/11/12/hwjHTnEaMG2UQcm.png  width=60%/></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;瞎捣鼓:)&lt;/p&gt;</summary>
    
    
    
    <category term="或许用得到的tips" scheme="https://atffang.github.io/categories/%E6%88%96%E8%AE%B8%E7%94%A8%E5%BE%97%E5%88%B0%E7%9A%84tips/"/>
    
    
  </entry>
  
  <entry>
    <title>百度指数爬取</title>
    <link href="https://atffang.github.io/2023/09/11/%E7%99%BE%E5%BA%A6%E6%8C%87%E6%95%B0%E7%88%AC%E5%8F%96%E2%80%94%E2%80%94%E4%B8%8D%E5%90%8C%E5%9F%8E%E5%B8%82%E5%AF%B9%E4%BA%8E%E5%90%84%E7%B1%BB%E5%85%B3%E9%94%AE%E8%AF%8D%E6%90%9C%E7%B4%A0%E9%87%8F%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/"/>
    <id>https://atffang.github.io/2023/09/11/%E7%99%BE%E5%BA%A6%E6%8C%87%E6%95%B0%E7%88%AC%E5%8F%96%E2%80%94%E2%80%94%E4%B8%8D%E5%90%8C%E5%9F%8E%E5%B8%82%E5%AF%B9%E4%BA%8E%E5%90%84%E7%B1%BB%E5%85%B3%E9%94%AE%E8%AF%8D%E6%90%9C%E7%B4%A0%E9%87%8F%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/</id>
    <published>2023-09-11T14:02:38.000Z</published>
    <updated>2023-09-11T14:40:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>程序设计需求：横向对比中国各城市对于各关键词百度搜索强度。</p><span id="more"></span><p>  本程序基于网友longxiaofei设计的百度指数访问python包，链接如下：<a href="https://github.com/longxiaofei/spider-BaiduIndex%E3%80%82">https://github.com/longxiaofei/spider-BaiduIndex。</a></p><p>爬虫需要获取百度指数网站cookie，在百度指数官网打开开发者模式即可取得。<br />  爬虫核心函数代码如下，程序链接会在文末贴出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取百度指数的函数  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_baidu_index</span>(<span class="params">keywords_list: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]], citycode, cookiesQueue</span>):  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># cookie  </span></span><br><span class="line">    cookies = cookiesQueue.queue[<span class="number">0</span>]  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 当前请求的五个关键词  </span></span><br><span class="line">    requested_keywords = []  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 一组（五个）关键词为元素的队列  </span></span><br><span class="line">    q_keywords = queue.Queue(-<span class="number">1</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 将keywordlist分组后置入队列q_keywords  </span></span><br><span class="line">    <span class="keyword">for</span> splited_keywords_list <span class="keyword">in</span> split_keywords(keywords_list):  </span><br><span class="line">        q_keywords.put(splited_keywords_list)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 当次请求的城市名称  </span></span><br><span class="line">    cityname = <span class="built_in">str</span>(CITY_MAP[<span class="built_in">str</span>(citycode)])  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始请求&quot;</span>+<span class="built_in">str</span>(CITY_MAP[<span class="built_in">str</span>(citycode)])+<span class="string">&quot;的百度指数&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 遍历q_keywords，每一组q_keywords请求一次  </span></span><br><span class="line">    <span class="comment"># 获得的数据输入data  </span></span><br><span class="line">    datas = []  </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> q_keywords.empty():  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 取出一组  </span></span><br><span class="line">        cur_keywords_list = q_keywords.get()  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 增加容错率：若错误，则换cookie重试  </span></span><br><span class="line">        <span class="comment"># 当前尝试次数  </span></span><br><span class="line">        attempts = <span class="number">0</span>  </span><br><span class="line">        <span class="comment"># 最大尝试次数  </span></span><br><span class="line">        max_attempts = <span class="number">3</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">while</span> attempts &lt; max_attempts:  </span><br><span class="line">            <span class="keyword">try</span>:  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;开始请求: <span class="subst">&#123;cur_keywords_list&#125;</span>&quot;</span>)  </span><br><span class="line">                <span class="comment"># 这一组获得的data  </span></span><br><span class="line">                current_data = []  </span><br><span class="line">                <span class="keyword">for</span> index <span class="keyword">in</span> get_search_index(  </span><br><span class="line">                        keywords_list=cur_keywords_list,  </span><br><span class="line">                        start_date=STARTTIME,  </span><br><span class="line">                        end_date=ENDTIME,  </span><br><span class="line">                        cookies=cookies,  </span><br><span class="line">                        area=citycode  </span><br><span class="line">                ):  </span><br><span class="line">                    index[<span class="string">&quot;keyword&quot;</span>] = <span class="string">&quot;,&quot;</span>.join(index[<span class="string">&quot;keyword&quot;</span>])  </span><br><span class="line">                    <span class="comment"># 将输出的index数据转化为list  </span></span><br><span class="line">                    index_list = [citycode, cityname, index[<span class="string">&#x27;keyword&#x27;</span>], index[<span class="string">&#x27;type&#x27;</span>], index[<span class="string">&#x27;date&#x27;</span>], index[<span class="string">&#x27;index&#x27;</span>]]  </span><br><span class="line">                    current_data.append(index_list)  </span><br><span class="line">                requested_keywords.extend(cur_keywords_list)  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;请求完成: <span class="subst">&#123;cur_keywords_list&#125;</span>&quot;</span>)  </span><br><span class="line">                datas.extend(current_data)  </span><br><span class="line">                time.sleep(<span class="number">0.2</span>)  </span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:  </span><br><span class="line">                traceback.print_exc()  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;请求出错, requested_keywords: <span class="subst">&#123;requested_keywords&#125;</span>，错误为<span class="subst">&#123;e&#125;</span>&quot;</span>)  </span><br><span class="line">                time.sleep(<span class="number">5</span>)  </span><br><span class="line">                cookies = cookiesQueue.get()  </span><br><span class="line">                attempts += <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> datas</span><br></pre></td></tr></table></figure><p>  本程序包含三个文件夹与一个主程序（.py），其中参考数据文件夹给出了百度指数对于中国355个城市给出的代码以及相应的城市名称，输出数据文件夹存储爬取的数据，而输入数据的文件夹包含存储百度cookies文本文件Allcookies，每行存放一个cookie，注意行末不要出现换行符。由于百度指数对于每个cookie访问的次数存在限制（几天后会刷新），因此对于关键词较多的爬取要求，建议多准备几个cookie。Ocity数据中存放城市代码与城市名称，Keyword中存放关键词（第一列存放排序数字）。总之，按示例数据填充即可。<br />代码链接如下：<br /><a href="https://github.com/ATFfang/ATFfang.github.io/tree/main/2023/09/11/%E7%99%BE%E5%BA%A6%E6%8C%87%E6%95%B0%E7%88%AC%E5%8F%96%E2%80%94%E2%80%94%E4%B8%8D%E5%90%8C%E5%9F%8E%E5%B8%82%E5%AF%B9%E4%BA%8E%E5%90%84%E7%B1%BB%E5%85%B3%E9%94%AE%E8%AF%8D%E6%90%9C%E7%B4%A0%E9%87%8F%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/%E7%99%BE%E5%BA%A6%E7%88%AC%E8%99%ABV2">链接</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;程序设计需求：横向对比中国各城市对于各关键词百度搜索强度。&lt;/p&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
  <entry>
    <title>python数据结构基础</title>
    <link href="https://atffang.github.io/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/"/>
    <id>https://atffang.github.io/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/</id>
    <published>2023-09-05T12:49:50.000Z</published>
    <updated>2023-09-13T07:04:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>2023-04-03日上传，2023-04-05日第三次更新。<br />报了个蓝桥杯的python赛道，却没怎么复习……稍微整理了一些数据结构（python实现）的知识点，赛前看一下。</p><span id="more"></span><p><strong>可以先看看第六章python基础</strong>（我记性太差了）</p><p>以下有的代码是书上抄的，有的代码是我自己写的，有的代码是gpt生成的，均为经过编译器编译，准确性未知，主要看个思路！</p><p>以及：如果网页版看的不爽，您可以点击下载<a href="https://raw.githubusercontent.com/ATFfang/publicWarehouse/main/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80.md">markdown</a>（只是里面没有动图）。请注意：务必下载时，选择文件类型为全部文件，<a href="http://xn--siqsrg0kktvclai81k.md">文件后缀改为.md</a>（<a href="http://xn--Chrome-np7im42b3rqsmy8rarf797sbvfm9cz38ab87d.md">Chrome下载时显示的后缀确实是.md</a>，但这是因为他把后面的.txt折叠了……麻烦删掉）</p><h3 id="1-基础数据结构"><a class="markdownIt-Anchor" href="#1-基础数据结构"></a> 1. 基础数据结构</h3><h4 id="11-栈"><a class="markdownIt-Anchor" href="#11-栈"></a> 1.1 栈</h4><p>python栈实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__self</span>(<span class="params">self</span>):</span><br><span class="line">self.items=[]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.items==[]</span><br><span class="line"><span class="comment">#入栈</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self,item</span>):</span><br><span class="line">self.items.append(item)</span><br><span class="line"><span class="comment">#`pop()` 函数用于删除列表中指定索引位置（默认为最后一个元素）的元素</span></span><br><span class="line"><span class="comment">#出栈</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.items.pop();</span><br><span class="line"><span class="comment">#取值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.items[<span class="built_in">len</span>(items)-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(self.items)</span><br></pre></td></tr></table></figure><p>用途：匹配括号，将十进制转化为二进制，前序、中序、后序表达式以及其之间的转换。</p><h4 id="12-a队列"><a class="markdownIt-Anchor" href="#12-a队列"></a> 1.2 a.队列</h4><p>python队列的实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">self.items=[]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.items==[]</span><br><span class="line"><span class="comment">#入队</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enqueue</span>(<span class="params">self,item</span>):</span><br><span class="line"><span class="keyword">return</span> self.items.insert(<span class="number">0</span>,item)</span><br><span class="line"><span class="comment">#出队</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dequeue</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.items.pop();</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(self.items)</span><br></pre></td></tr></table></figure><p>队列的例子：模拟传土豆，模拟打印任务</p><h4 id="12-b双端队列"><a class="markdownIt-Anchor" href="#12-b双端队列"></a> 1.2 b.双端队列</h4><p>双端队列是与队列类似的有序集合。与队列不同的是，双端队列在哪一端添加元素都没有任何限制，移除也是同理。<br />双端队列的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Deque</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">self.items=[]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.items==[]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addFront</span>(<span class="params">self,item</span>):</span><br><span class="line">self.items.append(item)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addRear</span>(<span class="params">self,item</span>):</span><br><span class="line">self.items.insert(<span class="number">0</span>,item)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">removeFront</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.items.pop()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">removeRear</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.items.pop(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(self.items)</span><br></pre></td></tr></table></figure><p>双端队列的应用：回文检测器<br />回文检测器：将字符串逐字符加入双端队列，依次进行前后端出队，当前端出队元素和后端出队元素相等时再继续。</p><h4 id="13-列表"><a class="markdownIt-Anchor" href="#13-列表"></a> 1.3 列表</h4><h5 id="131无序列表链表"><a class="markdownIt-Anchor" href="#131无序列表链表"></a> 1.3.1无序列表：链表</h5><p>node节点是构建链表的基本数据结构。每一个节点至少保有：数据变量；指向下一个节点的应用。下面是一个node类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,initdata</span>):</span><br><span class="line">self.data=initdata</span><br><span class="line">self.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getData</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.data</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getNext</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.<span class="built_in">next</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setData</span>(<span class="params">self,newdata</span>):</span><br><span class="line">self.data=newdata</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setNext</span>(<span class="params">self,newnext</span>):</span><br><span class="line">self.<span class="built_in">next</span>=newnext</span><br></pre></td></tr></table></figure><p>通过节点，可以构建无序列表类UnorderedList类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnorderedList</span>:</span><br><span class="line"><span class="comment">#在初始化时，只需要一个head节点：</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">self.head=<span class="literal">None</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.head==<span class="literal">None</span></span><br><span class="line"><span class="comment">#在head前添加一个节点，并将这个节点设置为head，此时head不再为None，即链表不再为空</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self,item</span>):</span><br><span class="line">temp=Node(item)</span><br><span class="line">temp.setNext(self.head)</span><br><span class="line">self.head=temp</span><br><span class="line"><span class="comment">#通过遍历获取链表长度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">length</span>(<span class="params">self</span>):</span><br><span class="line">current=self.head</span><br><span class="line">cont=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(current!=<span class="literal">None</span>):</span><br><span class="line">cont+=<span class="number">1</span></span><br><span class="line">current=current.getNext()</span><br><span class="line"><span class="keyword">return</span> cont</span><br><span class="line"><span class="comment">#遍历寻找元素是否在链表内</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self,item</span>):</span><br><span class="line">current=self.head</span><br><span class="line">found=false</span><br><span class="line"><span class="keyword">while</span>(current!=<span class="literal">None</span> <span class="keyword">and</span> found==false):</span><br><span class="line"><span class="keyword">if</span>(current.data==item):</span><br><span class="line">found=true</span><br><span class="line"><span class="keyword">return</span> found</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">current=current.getNext()</span><br><span class="line"><span class="keyword">return</span> found</span><br><span class="line"><span class="comment">#通过遍历删除值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self,item</span>):</span><br><span class="line">current=self.head</span><br><span class="line">previous=<span class="literal">None</span></span><br><span class="line">found=<span class="literal">False</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> found:</span><br><span class="line"><span class="keyword">if</span> current.getData()==item:</span><br><span class="line">found=<span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">previous=current</span><br><span class="line">current=current.getNext()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> previous==<span class="literal">None</span>:</span><br><span class="line">self.head=current.getNext()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">previous.setNext(current.getNext())</span><br></pre></td></tr></table></figure><h5 id="132-有序列表"><a class="markdownIt-Anchor" href="#132-有序列表"></a> 1.3.2 有序列表</h5><p>有序列表中，元素的相对位置取决于他们的基本特征<br />有序列表的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OrderedList</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">self.head=<span class="literal">None</span></span><br><span class="line"><span class="comment">#遍历，找到比插入值大的节点，插入到该节点的前面</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self,item</span>):</span><br><span class="line">current=self.head</span><br><span class="line">precious=<span class="literal">None</span></span><br><span class="line">stop=<span class="literal">False</span></span><br><span class="line"><span class="keyword">while</span> current!=<span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> stop:</span><br><span class="line"><span class="keyword">if</span> current.getData()&gt;item:</span><br><span class="line">stop=<span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">previous=current</span><br><span class="line">current=current.getNext()</span><br><span class="line">temp=Node(item)</span><br><span class="line"><span class="keyword">if</span>(previous=<span class="literal">None</span>):</span><br><span class="line">self.head=temp</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">temp.setNext(current)</span><br><span class="line">precious.setNext(temp)</span><br><span class="line"><span class="comment">#遍历，直到满足：1.找到了；2.遍历到的值已经大于要找的值，退出；</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self,item</span>):</span><br><span class="line">current=self.head</span><br><span class="line">found=<span class="literal">False</span></span><br><span class="line">stop=<span class="literal">False</span></span><br><span class="line"><span class="keyword">while</span> current!=<span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> found <span class="keyword">and</span> <span class="keyword">not</span> stop:</span><br><span class="line"><span class="keyword">if</span> current.getData()==item:</span><br><span class="line">found=<span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">if</span> current.getData()&gt;item:</span><br><span class="line">stop=<span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">current=current.getNext()</span><br><span class="line"><span class="keyword">return</span> found</span><br></pre></td></tr></table></figure><h3 id="2-递归"><a class="markdownIt-Anchor" href="#2-递归"></a> 2. 递归</h3><h4 id="21-迷宫搜索"><a class="markdownIt-Anchor" href="#21-迷宫搜索"></a> 2.1 迷宫搜索</h4><p>示例：迷宫搜索函数：<br />下列的实例代码中，接受三个参数：迷宫对象、起始行、起始列<br />PART_OF_PATH:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">searchForm</span>(<span class="params">maze,startRow,startColumn</span>):</span><br><span class="line">maze.updatePosition(startRow,startColumn)</span><br><span class="line"><span class="comment">#检查基本情况</span></span><br><span class="line"><span class="comment">#1.遇到墙</span></span><br><span class="line"><span class="keyword">if</span> (maze[startRow][startColumn]==OBSTACLE):</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="comment">#2.遇到已经走过的格子</span></span><br><span class="line"><span class="keyword">if</span> (maze[startRow][startColumn]==TRIED):</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="comment">#3.找到出口</span></span><br><span class="line"><span class="keyword">if</span> maze.isExit([startRow][startColumn]):</span><br><span class="line">maze.updatePosition(startRow,startColumn,PART_OF_PATH)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">maze.updatePosition(startRow,startColumn,TRIED)</span><br><span class="line"></span><br><span class="line"><span class="comment">#否则，依次尝试四个方向走动，对于or，只要有一个正确，后面的就不会执行</span></span><br><span class="line">found=searchFrom(maze,startRow-<span class="number">1</span>,startColumn)\</span><br><span class="line"><span class="keyword">or</span> searchFrom(maze,startRow+<span class="number">1</span>,startColumn)\</span><br><span class="line"><span class="keyword">or</span> searchFrom(maze,startRow,startColumn-<span class="number">1</span>)\</span><br><span class="line"><span class="keyword">or</span> searchFrom(maze,startRow,startColumn+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> found:</span><br><span class="line">maze.uodatePosition(startRow,startColumn,PART_OF_PATH)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">maze.uodatePosition(startRow,startColumn,DEAD_END)</span><br><span class="line"><span class="keyword">return</span> found</span><br></pre></td></tr></table></figure><h4 id="22-汉诺塔"><a class="markdownIt-Anchor" href="#22-汉诺塔"></a> 2.2 汉诺塔</h4><p>其他示例：汉诺塔<br />汉诺塔是一种经典的递归问题，它的原理比较简单：有三根杆子，在其中一根杆子上按照大小顺序放置了若干个圆盘，现在需要把这些圆盘从一根杆子移动到另一根杆子上，移动过程中要保证较大的圆盘必须放在较小的圆盘下面，且每次只能移动一个圆盘。在汉诺塔问题中，我们通常称这三根杆子为 A、B、C 杆。</p><p>解决汉诺塔问题的常用方法是递归算法，具体的步骤如下：</p><ol><li>递归出口：当只有一个圆盘时，直接把它从 A 杆移到 C 杆上，即 return 1。</li><li>将 n-1 个圆盘从 A 杆移动到 B 杆上，使用 C 杆作为辅助杆。</li><li>将第 n 个圆盘从 A 杆移动到 C 杆上。</li><li>将 n-1 个圆盘从 B 杆移动到 C 杆上，使用 A 杆作为辅助杆。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hanoi</span>(<span class="params">n, A, B, C</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Move disk 1 from &#123;&#125; to &#123;&#125;&quot;</span>.<span class="built_in">format</span>(A, C))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        step1 = hanoi(n - <span class="number">1</span>, A, C, B)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Move disk &#123;&#125; from &#123;&#125; to &#123;&#125;&quot;</span>.<span class="built_in">format</span>(n, A, C))</span><br><span class="line">        step2 = hanoi(n - <span class="number">1</span>, B, A, C)</span><br><span class="line">        <span class="keyword">return</span> step1 + <span class="number">1</span> + step2</span><br></pre></td></tr></table></figure><h4 id="23-动态规划"><a class="markdownIt-Anchor" href="#23-动态规划"></a> 2.3 动态规划</h4><p>示例：动态规划找零问题：</p><ul><li>问题提出：硬币只有1美分，5美分，10美分和25美分，如何在消耗硬币最少的情况下，找零出37美分？</li><li>问题剖析：<br />1.递归方法，即：<br />若是每次找出x元的硬币，则剩余找零为（找零-x）元，每次利用函数numCoins寻找四种numCoins（找零-x）中的最小值，构建一颗子节点为4的递归树。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numCoins=<span class="built_in">min</span>(<span class="number">1</span>+numCoins(找零-<span class="number">1</span>),<span class="number">1</span>+numCoins(找零-<span class="number">5</span>),<span class="number">1</span>+numCoins(找零-<span class="number">10</span>),<span class="number">1</span>+numCoins(找零-<span class="number">25</span>))</span><br></pre></td></tr></table></figure><ol start="2"><li>动态规划方法，即：<br />每个金额的找零方式都由该金额-i的找零方式所决定，其中，i为硬币面值。<br />譬如，当我们需要知道15分怎么找时，可以求以下方式的最小值：</li></ol><ul><li>一枚一分的硬币+14分所需的最少的硬币（1+6）</li><li>一枚5分的硬币+10分所需的最少的硬币（1+1）</li><li>一枚10分的硬币+5分所需最少的硬币（1+1）</li></ul><p>因此，我们从0开始，指导要解的找零值，求出这之间所有值的最小硬币构成。<br />下面为动态规划的实现，其中，coinValueList为硬币的面值列表，change表示找零金额，minCoins表示从0到change的所有最优解，coinsUsed存储用于找零的硬币。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dpMakeChange</span>(<span class="params">coinValueList,change,minCoins,coinsUsed</span>):</span><br><span class="line"><span class="comment">#从0遍历到change（python左闭右开！）</span></span><br><span class="line"><span class="keyword">for</span> cents <span class="keyword">in</span> <span class="built_in">range</span>(change+<span class="number">1</span>):</span><br><span class="line"><span class="comment">#所用的硬币数</span></span><br><span class="line">coinCount=cents</span><br><span class="line"><span class="comment">#记录使用的硬币的面额</span></span><br><span class="line">newCoin=<span class="number">1</span></span><br><span class="line"><span class="comment">#遍历所有小于找零值的硬币</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> [c <span class="keyword">for</span> c <span class="keyword">in</span> coinValueList of c&lt;cents]:</span><br><span class="line"><span class="comment">#如果cents-面额j的最小硬币数+1小于之前求得的硬币数，则替换</span></span><br><span class="line"><span class="keyword">if</span> minCoins[cents-j]+<span class="number">1</span>&lt;coinCount:</span><br><span class="line">CoinCount=minCoins[cents-j]+<span class="number">1</span></span><br><span class="line">newCoin=j</span><br><span class="line"><span class="comment">#记载入最优解列表中</span></span><br><span class="line">minCoins[cents]=contCount</span><br><span class="line"><span class="comment">#记载入使用过的硬币列表中</span></span><br><span class="line">coinUsed[cents]=newCoin</span><br><span class="line"><span class="keyword">return</span> minCoins[change]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printCoins</span>(<span class="params">coinsUsed,change</span>):</span><br><span class="line">coin=change</span><br><span class="line"><span class="keyword">while</span> coin&gt;<span class="number">0</span>:</span><br><span class="line">thisCoin=coinsUsed[coin]</span><br><span class="line"><span class="built_in">print</span>(thisCoin)</span><br><span class="line">coin=coin-thisCoin</span><br></pre></td></tr></table></figure><p>下面详细介绍一下动态规划：<br /><strong>动态规划</strong>（Dynamic Programming，简称DP）是一种将复杂问题分解成更小的子问题来解决的优化技术，常用于解决最优化问题。它在求解具有重叠子问题和最优子结构的问题中特别有效。</p><p>动态规划的基本思想是将原问题分解成若干个子问题，先求解子问题的最优解，然后通过子问题的最优解得到原问题的最优解。具体来说，动态规划的思路包括以下几个步骤：<br />（1）划分：按照问题的特征，把问题分为若干阶段。注意：划分后的阶段一定是有序的或者可排序的<br />（2）确定状态和状态变量：将问题发展到各个阶段时所处的各种不同的客观情况表现出来。状态的选择要满足无后续性<br />（3）确定决策并写出状态转移方程：状态转移就是根据上一阶段的决策和状态来导出本阶段的状态。根据相邻两个阶段状态之间的联系来确定决策方法和状态转移方程<br />（4）边界条件：状态转移方程是一个递推式，因此需要找到递推终止的条件</p><p>整个求解过程可以用一张最优决策表来描述，最优决策表是一张二维表（行：决策阶段，列：问题的状态）表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</p><p>例如：f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)}</p><p>下面是一些问题实例，有助于理解动态规划：</p><h5 id="231-背包问题"><a class="markdownIt-Anchor" href="#231-背包问题"></a> 2.3.1 背包问题</h5><p>对于初学者来说，理解背包问题并不容易，可以先看这个<a href="https://www.bilibili.com/video/BV1g7411B7SP/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=717d4feb094126b2033be27866e18150">视频</a>，里面有十分详细的讲解。<br />背包问题是一类经典的优化问题，通常指在给定容量的背包中，如何选择最有价值的物品，使得背包中物品的总价值最大。<br />具体来说，背包问题有两种形式：0/1背包和完全背包。<br />0/1背包问题中，物品不可分割，每个物品只有一个，选择放入或不放入，不能将物品分成若干部分装入背包。<br />完全背包问题中，每个物品可以选择放入多次，即物品是可分割的。</p><p>对于这两种问题，一般可以用动态规划的思想进行求解。设背包容量为V，有n个物品，第i个物品的体积为v[i]，价值为w[i]。定义f(i,j)表示在前i个物品中选择不超过j容量的物品的最大价值，则有：</p><ol><li>对于0/1背包问题：<br />f(i,j) = max{f(i-1,j), f(i-1,j-v[i])+w[i]}, j &gt;= v[i]<br />f(i,j) = f(i-1,j), j &lt; v[i]<br />即：当第i件物品可以加入背包时，可以选择加入或者不加入。如果加入，则总价值为：f(i-1,j)，若不加入，则总价值为：第i件物品的价值+当前容量（总容量-第i件物品的重量）能够存放的最大价值f(i,j) = max{f(i-1,j), f(i-1,j-v[i])+w[i]}, j &gt;= v[i]</li></ol><p>python实现的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">knapsack</span>(<span class="params">capacity, weights, values, n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    0/1背包问题的解法</span></span><br><span class="line"><span class="string">    :param capacity: 背包的容量</span></span><br><span class="line"><span class="string">    :param weights: 每个物品的重量列表</span></span><br><span class="line"><span class="string">    :param values: 每个物品的价值列表</span></span><br><span class="line"><span class="string">    :param n: 物品数量</span></span><br><span class="line"><span class="string">    :return: 最大价值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 初始化二维数组f，用于存储状态转移方程的结果</span></span><br><span class="line">    f = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(capacity + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, capacity + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 如果当前物品的体积小于等于背包容量，则可以选择装入或者不装入</span></span><br><span class="line">            <span class="keyword">if</span> weights[i-<span class="number">1</span>] &lt;= j:</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i-<span class="number">1</span>][j], f[i-<span class="number">1</span>][j-weights[i-<span class="number">1</span>]]+values[i-<span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 否则只能不装入</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                f[i][j] = f[i-<span class="number">1</span>][j]</span><br><span class="line">    <span class="keyword">return</span> f[n][capacity]</span><br></pre></td></tr></table></figure><h5 id="232-台阶问题"><a class="markdownIt-Anchor" href="#232-台阶问题"></a> 2.3.2 台阶问题</h5><p>有n级台阶，一个人每次上一级或者两级，问有多少种走完n级台阶的方法。</p><p>分析：动态规划的实现的关键在于能不能准确合理的用动态规划表来抽象出 实际问题。在这个问题上，我们让f(n)表示走上n级台阶的方法数。</p><p>那么当n为1时，f(n) = 1,n为2时，f(n) =2,就是说当台阶只有一级的时候，方法数是一种，台阶有两级的时候，方法数为2。那么当我们要走上n级台阶，必然是从n-1级台阶迈一步或者是从n-2级台阶迈两步，所以到达n级台阶的方法数必然是到达n-1级台阶的方法数加上到达n-2级台阶的方法数之和。即f(n) = f(n-1)+f(n-2)，我们用dp[n]来表示动态规划表，dp[i],i&gt;0,i&lt;=n,表示到达i级台阶的方法数。</p><p>下面是一个python实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param n: an integer</span></span><br><span class="line"><span class="string">    @return: an ineger f(n)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">up</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="comment"># if n == 0:</span></span><br><span class="line">        <span class="comment">#     return 0</span></span><br><span class="line">        L = []</span><br><span class="line">        L.append(<span class="number">1</span>)</span><br><span class="line">        L.append(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">            L.append(L[i - <span class="number">1</span>] + L[i - <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> L[n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="3-搜索与排序"><a class="markdownIt-Anchor" href="#3-搜索与排序"></a> 3. 搜索与排序</h3><h4 id="31-搜索"><a class="markdownIt-Anchor" href="#31-搜索"></a> 3.1 搜索</h4><p>Python提供了in，通过它可以方便的检查元素是否在列表中：<br /><code>15 in [1,2,3,4,15]</code></p><h5 id="311-顺序搜索"><a class="markdownIt-Anchor" href="#311-顺序搜索"></a> 3.1.1 顺序搜索</h5><p>这个就不讲了，大猩猩都会</p><h5 id="312-二分搜索"><a class="markdownIt-Anchor" href="#312-二分搜索"></a> 3.1.2 二分搜索</h5><p>目标值比中间元素小，则在左半部分继续查找；否则，在右半部分继续查找。重复以上过程，直到找到目标值或者确定目标值不存在为止。<br />二分搜索算法的时间复杂度为 O(log n)，其中 n 表示数组中元素的个数，因此它比线性搜索算法的时间复杂度 O(n) 更快，特别是对于大规模的数据集。<br />显然，二分搜索可以使用递归实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_helper</span>(<span class="params">arr, target, left, right</span>): </span><br><span class="line"><span class="keyword">if</span> left &gt; right: </span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span> </span><br><span class="line">mid = (left + right) // <span class="number">2</span> </span><br><span class="line"><span class="keyword">if</span> arr[mid] == target: </span><br><span class="line"><span class="keyword">return</span> mid </span><br><span class="line"><span class="keyword">elif</span> arr[mid] &lt; target: </span><br><span class="line"><span class="keyword">return</span> binary_search_helper(arr, target, mid + <span class="number">1</span>, right) </span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line"><span class="keyword">return</span> binary_search_helper(arr, target, left, mid - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h5 id="313-散列"><a class="markdownIt-Anchor" href="#313-散列"></a> 3.1.3 散列</h5><p>（这里我不想写了，下面都是gpt写的）<br />散列（Hashing）是一种用于快速查找的数据结构，它能够在 O(1) 的时间复杂度内完成查找操作。散列使用散列函数将键映射到存储位置，每个存储位置称为散列表中的一个桶。当需要查找一个键时，可以使用散列函数计算出该键对应的桶的位置，并在该桶中查找是否存在对应的值。</p><p>散列函数是散列表的关键，它将键映射到桶的位置。一个好的散列函数应该具有以下特点：</p><ol><li>散列函数应该能够将不同的键映射到不同的桶，避免不同键的哈希冲突。</li><li>散列函数应该尽可能地将键均匀地分布在桶中，避免出现某些桶过载的情况。</li><li>散列函数的计算速度应该足够快，否则会影响散列表的性能。</li></ol><p>散列函数可以使用不同的算法来实现，包括简单的取余法、乘法散列法、多项式散列法、MD5 散列等。</p><p>在实际应用中，散列可以用于解决大量数据的查找问题，例如在数据库中查找记录、在哈希表中查找键值对等。但是，散列也有一些缺点，例如：</p><ol><li>散列函数可能出现哈希冲突，即不同的键映射到了同一个桶中，需要使用冲突解决策略来解决。</li><li>散列表的性能取决于散列函数的质量和散列表的装载因子，当装载因子过高时，会影响散列表的性能。</li><li>散列表的大小通常是固定的，不能动态扩展，如果散列表的大小不够，需要重新创建一个更大的散列表来解决。</li></ol><p>下面是一个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, size</span>):</span><br><span class="line">        self.size = size</span><br><span class="line">        self.table = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash_func</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(key) % self.size</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        index = self.hash_func(key)</span><br><span class="line">        self.table[index].append((key, value))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, key</span>):</span><br><span class="line">        index = self.hash_func(key)</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> self.table[index]:</span><br><span class="line">            <span class="keyword">if</span> k == key:</span><br><span class="line">                <span class="keyword">return</span> v</span><br><span class="line">        <span class="keyword">raise</span> KeyError(key)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, key</span>):</span><br><span class="line">        index = self.hash_func(key)</span><br><span class="line">        <span class="keyword">for</span> i, (k, v) <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.table[index]):</span><br><span class="line">            <span class="keyword">if</span> k == key:</span><br><span class="line">                <span class="keyword">del</span> self.table[index][i]</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">raise</span> KeyError(key)</span><br></pre></td></tr></table></figure><p>以上是一个简单的散列表实现，使用 Python 列表作为散列表的存储结构，使用哈希函数将键映射到散列表中的索引位置。当插入一个键值对时，使用哈希函数计算键的索引位置，并将键值对添加到该位置对应的列表中。当查找或删除一个键值对时，同样使用哈希函数计算键的索引位置，并在该位置对应的列表中查找或删除键值对。</p><p>这里的哈希函数使用内置函数 hash，它可以将任意 Python 对象转换为整数，并且保证相同的对象具有相同的哈希值。但是，在实际应用中，可以根据具体的应用场景选择不同的哈希函数。</p><h4 id="32-排序"><a class="markdownIt-Anchor" href="#32-排序"></a> 3.2 排序</h4><p>python提供了内置的排序函数：<br /><code>list.sort(*, key=None, reverse=False)</code>：该函数用于对列表进行原地排序，它接受 key 函数和 reverse 参数，如果 reverse 参数为 True，则按照降序排序。</p><h5 id="321-冒泡排序"><a class="markdownIt-Anchor" href="#321-冒泡排序"></a> 3.2.1 冒泡排序</h5><p>冒泡排序（Bubble Sort）是一种简单的排序算法，它重复地走访过要排序的数列，依次比较相邻的两个元素，如果它们的顺序错误就交换它们的位置，直到没有需要交换的元素为止。<br />这没啥要讲的了</p><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%86%92%E6%B3%A1.gif" class="" title="sucessful"><h5 id="322-选择排序"><a class="markdownIt-Anchor" href="#322-选择排序"></a> 3.2.2 选择排序</h5><p>选择排序（Selection Sort）是一种简单的排序算法，它的基本思想是找到最小元素并将其放置在数组的起始位置，然后继续找到剩余元素中的最小元素并放置在已排序序列的末尾，以此类推，直到所有元素都排好序为止。</p><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E9%80%89%E6%8B%A9.gif" class="" title="sucessful"><p>具体实现过程如下：</p><ol><li>遍历整个数组，找到其中最小的元素，并记录其位置。</li><li>将最小元素与数组的第一个元素进行交换。</li><li>排除已排序的第一个元素，对剩余元素执行步骤 1 和 2，直到所有元素都被排序。</li></ol><p>下面是一个代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">selection_sort</span>(<span class="params">lst</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(lst)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        min_idx = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> lst[j] &lt; lst[min_idx]:</span><br><span class="line">                min_idx = j</span><br><span class="line">        lst[i], lst[min_idx] = lst[min_idx], lst[i]</span><br><span class="line">    <span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure><h5 id="323-插入排序"><a class="markdownIt-Anchor" href="#323-插入排序"></a> 3.2.3 插入排序</h5><p>一个一个插入到已排序序列中的合适位置，最终完成排序。具体实现过程如下：</p><ol><li>遍历整个数组，将数组中的第一个元素视为已排序序列。</li><li>遍历未排序序列中的元素，将它插入到已排序序列中的合适位置，使得插入后的序列仍然有序。</li><li>重复步骤 2 直到所有元素都被插入到已排序序列中。</li></ol><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E6%8F%92%E5%85%A5.gif" class="" title="sucessful"><p>下面是一个代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">lst</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(lst)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        key = lst[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> lst[j] &gt; key:</span><br><span class="line">            lst[j + <span class="number">1</span>] = lst[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        lst[j + <span class="number">1</span>] = key</span><br><span class="line">    <span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure><h5 id="324-希尔排序"><a class="markdownIt-Anchor" href="#324-希尔排序"></a> 3.2.4 希尔排序</h5><p>希尔排序（Shell Sort）是一种改进的插入排序算法，它是通过将整个序列分成若干个子序列来实现排序，每个子序列分别进行插入排序，最终完成整个序列的排序。</p><p>希尔排序的基本思想是将待排序序列按照一定的步长进行分组，对每组使用插入排序算法进行排序。然后将步长逐渐缩小，重复进行分组和排序，直到步长为 1。此时，序列已经被分成了若干个有序子序列，最后进行一次插入排序即可完成整个序列的排序。</p><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%B8%8C%E5%B0%94.gif" class="" title="sucessful"><p>下面是实现的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">shell_sort</span>(<span class="params">lst</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(lst)</span><br><span class="line">    gap = n // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap, n):</span><br><span class="line">            key = lst[i]</span><br><span class="line">            j = i - gap</span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> lst[j] &gt; key:</span><br><span class="line">                lst[j + gap] = lst[j]</span><br><span class="line">                j -= gap</span><br><span class="line">            lst[j + gap] = key</span><br><span class="line">        gap //= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure><p>其中，参数 lst 是一个待排序的列表，函数返回一个新的已排序的列表。函数首先将整个序列分成若干个子序列，对每个子序列使用插入排序算法进行排序。然后将步长 gap 逐渐缩小，重复进行分组和排序，直到步长为 1。在每个子序列中，将当前元素存储为关键字 key，并将它与已排序序列中的元素进行比较，找到合适的位置并插入，直到所有元素都被插入到已排序序列中为止。</p><h5 id="325-归并排序"><a class="markdownIt-Anchor" href="#325-归并排序"></a> 3.2.5 归并排序</h5><p>归并排序（Merge Sort）是一种稳定的排序算法，它采用分治思想将待排序序列分成若干个子序列，每个子序列都是有序的，然后再将这些有序的子序列合并成一个有序序列。</p><p>归并排序的基本思想是将待排序序列不断地对半分割，直到每个子序列只有一个元素，然后将相邻的子序列进行合并，形成新的有序子序列，直到最终只剩下一个有序序列为止。合并操作时，需要额外的一个数组来存储已经排序好的元素，最后再将排序好的元素复制回原数组。</p><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%BD%92%E5%B9%B6.gif" class="" title="sucessful"><p>以下是使用 Python 实现的归并排序代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">lst</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(lst) &gt; <span class="number">1</span>:</span><br><span class="line">        mid = <span class="built_in">len</span>(lst) // <span class="number">2</span></span><br><span class="line">        left_half = lst[:mid]</span><br><span class="line">        right_half = lst[mid:]</span><br><span class="line"></span><br><span class="line">        merge_sort(left_half)</span><br><span class="line">        merge_sort(right_half)</span><br><span class="line"></span><br><span class="line">        i = j = k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left_half) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right_half):</span><br><span class="line">            <span class="keyword">if</span> left_half[i] &lt; right_half[j]:</span><br><span class="line">                lst[k] = left_half[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lst[k] = right_half[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left_half):</span><br><span class="line">            lst[k] = left_half[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(right_half):</span><br><span class="line">            lst[k] = right_half[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure><p>其中，参数 lst 是一个待排序的列表，函数返回一个新的已排序的列表。函数首先将待排序序列不断地对半分割，直到每个子序列只有一个元素，然后将相邻的子序列进行合并，形成新的有序子序列，直到最终只剩下一个有序序列为止。在合并操作中，需要额外的一个数组来存储已经排序好的元素，最后再将排序好的元素复制回原数组。</p><h5 id="326-快速排序"><a class="markdownIt-Anchor" href="#326-快速排序"></a> 3.2.6 快速排序</h5><p>快速排序（Quick Sort）是一种常见的排序算法，它采用分治思想将待排序序列分成两个子序列，一部分小于基准元素，一部分大于基准元素。然后对这两个子序列分别进行递归排序，最终得到一个有序序列。</p><p>快速排序的基本思想是选定一个基准元素，然后通过一趟排序将待排序序列分成两部分，使得左边的子序列都小于基准元素，右边的子序列都大于基准元素，然后分别对左右两部分递归地进行快速排序，最终得到一个有序序列。</p><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%BF%AB%E9%80%9F.gif" class="" title="sucessful"><p>以下是使用 Python 实现的快速排序代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">lst, left, right</span>):</span><br><span class="line">    <span class="keyword">if</span> left &lt; right:</span><br><span class="line">        pivot_index = partition(lst, left, right)</span><br><span class="line">        quick_sort(lst, left, pivot_index - <span class="number">1</span>)</span><br><span class="line">        quick_sort(lst, pivot_index + <span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">lst, left, right</span>):</span><br><span class="line">    pivot = lst[left]</span><br><span class="line">    i, j = left + <span class="number">1</span>, right</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">while</span> i &lt;= j <span class="keyword">and</span> lst[i] &lt; pivot:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j <span class="keyword">and</span> lst[j] &gt;= pivot:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &lt;= j:</span><br><span class="line">            lst[i], lst[j] = lst[j], lst[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    lst[left], lst[j] = lst[j], lst[left]</span><br><span class="line">    <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure><p>其中，参数 lst 是一个待排序的列表，参数 left 和 right 是列表的左右边界，函数使用递归的方式实现快速排序。在递归的过程中，首先选定一个基准元素，然后通过 partition 函数将待排序序列分成两部分。partition 函数使用双指针的方式将待排序序列分成两部分，左边部分的元素都小于基准元素，右边部分的元素都大于等于基准元素。最后，将基准元素放在分界点上，返回分界点的位置。然后分别对左右两部分递归地进行快速排序，最终得到一个有序序列。</p><h3 id="4-树"><a class="markdownIt-Anchor" href="#4-树"></a> 4. 树</h3><p>不多介绍，直接看实现与算法</p><h4 id="41-树的实现"><a class="markdownIt-Anchor" href="#41-树的实现"></a> 4.1 树的实现</h4><h5 id="411-实现方法1列表之列表"><a class="markdownIt-Anchor" href="#411-实现方法1列表之列表"></a> 4.1.1 实现方法1：列表之列表</h5><p>例如，a为根节点，有子节点b，c，节点b又有子节点d（左），则使用列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a,[b,[d,[],[]],[]],[c,[],[]]]</span><br></pre></td></tr></table></figure><p>不说了，这方法真的会有人用吗</p><h5 id="412-实现方法2节点与引用"><a class="markdownIt-Anchor" href="#412-实现方法2节点与引用"></a> 4.1.2 实现方法2：节点与引用</h5><p>基础类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,rootObj</span>):</span><br><span class="line">self.key=rootObj</span><br><span class="line">self.leftChild=<span class="literal">None</span></span><br><span class="line">self.rightChild=<span class="literal">None</span></span><br></pre></td></tr></table></figure><p>插入左节点（如果已经存在左子节点，插入时要把原先的左子节点降一层，自己到那个位置）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">instertLeft</span>(<span class="params">self,newNode</span>):</span><br><span class="line"><span class="keyword">if</span>(self.leftChild==<span class="literal">None</span>):</span><br><span class="line">self.leftChild=BinaryTree(newNode)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">t=BinaryTree(newNode)</span><br><span class="line">t.leftChild=self.leftChild</span><br><span class="line">self.leftChild=t</span><br></pre></td></tr></table></figure><p>右子节点也一样。<br />访问函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getRightChild</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.rightChild</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getLeftChild</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.LeftChild</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setRootVal</span>(<span class="params">self,obj</span>):</span><br><span class="line">self.key=obj</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getRootVal</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.key</span><br></pre></td></tr></table></figure><h4 id="42-树的遍历"><a class="markdownIt-Anchor" href="#42-树的遍历"></a> 4.2 树的遍历</h4><p>树的遍历方式分为三种：前序遍历、中序遍历、后序遍历</p><h5 id="421-前序遍历"><a class="markdownIt-Anchor" href="#421-前序遍历"></a> 4.2.1 前序遍历</h5><p>先访问根节点，然后递归地前序遍历左子树，最后递归地前序遍历右子树</p><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%89%8D%E5%BA%8F.gif" class="" title="sucessful"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">tree</span>):</span><br><span class="line"><span class="keyword">if</span> tree:</span><br><span class="line"><span class="built_in">print</span>(tree.getRootVal())</span><br><span class="line">preorder(tree.getLeftChild())</span><br><span class="line">preorder(tree.getRightChild())</span><br></pre></td></tr></table></figure><h5 id="422-中序遍历"><a class="markdownIt-Anchor" href="#422-中序遍历"></a> 4.2.2 中序遍历</h5><p>先递归地中序遍历左子树，然后访问根节点，在中序遍历右子树</p><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E4%B8%AD%E5%BA%8F.gif" class="" title="sucessful"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">tree</span>):</span><br><span class="line"><span class="keyword">if</span> tree:</span><br><span class="line">inorder(tree.getLeftChild())</span><br><span class="line"><span class="built_in">print</span>(tree.getRootVal())</span><br><span class="line">inorder(tree.getRightChild())</span><br></pre></td></tr></table></figure><h5 id="423-后序遍历"><a class="markdownIt-Anchor" href="#423-后序遍历"></a> 4.2.3 后序遍历</h5><p>先递归地后序遍历右子树，然后递归地后序遍历左子树，最后访问根节点</p><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%90%8E%E5%BA%8F.gif" class="" title="sucessful"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">postorder</span>(<span class="params">tree</span>):</span><br><span class="line"><span class="keyword">if</span> tree:</span><br><span class="line">postorder(tree.getLeftChild())</span><br><span class="line">postorder(tree.getRightChild())</span><br><span class="line"><span class="built_in">print</span>(tree.getRootVal())</span><br></pre></td></tr></table></figure><h4 id="43-利用二叉堆实现优先级队列"><a class="markdownIt-Anchor" href="#43-利用二叉堆实现优先级队列"></a> 4.3 利用二叉堆实现优先级队列</h4><p>二叉堆（binary heap）是一种特殊的二叉树数据结构，它可以用数组来实现，并且常用于实现优先队列。</p><p>二叉堆分为最大堆和最小堆两种类型。最大堆满足任何一个父节点的键值大于等于它的任何一个子节点的键值；最小堆则满足任何一个父节点的键值小于等于它的任何一个子节点的键值。因此，最大堆的堆顶是堆中的最大元素，最小堆的堆顶是堆中的最小元素。</p><p>二叉堆的数组实现中，数组的第一个元素是根节点，数组的下标从1开始（而不是0）。对于第i个节点，它的左子节点在2i的位置，右子节点在2i+1的位置，父节点在i/2的位置（向下取整）。</p><p>二叉堆的主要操作包括插入一个元素、删除堆顶元素和查找堆顶元素。插入一个元素需要将元素插入到堆的最后一个位置，然后通过向上逐级比较交换，将新元素移动到合适的位置以维护堆的性质。删除堆顶元素需要将堆顶元素与堆中最后一个元素交换位置，然后删除最后一个元素，并通过向下逐级比较交换，将堆顶元素移动到合适的位置以维护堆的性质。查找堆顶元素只需要返回数组的第一个元素。</p><h5 id="431-二叉堆的实现"><a class="markdownIt-Anchor" href="#431-二叉堆的实现"></a> 4.3.1 二叉堆的实现</h5><p>在实现二叉堆时，我们通过创建一颗完全二叉树来维持树的平衡。在完全二叉树中，除了最底层，其他每一层的节点都是满的。在对底层，从左往右填充节点。</p><p>完全二叉树的特殊之处在于，可以用一个列表来表示它。<br />完全二叉树节点在列表中的排序为：从上而下，从左往右。<br />按此排布，对于在列表中位置p的节点来说，其左子节点的位置为2p，右子节点的位置为2p+1（请读者自行推算一遍）</p><p>二叉堆的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">self.heapList=[<span class="number">0</span>]</span><br><span class="line">self.currentSize=<span class="number">0</span></span><br></pre></td></tr></table></figure><p>对于一个要求子节点大于父节点的堆来说，插入的最简单、最高效的方法就是将元素追加到列表的末尾，然后和其父节点比较，若小于其父节点，就对换位置。此处代码不再给出，简单来说就是比较插入的第i个和父节点第i//2个对比。</p><p>二叉堆还有一个功能，删除最小元素（即根节点），但是删除后，需要对堆进行重建。重建方法为：</p><ol><li>取出列表中最后一个元素，将其放在根节点的位置</li><li>通过与子节点之间的交换，将新的根节点沿着树推到正确的位置</li></ol><h4 id="44-二叉搜索树"><a class="markdownIt-Anchor" href="#44-二叉搜索树"></a> 4.4 二叉搜索树</h4><p>二叉搜索树依赖于这样的性质：小于父节点的键都在左子树中，大于父节点的键则都在右子树中。</p><h5 id="441-插入"><a class="markdownIt-Anchor" href="#441-插入"></a> 4.4.1 插入</h5><p>根据性质，插入算法为：</p><ol><li>从根节点开始搜索二叉树，比较新键与当前节点的键，如果新键更小，搜索左子树，如果新键更大，搜索右子树</li><li>当没有可供搜索的左/右字节点时，说明找到了正确的位置。</li><li>创建一个TreeNode对象，并将其插入到前一步发现的位置上。</li></ol><p>下面是一个利用递归方法实现的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.root:</span><br><span class="line">            self.root = Node(val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._insert(val, self.root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_insert</span>(<span class="params">self, val, node</span>):</span><br><span class="line">        <span class="keyword">if</span> val &lt; node.val:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left:</span><br><span class="line">                node.left = Node(val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self._insert(val, node.left)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                node.right = Node(val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self._insert(val, node.right)</span><br></pre></td></tr></table></figure><h5 id="442-查找"><a class="markdownIt-Anchor" href="#442-查找"></a> 4.4.2 查找</h5><p>相似的，查找的方法为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, val</span>):</span><br><span class="line">    node = self.root</span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        <span class="keyword">if</span> node.val == val:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        <span class="keyword">elif</span> val &lt; node.val:</span><br><span class="line">            node = node.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = node.right</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h5 id="443-删除"><a class="markdownIt-Anchor" href="#443-删除"></a> 4.4.3 删除</h5><p>删除的情况就相对复杂。</p><ol><li>要删除的节点是叶子节点，也就是没有左右子节点的节点。在这种情况下，可以直接删除该节点，将其父节点的左子节点或右子节点指向 None。</li><li>要删除的节点只有一个子节点，可以将该节点的子节点替换为该节点。</li><li>要删除的节点有两个子节点。在这种情况下，可以将该节点的左子树的最大节点或右子树的最小节点替换该节点。（因为左子树的最大节点或右子树的最小节点正好可以填进去）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span>:</span><br><span class="line">    <span class="comment"># 省略插入方法和查找方法...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, val</span>):</span><br><span class="line">        node, parent = self.search_with_parent(val)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 未找到要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">or</span> <span class="keyword">not</span> node.right:  <span class="comment"># 第一种和第二种情况</span></span><br><span class="line">            child = node.left <span class="keyword">or</span> node.right</span><br><span class="line">            <span class="keyword">if</span> parent:</span><br><span class="line">                <span class="keyword">if</span> node == parent.left:</span><br><span class="line">                    parent.left = child</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    parent.right = child</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.root = child</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 第三种情况</span></span><br><span class="line">            succ = node.right</span><br><span class="line">            <span class="keyword">while</span> succ.left:</span><br><span class="line">                succ = succ.left</span><br><span class="line">            node.val = succ.val</span><br><span class="line">            <span class="keyword">if</span> succ == node.right:</span><br><span class="line">                node.right = succ.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = self.search_with_parent(succ.val)[<span class="number">1</span>]</span><br><span class="line">                p.left = succ.right</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="45-平衡二叉搜索树"><a class="markdownIt-Anchor" href="#45-平衡二叉搜索树"></a> 4.5 平衡二叉搜索树</h4><p>这个真太烦了，我不高兴看了T.T</p><h4 id="46-霍夫曼树"><a class="markdownIt-Anchor" href="#46-霍夫曼树"></a> 4.6 霍夫曼树</h4><p>霍夫曼树（Huffman Tree）是一种带权路径最短的树，通常用于数据压缩。它的构建过程基于贪心算法，根据数据频率构建一棵无损压缩的树。具体来说，给定一组数据和对应的权值，霍夫曼树的构建过程如下：</p><ol><li>对所有的数据按照权值从小到大排序，每个数据作为一个单独的节点。</li><li>每次从排序后的节点中选取权值最小的两个节点，将它们合并为一个新节点，新节点的权值为两个节点的权值之和，左子节点为权值较小的节点，右子节点为权值较大的节点。</li><li>将新节点插入到排序后的节点列表中，并删除原来的两个节点。</li><li>重复步骤2和3，直到只剩下一个节点为止，该节点即为霍夫曼树的根节点。</li></ol><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%93%88%E5%A4%AB%E6%9B%BC.gif" class="" title="sucessful style&#x3D;display: block; margin: 0 auto; max-width: 50%;"><p>下面是一个Python实现示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HuffmanNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value, weight</span>):</span><br><span class="line">        self.value = value</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_huffman_tree</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="comment"># 构建叶子节点列表</span></span><br><span class="line">    nodes = [HuffmanNode(val, weight) <span class="keyword">for</span> val, weight <span class="keyword">in</span> data]</span><br><span class="line">    <span class="comment"># 构建霍夫曼树</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(nodes) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># 按权值排序</span></span><br><span class="line">        nodes.sort(key=<span class="keyword">lambda</span> node: node.weight)</span><br><span class="line">        <span class="comment"># 取出权值最小的两个节点</span></span><br><span class="line">        left_node = nodes.pop(<span class="number">0</span>)</span><br><span class="line">        right_node = nodes.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 构建新节点</span></span><br><span class="line">        new_weight = left_node.weight + right_node.weight</span><br><span class="line">        new_node = HuffmanNode(<span class="literal">None</span>, new_weight)</span><br><span class="line">        new_node.left = left_node</span><br><span class="line">        new_node.right = right_node</span><br><span class="line">        <span class="comment"># 将新节点加入节点列表中</span></span><br><span class="line">        nodes.append(new_node)</span><br><span class="line">    <span class="comment"># 返回根节点</span></span><br><span class="line">    <span class="keyword">return</span> nodes[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>在这个实现中，我们先定义了一个<code>HuffmanNode</code>类，表示霍夫曼树中的节点。每个节点包含一个<code>value</code>属性表示节点的值（如果节点是叶子节点，则为原始数据），一个<code>weight</code>属性表示节点的权值，以及左子节点和右子节点。我们还定义了一个<code>build_huffman_tree(data)</code>函数，用于构建霍夫曼树。<code>data</code>参数是一个二元组列表，每个二元组包含一个数据和对应的权值。函数返回霍夫曼树的根节点。</p><p>在构建完霍夫曼树后，我们可以通过对树进行遍历来获得每个数据的编码。具体来说，我们可以对树进行先序遍历，在遍历过程中，记录每个叶子节点的编码（0表示向左走，1表示向右走）。最终得到的编码就是霍夫曼编码，可以用于数据压缩。</p><p>例如，如果一个数据出现的频率很高，代表着他权值很高，我们可以用一个比较短的编码来表示它，比如说用一个1位的编码表示它。而如果一个数据出现的频率很低，我们可以用一个比较长的编码来表示它，比如说用一个10位的编码表示它。这样，在对数据进行编码后，数据的存储空间就会减少。</p><h3 id="5-图"><a class="markdownIt-Anchor" href="#5-图"></a> 5. 图</h3><p>下面先回顾一下图中的术语以及定义：</p><ol><li>顶点（vertex）：也称为节点，表示图中的一个点，通常用一个唯一的标识符来标识。</li><li>边（edge）：表示两个顶点之间的连线，可以是有向或无向的，可以有权重或无权重。</li><li>权重（weight）：如果边带有数值，则称这个数值为边的权重。</li><li>路径（path）：表示从一个顶点到另一个顶点依次经过的边和顶点的序列，路径的长度为路径上所有边的权重之和。</li><li>环（cycle）：表示一个顶点经过一系列边回到自身的路径。</li><li>连通（connected）：如果图中的任意两个顶点都有一条路径相连，则称该图是连通的。</li><li>连通分量（connected component）：无向图中每个连通的部分称为一个连通分量。</li><li>强连通（strongly connected）：如果有向图中的任意两个顶点都有互相到达的路径，则称该图是强连通的。</li><li>强连通分量（strongly connected component）：有向图中每个强连通的部分称为一个强连通分量。</li><li>入度（in-degree）：有向图中指向一个顶点的边的数量。</li><li>出度（out-degree）：有向图中从一个顶点出发的边的数量。</li><li>邻接点（adjacent vertex）：与一个顶点直接相连的顶点称为它的邻接点。</li><li>邻接矩阵（adjacency matrix）：用矩阵来表示图中每个顶点之间的连通关系，其中矩阵中的行和列分别代表图中的顶点，矩阵中的元素表示两个顶点之间是否有连通关系。</li><li>邻接表（adjacency list）：用链表来表示图中每个顶点的邻接点列表，链表中的每个节点表示一个邻接点。</li></ol><h4 id="51-图的抽象数据类型以及其实现"><a class="markdownIt-Anchor" href="#51-图的抽象数据类型以及其实现"></a> 5.1 图的抽象数据类型以及其实现</h4><h5 id="511-邻接矩阵"><a class="markdownIt-Anchor" href="#511-邻接矩阵"></a> 5.1.1 邻接矩阵</h5><p>只是一个矩阵，不多赘述</p><h5 id="512-邻接表"><a class="markdownIt-Anchor" href="#512-邻接表"></a> 5.1.2 邻接表</h5><p>python中，字典的键值对可以有效地实现图的边。下面是一个示例，利用字典connectedTo来记录与节点Vertex相邻的点。</p><p>以下给出一个节点类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,key</span>):</span><br><span class="line">self.<span class="built_in">id</span>=key</span><br><span class="line">self.connectedTo=&#123;&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addNeighbor</span>(<span class="params">self,nbr,weight=<span class="number">0</span></span>):</span><br><span class="line">self.connectefTo(nbr)=weight</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">str</span>(self.<span class="built_in">id</span>)+<span class="string">&#x27; connectedTo: &#x27;</span>+<span class="built_in">str</span>([x.<span class="built_in">id</span> <span class="keyword">for</span> x <span class="keyword">in</span> self.connectedTo])</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getConnections</span>(<span class="params">self</span>):</span><br><span class="line"><span class="comment">#通过获取所有键，获取节点所有相接的顶点名</span></span><br><span class="line"><span class="keyword">return</span> self.connectedTo.keys()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getId</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.<span class="built_in">id</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getWeight</span>(<span class="params">self,nbr</span>):</span><br><span class="line"><span class="keyword">return</span> self.connectedTo[nbr]</span><br></pre></td></tr></table></figure><p>Graph类就不再赘述，只需要特别注意两个功能：添加顶点，添加边</p><h4 id="52-广度优先搜索bfs"><a class="markdownIt-Anchor" href="#52-广度优先搜索bfs"></a> 5.2 广度优先搜索（BFS）</h4><p>要求边的权值都为0！！！！！！</p><p>BFS，即广度优先搜索（Breadth-First Search），是一种图的遍历算法，用于在图中搜索特定的节点或路径。BFS从给定的起始节点开始遍历图，首先访问起始节点的所有邻居节点，然后按照遍历的深度依次访问下一层节点，直到遍历完整张图或找到目标节点为止。</p><p>BFS通常借助队列（Queue）数据结构来实现。首先将起始节点加入队列中，然后不断从队列中取出最早进入队列的节点，并将其邻居节点加入队列中（如果之前取过了，则不取），并计算节点到起始节点的距离（父节点到起始节点的距离+1）直到队列为空或找到目标节点为止。</p><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.gif" class="" title="sucessful style&#x3D;display: block; margin: 0 auto; max-width: 50%;"><p>下面是一个实现的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pythonds.graphs <span class="keyword">import</span> Graph, Vertex</span><br><span class="line"><span class="keyword">from</span> pythonds.basic <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">BFS</span>(<span class="params">g,start,end</span>):</span><br><span class="line"><span class="comment">#储存据起始节点距离</span></span><br><span class="line">distance=&#123;&#125;</span><br><span class="line">distance[start]=<span class="number">0</span></span><br><span class="line"><span class="comment">#储存是否有被访问过</span></span><br><span class="line">visited=[]</span><br><span class="line"><span class="comment">#队列</span></span><br><span class="line">queue=Queue()</span><br><span class="line">queue.enqueue(start)</span><br><span class="line"><span class="comment">#创建字典，用于记录每个节点的父节点，用于回溯路径</span></span><br><span class="line">parent = &#123;&#125; </span><br><span class="line"><span class="keyword">while</span>(!queue.size==<span class="number">0</span>):</span><br><span class="line"><span class="comment">#currentq：当前访问到的节点，名字起错了，不想改了</span></span><br><span class="line">currentq=queue.dequeue()</span><br><span class="line"><span class="keyword">if</span>(currentq==end):</span><br><span class="line"><span class="comment">#回溯打印</span></span><br><span class="line"><span class="keyword">while</span>(!currentq==start):</span><br><span class="line"><span class="built_in">print</span>(currentq.<span class="built_in">id</span>)</span><br><span class="line">currentq=parent[currentq]</span><br><span class="line"><span class="built_in">print</span>(start.<span class="built_in">id</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> currentq.connectedTo:</span><br><span class="line"><span class="keyword">if</span>(item <span class="keyword">not</span> <span class="keyword">in</span> visited):</span><br><span class="line">visited.appenf(item)</span><br><span class="line">queue.enqueue(item)</span><br><span class="line">distance[item]=distance[current]+<span class="number">1</span></span><br><span class="line">parent[item]=currentq</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="53-深度优先搜索"><a class="markdownIt-Anchor" href="#53-深度优先搜索"></a> 5.3 深度优先搜索</h4><p>深度优先搜索（Depth-First-Search, DFS）是一种用于遍历或搜索树或图的算法，其主要思想是从起点开始，不断往深度方向搜索，直到找到目标节点或者无法继续为止，然后返回上一层节点，继续搜索其他未被访问过的节点。</p><p>递归式的DFS可以通过递归调用实现。具体实现过程如下：</p><ol><li>创建一个visited数组，用于记录每个节点是否被访问过，初始值都为False。</li><li>定义DFS函数，输入参数为当前节点和图的邻接表表示。首先标记当前节点为已访问，并输出当前节点。然后遍历当前节点的邻居节点，对于每个未被访问过的邻居节点，递归调用DFS函数。</li><li>在主函数中遍历图中的每个节点，对于每个未被访问过的节点，调用DFS函数。</li></ol><p>以下是Python实现代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">currentVertex, visited</span>)<span class="comment">#当前访问的节点，已经访问过的节点列表</span></span><br><span class="line">visited[currentVertex]=<span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span>(currentVertex.<span class="built_in">id</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> currentVertex.connectedTo:</span><br><span class="line"><span class="keyword">if</span>(item <span class="keyword">not</span> <span class="keyword">in</span> visited):</span><br><span class="line">DFS(currentVertex,visited)</span><br></pre></td></tr></table></figure><h4 id="54-最短路径"><a class="markdownIt-Anchor" href="#54-最短路径"></a> 5.4 最短路径</h4><h5 id="541-dijkstra算法"><a class="markdownIt-Anchor" href="#541-dijkstra算法"></a> 5.4.1 Dijkstra算法</h5><p>Dijkstra算法是一种用于求解单源最短路径的贪心算法，它能够计算出从一个源点到图中其他所有点的最短路径。算法的基本思想是维护一个到源点的距离数组，每次选取一个距离最短的点进行松弛操作（通过更新边来减小从起点到顶点的距离），更新其他节点到源点的距离值。当所有节点都被更新后，最短路径就求解完成。</p><p>以下是使用Python实现Dijkstra算法的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个函数用于实现Dijkstra算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dijkstra</span>(<span class="params">graph, start</span>):</span><br><span class="line">    <span class="comment"># 初始化距离字典，所有节点的距离值默认为无限大</span></span><br><span class="line">    dist = &#123;node: <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125;</span><br><span class="line">    <span class="comment"># 将起点的距离值初始化为0</span></span><br><span class="line">    dist[start] = <span class="number">0</span></span><br><span class="line">    ……<span class="comment">#初始化距离字典</span></span><br><span class="line">    <span class="comment"># 初始化路径字典</span></span><br><span class="line">    path = &#123;start: []&#125;</span><br><span class="line">    <span class="comment"># 将起点放入已访问节点集合中</span></span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 从未访问节点中找到距离起点最近的节点</span></span><br><span class="line">        min_node = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> graph:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">if</span> min_node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    min_node = node</span><br><span class="line">                <span class="keyword">elif</span> dist[node] &lt; dist[min_node]:</span><br><span class="line">                    min_node = node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> min_node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将该节点标记为已访问</span></span><br><span class="line">        visited.add(min_node)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新所有与该节点相邻的节点的距离值</span></span><br><span class="line">        <span class="keyword">for</span> neighbor, weight <span class="keyword">in</span> graph[min_node].items():</span><br><span class="line">            <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                new_dist = dist[min_node] + weight</span><br><span class="line">                <span class="keyword">if</span> new_dist &lt; dist[neighbor]:</span><br><span class="line">                    dist[neighbor] = new_dist</span><br><span class="line">                    path[neighbor] = path[min_node] + [min_node]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist, path</span><br></pre></td></tr></table></figure><h5 id="542-prim算法"><a class="markdownIt-Anchor" href="#542-prim算法"></a> 5.4.2 Prim算法</h5><p>Prim算法是一种用于解决最小生成树问题的贪心算法。其基本思路是从一个起点开始，不断扩展生成树，每次加入距离已有部分最近的一个点，直到所有点都被加入为止。</p><p>具体步骤如下：</p><ol><li>初始化一个空的生成树，以一个节点作为起始节点；</li><li>找到与生成树相邻的边中，权值最小的那条边，将其连接的点加入生成树中；</li><li>重复第二步，直到所有节点都加入生成树中。</li></ol><p>该算法可以借助优先级队列来实现（Dijkstra算法也可以，但我没用），优先级队列可以弹出包含最小元素的字典。</p><p>下面是一个python实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pythonds.graphs <span class="keyword">import</span> PriorityQueue, Graph, Vertex</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Prim</span>(<span class="params">G, start</span>):</span><br><span class="line">pq=PriorityQueue()</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> G:</span><br><span class="line">v.setDistance(sys.maxsize)<span class="comment">#设置和起始点的距离</span></span><br><span class="line">v.setPred(<span class="literal">None</span>)<span class="comment">#设置前驱结点</span></span><br><span class="line">start.SetDistance(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#创建一个堆，存放河节点的相邻节点</span></span><br><span class="line">pq.buildHeap([(v.getDistance, v) <span class="keyword">for</span> v <span class="keyword">in</span> G])</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> pq.isEmpty():</span><br><span class="line"><span class="comment">#取出最小的起始点的相邻节点</span></span><br><span class="line">currentVert=pq.delMin()</span><br><span class="line"><span class="comment">#遍历该节点的所有相邻节点</span></span><br><span class="line"><span class="keyword">for</span> nextVert <span class="keyword">in</span> currentVert.getConnections():</span><br><span class="line"><span class="comment">#新的距离=节点currentVert和原点的距离+当前节点和currentVert的距离</span></span><br><span class="line">newCost=currentVert.getWeight(nextVert)+currentVert.getDistance()</span><br><span class="line"><span class="comment">#如果新生成的路径长度比原来的短</span></span><br><span class="line"><span class="keyword">if</span> v <span class="keyword">in</span> pq <span class="keyword">and</span> newCost&lt;nextVert.getDistance():</span><br><span class="line">nextVert.setPred(currentVert)</span><br><span class="line">nextVert.setDistance(newCost)</span><br><span class="line">pq.decreaseKey(nextVert,newCost)</span><br></pre></td></tr></table></figure><h3 id="6-python基础复习"><a class="markdownIt-Anchor" href="#6-python基础复习"></a> 6. python基础复习</h3><h4 id="61-python基础库"><a class="markdownIt-Anchor" href="#61-python基础库"></a> 6.1 python基础库</h4><ol><li>队列：queue，入队和出队的方法分别是put()和get()，empty(): 判断队列是否为空。qsize(): 返回队列中当前的元素个数。</li><li>栈：Python 中没有专门表示栈的基础库，但是可以使用内置的 list类来实现栈的功能，因为list 的 append() 和 pop()方法可以分别实现入栈和出栈操作。</li></ol><h4 id="62-基础函数"><a class="markdownIt-Anchor" href="#62-基础函数"></a> 6.2 基础函数</h4><h5 id="621-列表基础函数"><a class="markdownIt-Anchor" href="#621-列表基础函数"></a> 6.2.1 列表基础函数</h5><ol><li>append：在列表末尾添加一个元素，例如：<code>list.append(item)</code></li><li>extend：将一个列表中的所有元素添加到另一个列表末尾，例如：<code>list.extend(another_list)</code></li><li>insert：在列表的指定位置插入一个元素，例如：<code>list.insert(index, item)</code></li><li>remove：删除列表中指定的元素，例如：<code>list.remove(item)</code></li><li>pop：从列表中删除指定位置的元素，并返回该元素，例如：<code>list.pop(index)</code></li><li>index：返回列表中指定元素的索引位置，例如：<code>list.index(item)</code></li><li>count：返回列表中指定元素出现的次数，例如：<code>list.count(item)</code></li><li>sort：对列表中的元素进行排序，例如：<code>list.sort()</code></li><li>reverse：将列表中的元素反向排序，例如：<code>list.reverse()</code></li><li>clear：从列表中删除所有元素，例如：<code>list.clear()</code></li><li>构建二维数组：Sum=[[0 for i in range(n)]for j in range(m)]</li></ol><h5 id="622-字典基础函数"><a class="markdownIt-Anchor" href="#622-字典基础函数"></a> 6.2.2 字典基础函数</h5><ol><li>dict()：创建一个新字典</li><li>len(dict)：返回字典中键值对的数量</li><li>dict[key]：获取字典中指定键的值</li><li>dict[key] = value：设置字典中指定键的值</li><li>del dict[key]：从字典中删除指定键</li><li>key in dict：检查字典中是否包含指定键</li><li>dict.keys()：返回一个包含字典所有键的列表</li><li>dict.values()：返回一个包含字典所有值的列表</li><li>dict.items()：返回一个包含字典所有键值对的列表</li><li>dict.get(key, default)：获取字典中指定键的值，如果键不存在返回默认值</li><li>dict.setdefault(key, default)：获取字典中指定键的值，如果键不存在设置默认值并返回</li><li>dict.pop(key, default)：从字典中删除指定键，并返回其对应的值。如果键不存在返回默认值</li><li>dict.update(other_dict)：使用其他字典中的键值对来更新当前字典</li></ol><h5 id="623-map-filter函数"><a class="markdownIt-Anchor" href="#623-map-filter函数"></a> 6.2.3 map、filter函数</h5><p><code>map()</code> 是 Python 内置的一个高阶函数，它将一个函数作用于一个或多个可迭代对象的每个元素上，并返回一个可迭代对象（迭代器），其中包含应用函数后的结果。</p><p><code>map()</code> 函数的语法如下，下面是一个简单的例子，将一个列表中的每个元素乘以 2：：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">double</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">doubled_numbers = <span class="built_in">list</span>(<span class="built_in">map</span>(double, numbers))</span><br><span class="line"><span class="built_in">print</span>(doubled_numbers)  <span class="comment"># [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>double()</code> 函数接收一个参数并返回该参数的两倍。<code>map()</code> 函数将 <code>double()</code> 应用于 <code>numbers</code> 列表中的每个元素，并返回一个迭代器，其中包含应用函数后的结果。<code>list()</code> 函数将迭代器转换为一个列表，最终输出 <code>[2, 4, 6, 8, 10]</code>。</p><p><code>filter</code>函数：对一个可迭代对象中的元素进行过滤，返回满足条件的元素组成的新的可迭代对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_even</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">return</span> num % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">even_nums = <span class="built_in">filter</span>(is_even, nums)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(even_nums))  <span class="comment"># [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure><h5 id="624-字符串函数"><a class="markdownIt-Anchor" href="#624-字符串函数"></a> 6.2.4 字符串函数</h5><ol><li>len()：获取字符串的长度。</li><li>strip()：去掉字符串开头和结尾的空格。</li><li>split()：按照指定的分隔符将字符串分割成列表。</li><li>join()：将列表或元组中的字符串拼接成一个字符串，中间用指定的字符隔开。</li><li>replace()：将字符串中指定的子字符串替换为另一个字符串。</li><li>find()：查找指定的子字符串在字符串中的位置，返回第一个匹配到的位置。</li><li>lower()和upper()：分别将字符串转换成小写和大写。</li><li>startswith()和endswith()：判断字符串是否以指定的字符串开头或结尾。</li><li>isdigit()、isalpha()和isalnum()：判断字符串是否全部由数字、字母或数字字母组成。</li><li>format()：将指定的值格式化到字符串中。</li><li>list()：转化为一个列表</li></ol><p>示例：join的用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">words = [<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;awesome&#x27;</span>]</span><br><span class="line">sep = <span class="string">&#x27; &#x27;</span></span><br><span class="line">sentence = sep.join(words)</span><br><span class="line"><span class="built_in">print</span>(sentence) <span class="comment"># 输出：Python is awesome</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;2023-04-03日上传，2023-04-05日第三次更新。&lt;br /&gt;
报了个蓝桥杯的python赛道，却没怎么复习……稍微整理了一些数据结构（python实现）的知识点，赛前看一下。&lt;/p&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
  <entry>
    <title>JS实现地理流可视化</title>
    <link href="https://atffang.github.io/2023/07/06/JS%E5%AE%9E%E7%8E%B0%E5%9C%B0%E7%90%86%E6%B5%81%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <id>https://atffang.github.io/2023/07/06/JS%E5%AE%9E%E7%8E%B0%E5%9C%B0%E7%90%86%E6%B5%81%E5%8F%AF%E8%A7%86%E5%8C%96/</id>
    <published>2023-07-06T05:42:38.000Z</published>
    <updated>2023-08-16T13:49:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>前端对于地理流数据进行可视化。</p><span id="more"></span><p>地理流是一种地理对象间交互的表现形式，一般来说，地理流是单向的，如北京向上海的人口流动，而两个地理流构成了一对地理对象之间的交互，如北京-上海人口流动由北京向上海的人口流动与上海向北京的人口流动构成。由此，在一组地理对象间的地理流数据可以表示为一个OD(origin-destination)矩阵。基于一些需求，我需要将地理流数据展现在网页地图上，下面给出一个基于mapbox的原生解决方案。</p><h4 id="正文"><a class="markdownIt-Anchor" href="#正文"></a> 正文</h4><h5 id="一-贝塞尔曲线"><a class="markdownIt-Anchor" href="#一-贝塞尔曲线"></a> 一.  <strong>贝塞尔曲线</strong></h5><p><img align="left" width=50% src="https://s2.loli.net/2023/08/16/dMDqrkQty71zNLI.gif" style="margin-right: 20px;margin-top: 10px;margin-buttom:20px;">  贝塞尔曲线是一种<strong>使用数学方法描述的曲线</strong>，被广泛用于计算机图形学和动画中。一般来说，除起点与终点外，贝塞尔曲线拥有两个控制点，确定控制点与终末点的位置关系即可得到设想中的曲线。<br />   能力有限我们无法直接得到一条曲线公式，故使用点集替代，再将其转化为弧段。</p><p>  &amp;emsp定义一个函数<code>getCurvedLine</code>,输入ps（起始点）,pe（结束点）,arci（弧度），返回一个点集，表示包含500个点的贝塞尔曲线：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getCurvedLine</span>(<span class="params">ps,pe,arci</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(ps==pe)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">computeControlPoint1</span> = (<span class="params">ps, pe, arc = arci</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> deltaX = pe[<span class="number">0</span>] - ps[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">const</span> deltaY = pe[<span class="number">1</span>] - ps[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">const</span> theta = <span class="title class_">Math</span>.<span class="title function_">atan</span>(deltaY / deltaX);</span><br><span class="line">        <span class="keyword">const</span> len = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>((deltaX * deltaX) + (deltaY * deltaY)) / <span class="number">2</span> * arc;</span><br><span class="line">        <span class="keyword">const</span> newTheta = theta - <span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">          (ps[<span class="number">0</span>] + pe[<span class="number">0</span>]) / <span class="number">2</span> - len * <span class="title class_">Math</span>.<span class="title function_">cos</span>(newTheta),</span><br><span class="line">          (ps[<span class="number">1</span>] + pe[<span class="number">1</span>]) / <span class="number">2</span> - len * <span class="title class_">Math</span>.<span class="title function_">sin</span>(newTheta),</span><br><span class="line">        ];</span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> controlpoint1=<span class="title function_">computeControlPoint1</span>(ps,pe)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> linePoints=[ps,controlpoint1,pe];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> line = turf.<span class="title function_">lineString</span>(linePoints);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> curved = turf.<span class="title function_">bezierSpline</span>(line);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> curveCoordinates = curved.<span class="property">geometry</span>.<span class="property">coordinates</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> curveCoordinates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="二-生成featurecollection"><a class="markdownIt-Anchor" href="#二-生成featurecollection"></a> 二.  <strong>生成featureCollection</strong></h5><p>   FeatureCollection 是 GeoJSON 格式中的一种，它用于组织多个地理要素（features）。其基本格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;FeatureCollection&quot;</span>,</span><br><span class="line">  <span class="string">&quot;features&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Feature&quot;</span>,</span><br><span class="line">      <span class="string">&quot;geometry&quot;</span>: &#123;...&#125;,   <span class="comment">// 地理要素的几何信息</span></span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;...&#125;  <span class="comment">// 地理要素的属性信息</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 可以有更多的 features</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  FeatureCollection包含了地理要素的类型、几何信息与属性信息。在本项目中，使用mapbox展示弧线段。将点集转化为FeatureCollection的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getArcFeature</span>(<span class="params">lineList, valueList, arc</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> curveCoordinatesList=[];</span><br><span class="line">      lineList.<span class="title function_">forEach</span>(<span class="function">(<span class="params">line</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 在回调函数中使用 line 进行操作</span></span><br><span class="line">        curveCoordinatesList.<span class="title function_">push</span>(<span class="title function_">getCurvedLine</span>(line[<span class="number">0</span>],line[<span class="number">1</span>],arc))</span><br><span class="line">      &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> featureCollection = &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;FeatureCollection&#x27;</span>,</span><br><span class="line">    <span class="attr">features</span>: []</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; curveCoordinatesList.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> curveCoordinates = curveCoordinatesList[i];</span><br><span class="line">      <span class="keyword">const</span> feature = &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;Feature&#x27;</span>,</span><br><span class="line">        <span class="attr">geometry</span>: &#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&#x27;LineString&#x27;</span>,</span><br><span class="line">          <span class="attr">coordinates</span>: curveCoordinates</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">properties</span>: &#123;</span><br><span class="line">          <span class="string">&#x27;value&#x27;</span>:valueList[i]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    featureCollection.<span class="property">features</span>.<span class="title function_">push</span>(feature);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> featureCollection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  其中，LineList包含多个点集，valueList是这些点集对应的地理流强度。本项目中使用的数据格式具体如下：<br /><img align="left" width=50%  src="https://s2.loli.net/2023/08/16/ugZfTRaCh87bWJx.jpg" style="margin-right: 20px;margin-top: 10px;margin-buttom:20px;"><br /><br><br /><br><br /><br></p><h5 id="三-在mapbox上添加弧段"><a class="markdownIt-Anchor" href="#三-在mapbox上添加弧段"></a> 三.  <strong>在Mapbox上添加弧段</strong></h5><p>   将填充好的featureCollection加载在map的source中。mapbox的初始化本文不再赘述。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加线图层</span></span><br><span class="line">map1.<span class="title function_">addSource</span>(<span class="string">&#x27;line_flow&#x27;</span>+drawnum, &#123;</span><br><span class="line">  <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;geojson&#x27;</span>,</span><br><span class="line">  <span class="attr">lineMetrics</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;data&#x27;</span>: featureCollection</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>  其中，drawnum是每个featureCollection唯一标识符，需要保证每次添加时唯一标识符不同，否咋将导致冲突。<br />  按照赋予的id将弧线作为图层添加到map中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">map1.<span class="title function_">addLayer</span>(&#123;</span><br><span class="line">    <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;line_flow&#x27;</span>+drawnum,</span><br><span class="line">    <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;line&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;source&#x27;</span>: <span class="string">&#x27;line_flow&#x27;</span>+drawnum,</span><br><span class="line">    <span class="string">&#x27;layout&#x27;</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;line-join&#x27;</span>: <span class="string">&#x27;round&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;line-cap&#x27;</span>: <span class="string">&#x27;round&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">paint</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;line-width&#x27;</span>: [</span><br><span class="line">        <span class="string">&#x27;interpolate&#x27;</span>,</span><br><span class="line">        [<span class="string">&#x27;linear&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;value&#x27;</span>], <span class="comment">// 使用 feature 的 value 字段作为插值属性</span></span><br><span class="line">        min, <span class="comment">// 最小值</span></span><br><span class="line">        <span class="number">0.5</span>, <span class="comment">// 最小线宽</span></span><br><span class="line">        max, <span class="comment">// 最大值</span></span><br><span class="line">        <span class="number">5</span> <span class="comment">// 最大线宽</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&#x27;line-gradient&#x27;</span>: [</span><br><span class="line">        <span class="string">&#x27;interpolate&#x27;</span>,</span><br><span class="line">        [<span class="string">&#x27;linear&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;line-progress&#x27;</span>],</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        colorList[<span class="number">0</span>],</span><br><span class="line">        <span class="number">0.4</span>,</span><br><span class="line">        colorList[<span class="number">1</span>],</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        colorList[<span class="number">2</span>]</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><img align="left" width=50% src="https://s2.loli.net/2023/08/16/GsXR5UATWij7ZDO.png" style="margin-right: 20px;margin-top: 10px;margin-buttom:20px;">  在paint中使用line-width与line-gradient设置颜色与宽度的插值。添加起点和终点数据，作为点图层添加在map中，大致效果如左图所示<br />   至此，归纳一下总体流程。首先需要将OD数据与OD点对间地理流的强度存储于数据库中，在显示时读取并生成贝塞尔曲线，将曲线作为geometry，地理流强度作为properties生成弧线类型的FeatureCollection，并显示在地图上。此外，mapbox还可以实现对于属性的筛选，这就可以帮助我们做两件事：一是根据流动强度筛选要显示的高于或地域某一阈值的地理流；二是通过单击基础的geojson面，通过其反馈的地级市名称，查询该地的流入\流出数据并显示，例如：<br /><code>'filter': ['==','NAME', states[0].properties.NAME]</code></p><h5 id="四-添加动画"><a class="markdownIt-Anchor" href="#四-添加动画"></a> 四.  <strong>添加动画</strong></h5><p><img align="left" width=50% src="https://s2.loli.net/2023/08/16/LPjHkU46cCOu1Qh.gif" style="margin-right: 20px;margin-top: 10px;margin-buttom:20px;">  在展示单个城市的流入\流出时，可以适当添加动画以提升美观性。例如，通过递归调用绘制点的函数，来展示点扩散，以体现”向外传播“的视觉效果。动画的代码网上种类繁多，我作为前端开发业余爱好者的工作便不做展示。<br />  值得注意的是，在添加新的数据时，最好将先前的source和layer清除，以减轻内存负担。动画的添加也可能会导致卡顿、丢帧等问题，故需要兼容性能，不过这个领域的工作我就完全不了解了T.T<br /><br><br></p><h5 id="五-项目介绍"><a class="markdownIt-Anchor" href="#五-项目介绍"></a> 五.  <strong>项目介绍</strong></h5><p>   该项目爬取了2019、2020及2023年城市在五一期间的两种有向OD流数据:高德迁徙平台地级市间与人口流入流出数量正相关的迁徙指数数据共 889,375 条；百度指数平台地级市间PC端搜索量、手机端搜索量、网络搜索总量数据共 5,595,450 条。对比不同年份五一节假日虚（搜索数据）实（迁徙数据）两种地理流的空间格局，以得出相关结论。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前端对于地理流数据进行可视化。&lt;/p&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
  <entry>
    <title>GCJ02toWGS84</title>
    <link href="https://atffang.github.io/2023/03/25/GCJ02toWGS84/"/>
    <id>https://atffang.github.io/2023/03/25/GCJ02toWGS84/</id>
    <published>2023-03-25T05:26:55.000Z</published>
    <updated>2023-03-25T05:33:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>json文件GCJ02向WGS84坐标系转换的小工具</p><span id="more"></span><p>在做地图学作业时，需要对json数据完成GCJ02向WGS84坐标系的转换，QGIS实现时遇到了一些问题，因此借助openAI的帮助，写了个小脚本，分享给大家。</p><iframe  height=200width=60%src="https://atffang.github.io/GeoJson_GCJ02_WGS84/"  frameborder=0  allowfullscreen></iframe>]]></content>
    
    
    <summary type="html">&lt;p&gt;json文件GCJ02向WGS84坐标系转换的小工具&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="https://atffang.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>基于群体智慧的中国人口多情景时空仿真建模与预测</title>
    <link href="https://atffang.github.io/2023/03/14/%E5%9F%BA%E4%BA%8E%E7%BE%A4%E4%BD%93%E6%99%BA%E6%85%A7%E7%9A%84%E4%B8%AD%E5%9B%BD%E4%BA%BA%E5%8F%A3%E5%A4%9A%E6%83%85%E6%99%AF%E6%97%B6%E7%A9%BA%E4%BB%BF%E7%9C%9F%E5%BB%BA%E6%A8%A1%E4%B8%8E%E9%A2%84%E6%B5%8B/"/>
    <id>https://atffang.github.io/2023/03/14/%E5%9F%BA%E4%BA%8E%E7%BE%A4%E4%BD%93%E6%99%BA%E6%85%A7%E7%9A%84%E4%B8%AD%E5%9B%BD%E4%BA%BA%E5%8F%A3%E5%A4%9A%E6%83%85%E6%99%AF%E6%97%B6%E7%A9%BA%E4%BB%BF%E7%9C%9F%E5%BB%BA%E6%A8%A1%E4%B8%8E%E9%A2%84%E6%B5%8B/</id>
    <published>2023-03-14T11:24:51.000Z</published>
    <updated>2024-11-25T04:14:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>2022ESRI大赛参赛作品（一等奖）。</p><span id="more"></span><h3 id="1-设计思想"><a class="markdownIt-Anchor" href="#1-设计思想"></a> 1 设计思想</h3><h4 id="11-作品背景"><a class="markdownIt-Anchor" href="#11-作品背景"></a> 1.1 作品背景</h4><p>作为人口大国，人口问题始终是中国高度关注的重要战略问题，深刻影响着国家政治改革、经济发展、社会进步和文化建设等方面。然而，目前中国人口发展面临着深刻而复杂的形势变化，人口负增长下“少子老龄化”将成为常态。因此，推动人口长期均衡、可持续发展成为国家急需解决的问题，各类政策调整与社会经济因素变动对人口发展的影响亟待探索。</p><p>目前学界对于人口的研究多基于现有多期人口普查数据，从宏观、综合的视角对人口发展基本状况进行统计分析和预测模拟。研究方法多为Malthus指数模型和Logistic阻滞增长模型等数学方法；研究对象多为人口的<strong>总体</strong>或多个人口<strong>群体</strong>，缺乏对个体差异的深入考量；研究尺度多聚焦国家总体或特定地区，视角较为单一，未能全面地探讨人口的地域性特征。</p><p>为从地理学的视角解决社会问题、完善人口研究，本作品运用群体智慧与复杂系统建模的方法，从单一的智能体（即人口<strong>个体</strong>）的视角出发，自下而上地对中国各等级城市单元人口动态发展过程进行仿真建模，构建三大民生关切的场景，探究人口对于不同情景下社会决策的响应；同时，根据多项人口发展指标分别创建时空立方体，总结人口时空演变规律，并进行人口发展可持续性综合评价及分区，为区域人口发展规划提供参考。总体上，本作品运用创新的模型构建、空间分析方法，从数据层、特征层和决策层实现对中国人口发展的深入探索，从地理学的视角为缓解人口与政治、经济、社会的矛盾提供区域化解决思路，对中国人口可持续发展路径探索具有重要意义。</p><h4 id="12-方法设计"><a class="markdownIt-Anchor" href="#12-方法设计"></a> 1.2 方法设计</h4><p>如图1的技术路线所示，设计流程总体上可概括为数据获取、模型构建、情景模拟与规律探索四部分，最终在应用层面实现<strong>人口多情景决策模拟与推演</strong>以及<strong>人口时空演变规律探索</strong>。</p><div align=center>[![pplzRUA.jpg](https://s1.ax1x.com/2023/03/14/pplzRUA.jpg)](https://imgse.com/i/pplzRUA )图1 作品技术流程图<div align=left><p>第一部分为基础数据的获取与处理，通过多种手段为后续模型构建完成了数据准备；第二部分为基于群体智慧和复杂系统方法的人口动态仿真建模，运用涵盖了个人基本属性、地区特性、健康状况、经济状况及婚育状况的多主题多时期人口数据，构建了仿真的智能体属性库和智能体行为逻辑链，并进行实验验证模型的可行性；第三部分为人口多情景社会决策模拟与推演及时空演变规律探索，结合社会实际问题设定三类情景，通过不同情景下对具体参数的推演，模拟人口动态响应过程，并使用3D时空立方体模型可视化展现不同情景下多项人口指标发展过程，总结人口时空演变规律；第四部分为人口发展可持续性评估及区域划分，此部分综合城市人口自然增长率、性别比例及总抚养比评估人口发展可持续性，以此进行顾及空间约束的多要素地理分区，总结人口可持续发展区域化路径。</p><h5 id="121-数据获取与处理"><a class="markdownIt-Anchor" href="#121-数据获取与处理"></a> 1.2.1 数据获取与处理</h5><p>本作品将中国全域（除港澳台）的所有地市纳入研究范围，综合城市的人口和经济指标，如图2所示，所有城市被划分成0、1、2共三个等级，将属于同一省份同一等级的城市集合作为基本城市等级单元进行研究。<a href="https://imgse.com/i/pplzrjO"><div align=center><img src="https://s1.ax1x.com/2023/03/14/pplzrjO.jpg" alt="pplzrjO.jpg" /><br /></a><br />图2 城市等级分类及人口总量统计图<div align=left><br />本作品所使用的数据包含统计数据、文献数据及流动数据，主要数据来源为《中国统计年鉴》《中国2010年人口普查资料》《中国2020年人口普查资料》等官方统计资料及人口研究相关文献。其中，对获得的各省各等级城市单元多主题多时期等人口统计数据进行分类处理，以便后续机理分析与模型构建；使用文献研究法，综合文献与经验数据，归纳得出模型构建中的相关参数，如参与匹配概率、生育年龄阈值等。</p><h5 id="122-基于群体智慧与复杂系统方法的人口动态仿真建模"><a class="markdownIt-Anchor" href="#122-基于群体智慧与复杂系统方法的人口动态仿真建模"></a> 1.2.2 基于群体智慧与复杂系统方法的人口动态仿真建模</h5><p><strong>复杂系统</strong>泛指规模大、变量多、各部分关系和运动规律复杂或具有较大不确定性的动态系统，人口发展便是人口总体通过婚育行为决策、个人生命发展及人与环境交互等组成的动态复杂过程。目前，动态事件仿真建模主要有三种方法：离散事件、基于智能体以及系统动力学建模。在多方法仿真建模过程中，针对系统不同部分采用不同的建模方法进行详细描述，能够综合不同方法的优点，构建高效且可管理的模型，对现实世界复杂案例进行有效模拟。</p><p>本作品结合离散事件和基于智能体的方法，对中国人口动态发展过程进行时空仿真建模。一方面，如图3(a)所示，分别构建<strong>城市智能体</strong>和<strong>个人智能体</strong>，设置地理坐标、城市人口总数等城市属性以及年龄、性别等个人属性，关注智能体的个性行为及其之间的交互关系，城市智能体间的交互的现实表现为人口跨区域流动行为，个人智能体间的交互的现实表现为适龄异性间的匹配及婚育行为；另一方面，如图3(b)所示将每个个体的人生历程视为完整流程，基于未成年、成年、匹配、生育、死亡等人生状态构建系统流程，模拟个人对于婚育等的行为选择。即本作品采用离散事件模型描述个人智能体的内部流程，个人作为智能体显示在其所属城市范围内，城市作为智能体显示在中国全域范围内。<div align=center><a href="https://imgse.com/i/pplz6De"><img src="https://s1.ax1x.com/2023/03/14/pplz6De.jpg" alt="pplz6De.jpg" /></a><br />图3 基于复杂系统的人口发展过程建模示意图<div align=left></p><h5 id="123-时空立方体格局分析法与多要素地理分区分析法"><a class="markdownIt-Anchor" href="#123-时空立方体格局分析法与多要素地理分区分析法"></a> 1.2.3 时空立方体格局分析法与多要素地理分区分析法</h5><p>人口发展具有区域性、动态性、综合性，兼具了丰富的时间和空间内涵。而传统的空间分析并不能全面、深入地刻画中国城市人口变化及其未来发展，因此，需要从时空综合的视角对重要人口指标进行演变发展的规律性总结。</p><p><strong>时空立方体</strong>由若干个具有行、列和时间步长属性的立方图格组成，如图4(a)所示，通过创建时空立方体，可对动态发展数据进行可视化和分析。对于既定的行列位置可获得相应条柱时间序列，以此可分析变量时间变化差异。如图4(b)所示，基于同一位置可获取感兴趣变量的时序变化特征。基于多个目标要素的特征值，设置预期分类数量，可实现多元数据的聚类分析；顾及地理空间连续性，需要进一步对已经实现的聚类结果结构化，得到如图4©所示结果，整个研究区域被划分为三个分别空间连续的分区，从而实现多元数据的地理分区。<div align=center><a href="https://imgse.com/i/pplzcHH"><img src="https://s1.ax1x.com/2023/03/14/pplzcHH.jpg" alt="pplzcHH.jpg" /></a><br />图4 时空立方体格局与多要素地理分区分析过程<div align=left></p><h3 id="2-主要功能"><a class="markdownIt-Anchor" href="#2-主要功能"></a> 2 主要功能</h3><h4 id="21-多情景社会决策模拟与推演"><a class="markdownIt-Anchor" href="#21-多情景社会决策模拟与推演"></a> 2.1 多情景社会决策模拟与推演</h4><p>基于人口发展原始情景，调整社会经济、文化环境，通过提高就业率与工资水平、降低失业率、缩短工作时长、延长婚产假等改善工作环境，通过完善医疗设施、提升医疗水平等提升医疗条件，通过降低房价、提升住房公积金等缓解住房压力，以此构建三类生育友好情景，从而将影响个人生育决策及总体人口发展，为分析提供数据支持。如图5为人口仿真模型构建的部分逻辑图，社会情景的变动将直接影响个人行为选择，进而影响人口总体发展。<div align=center><a href="https://imgse.com/i/pplz48P"><img src="https://s1.ax1x.com/2023/03/14/pplz48P.jpg" alt="pplz48P.jpg" /></a><br />图5 模型构建逻辑图<div align=left></p><h4 id="22人口演变响应模式挖掘"><a class="markdownIt-Anchor" href="#22人口演变响应模式挖掘"></a> 2.2人口演变响应模式挖掘</h4><p>基于原始及多情景模拟过程，选取2020-2030十年间共120期人口发展指标数据，从人口发展演变过程与人口结构变化挖掘人口发展对不同情景的响应模式，并通过时空立方体及人口金字塔实现人口演变过程可视化。</p><h5 id="221-分情景人口时空演变规律"><a class="markdownIt-Anchor" href="#221-分情景人口时空演变规律"></a> 2.2.1 分情景人口时空演变规律</h5><p>基于模型预测结果，根据人口发展指标的时间序列创建多情景时空立方体，下如图6所示，各项指标均具有显著的空间异质性特征和邻近时空域中的自相关性特征，性别比例及劳动人口占比存在显著的时间异质性，且在不同情景下人口发展具有显著响应。</p><p>人口总量整体呈现“东多西少” 的空间特征，东部沿海及川渝地区持续存在人口总量热点；性别比例与地区性别偏好相关性强，地区差异显著但相关性强，各情景下均呈现西北-东南-东北“倒三角点状”性别比例热点，其中在医疗情景下西北地区预测结果高值聚集显著性更强；老龄人口占比总体呈现“东北高-西南低”的空间格局，存在东北及华北地区的老龄占比热点，老龄化问题严重，东北地区预计将成为新增老龄占比热点，而南方城市老龄化将得到一定程度缓解；劳动人口占比时间异质性显著，呈现西部-华中-东部沿海及东北的“H型”劳动力占比热点，云南、海南及广西等地区劳动人口占比将逐渐提升，激发地区活力，同时相较原始情景，住房情景下新疆地区高值聚集现象弱化，工作情景下新疆及东北地区劳动力占比高值聚集更显著，社会劳动力将更为充足。<div align=center><a href="https://imgse.com/i/pplz2Ed"><img src="https://s1.ax1x.com/2023/03/14/pplz2Ed.jpg" alt="pplz2Ed.jpg" /></a><br />图6 人口发展时空立方体（社会情景-人口发展指标）<div align=left></p><h5 id="222-人口结构动态变化趋势"><a class="markdownIt-Anchor" href="#222-人口结构动态变化趋势"></a> 2.2.2 人口结构动态变化趋势</h5><p>年龄结构是人口发展和社会劳动生产的关键因素，会随着人口发展动态变化，为清晰反映人口结构情况，选取多时段全国总体人口预测结果，并进行多情景分析。如图7所示，横向为同一时段中不同情景预测结果，纵向为同一情景下不同时段人口结构预测。从时间发展角度看，受上世纪70年代“计划生育”政策影响，2023年41-50岁人口占比小，且中国人口总体老龄化程度加深；而随着近年来二孩、三孩政策的落实，生育潜力释放，青少年占比逐步升高，并具有继续增加的趋势，老龄人口占比短暂上升后保持相对稳定状态；此外在各类情景下，人口结构整体将更加趋于稳定，各年龄占比较为均衡，更有利于社会发展。从社会情景变动视角看，在工作环境改善、医疗条件提升、购房压力减小等生育友好情景下，青少年人口增长趋势更加显著，生育意愿提升。人口发展对外部环境变化响应显著，生育政策调整及社会环境优化能够缓解人口老龄化问题，促进人口长期均衡发展。<div align=center><a href="https://imgse.com/i/pplzW4I"><img src="https://s1.ax1x.com/2023/03/14/pplzW4I.jpg" alt="pplzW4I.jpg" /></a><br />图7 多情景下人口金字塔结构动态变化预测图<div align=left></p><h4 id="23区域视角下人口发展可持续性综合评价"><a class="markdownIt-Anchor" href="#23区域视角下人口发展可持续性综合评价"></a> 2.3区域视角下人口发展可持续性综合评价</h4><p>人口可持续发展要求人口能够源源不断地适度增长，考虑各项人口指标，自然增长率反映地区人口总量变化幅度及发展趋势；性别比例为男性人数与女性之比，对婚姻及人口再生产具有重要意义，性别比失衡将导致婚姻挤压等问题，阻碍人口健康发展；总抚养比为非劳动人口与劳动人口的比值，反映劳动人口抚养负担及社会年龄结构，过重的负担将对生育产生负面影响。基于上述指标，从<strong>总量平稳性</strong>、<strong>性别平衡性</strong>、<strong>年龄均衡性</strong>三个角度综合评价人口发展可持续性，并进行多情景下顾及空间约束的多要素地理分区，探索区域现阶段人口可持续发展相似性，为区域人口决策规划提供建议。</p><p>基于多情景模拟结果，计算各地市三项人口指标，并调整设定聚类数进行多要素地理分区，如图8(a)-(d)所示，中国全域可基本划分为九大人口发展区域，按照自然增长率可分为增长、平稳与衰退三大类型，综合性别比例及总抚养比评估未来短期生育及人口发展潜力，可分为潜力型、稳定型及隐患型，在原始情景中，III区域包含上海、江苏、山东等省市部分地区，其三项指标均较低，属于衰退-潜力型，人口增长缓慢或出现负增长，但性别较为平衡且劳动人口抚养压力小，生育潜力较大，通过适当引导即可实现人口增长。在各类生育友好情景下，区域人口可持续类型发生变化，人口发展可持续性区域划分结果存在显著差异，表明社会情景动对人口发展区域相似性有重大影响。结合人口发展类型及具体指标情况，地区可根据发展<a href="https://imgse.com/i/pplzhCt"><div align=center><img src="https://s1.ax1x.com/2023/03/14/pplzhCt.jpg" alt="pplzhCt.jpg" /></a><br />图8 多情景人口发展可持续评价区域化结果图<div align=left></p><h3 id="3-作品特点"><a class="markdownIt-Anchor" href="#3-作品特点"></a> 3 作品特点</h3><h4 id="31-仿真性"><a class="markdownIt-Anchor" href="#31-仿真性"></a> 3.1 仿真性</h4><p>在本作品中，人被视作拥有特有属性和情感智慧的真实个体，个体的行为决策构成了整体的共享决策，基于此构建的模型自下而上地还原了人类个体的生命进程和人类社会总体发展的真实情境。</p><h4 id="32-社会现实性"><a class="markdownIt-Anchor" href="#32-社会现实性"></a> 3.2 社会现实性</h4><p>本作品面向人口问题进行仿真建模，并设置多个民生关切的现实情景，通过政策模拟与推演来探索人口响应规律，为国家战略制定与调整提供启示性参考，具有丰富的现实意义与应用价值。</p><h4 id="32-直观可视性"><a class="markdownIt-Anchor" href="#32-直观可视性"></a> 3.2 直观可视性</h4><p>作品中运用的时空立方体2D及3D可视化技术将时空数据用多维立体的形式展现出来，直观地展现了时间序列的变化趋势，便于使用者厘清时空数据的结构、变化趋势和时空分异特征。</p><h3 id="4-意义及展望"><a class="markdownIt-Anchor" href="#4-意义及展望"></a> 4 意义及展望</h3><p>本作品为科学把握人口发展规律，促进人口可持续发展提供参考。政策鼓励与国民福利保障方面，优化生育政策，加强生育家庭医保、购房租房等福利保障；经济支持与婚育压力缓解方面，完善假期用工成本分担机制，提高居民收入，延长假期，缓解积蓄少与时间紧带来的生育压力；在设施健全与公共服务提质方面，完善住房、医疗等基础设施条件，加快发展普惠托育服务体系，构建全面生育友好的社会环境。</p><p>后续研究拟深入挖掘个体交互行为，拓宽模型适用范围以用于解决其他人口问题；在现有分析基础上，将进一步探索基于人口动态发展时间序列的聚类分析，并顾及空间约束进行地理分区，为国家政策实施与管理提供便利。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2022ESRI大赛参赛作品（一等奖）。&lt;/p&gt;</summary>
    
    
    
    <category term="作品" scheme="https://atffang.github.io/categories/%E4%BD%9C%E5%93%81/"/>
    
    
  </entry>
  
  <entry>
    <title>VS2019-AnalysisService部署数据挖掘无法连接服务器的问题</title>
    <link href="https://atffang.github.io/2023/03/13/VS2019-AnalysisService%E9%83%A8%E7%BD%B2%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://atffang.github.io/2023/03/13/VS2019-AnalysisService%E9%83%A8%E7%BD%B2%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2023-03-13T07:51:36.000Z</published>
    <updated>2023-03-24T09:00:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>VS2019-AnalysisService挖掘SQLServer2012数据库时，无法连接本地服务器的问题</p><span id="more"></span><p>  起因是使用Visual Studio2019的Analysis Service模块，对SQLServer2012数据库进行挖掘时，部署后软件报错：无法连接localhost服务器，遂找了各种资料，最终综合两个方法解决了问题。<br />首先，在Visual Studio2019挖掘项目的属性-部署中，可以看到服务器名为localhost，即本台电脑。<br />但在SQLServer中，服务器名却为：<br /><a href="https://imgse.com/i/ppQwGut"><div align=center><img src="https://s1.ax1x.com/2023/03/13/ppQwGut.md.jpg" alt="ppQwGut.md.jpg" /></a><div align=left><br />即localhost+数据库实例名，因此，将Visual Studio2019中的服务器也改为相同的名称：<br /><a href="https://imgse.com/i/ppQwJDP"><div align=center><img src="https://s1.ax1x.com/2023/03/13/ppQwJDP.md.jpg" alt="ppQwJDP.md.jpg" /></a><div align=left><br />替换后，我的项目部署时仍然报错：缺少用户名NT SERVICE\MSOLAP$SQLSERVE。此时只需要在SQLServer中的安全性-登录名中，新建该登录名，并赋予其一定的权限即可。<br /><a href="https://imgse.com/i/ppQwYHf"><div align=center><img src="https://s1.ax1x.com/2023/03/13/ppQwYHf.md.jpg" alt="ppQwYHf.md.jpg" /></a><div align=left></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;VS2019-AnalysisService挖掘SQLServer2012数据库时，无法连接本地服务器的问题&lt;/p&gt;</summary>
    
    
    
    <category term="或许用得到的tips" scheme="https://atffang.github.io/categories/%E6%88%96%E8%AE%B8%E7%94%A8%E5%BE%97%E5%88%B0%E7%9A%84tips/"/>
    
    
  </entry>
  
</feed>
