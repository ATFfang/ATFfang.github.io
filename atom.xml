<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tianyao&#39; s BLOG</title>
  
  <subtitle>Tianyao</subtitle>
  <link href="https://atffang.github.io/atom.xml" rel="self"/>
  
  <link href="https://atffang.github.io/"/>
  <updated>2025-06-29T08:43:06.927Z</updated>
  <id>https://atffang.github.io/</id>
  
  <author>
    <name>Fang Tianyao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从0开始学java 01 ：委托与策略模式</title>
    <link href="https://atffang.github.io/2025/06/29/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6java2/"/>
    <id>https://atffang.github.io/2025/06/29/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6java2/</id>
    <published>2025-06-29T07:46:42.000Z</published>
    <updated>2025-06-29T08:43:06.927Z</updated>
    
    <content type="html"><![CDATA[<p>生活所迫呀。</p><span id="more"></span><p>上一期中，我们通过接口（interface）和抽象类（abstract class）理解了如何定义行为规范、如何实现多态等等。然而，在传统的继承方式中，子类通过覆盖方法来改变行为，但这种方式在面对行为切换、行为复用时显得僵硬。因此，我们希望有一种方式，不用继承，也能改变对象的行为，更适合“插件式”的行为结构。</p><p>这个时候，就需要一种新的模式<strong>委托</strong>，把行为交给另一个对象来完成。</p><p>首先，我们需要先定义一个接口，来规范要干的事情</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FlyBehavior</span>&#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现接口的类必须要实现fly这一个动作，我们定义一个实现FlyBehavior接口的类FlyWithWings，来实现有翅膀可以飞的动作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlyWithWings</span> <span class="keyword">implements</span> <span class="title class_">FlyBehavior</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;fly!!!!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再定义一个实现FlyBehavior接口的类FlyNoWings，来实现没翅膀不能飞的动作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlyNoWings</span> <span class="keyword">implements</span> <span class="title class_">FlyBehavior</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;cannot fly!!!!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义玩接口和接口的实现之后，我们定义了两个飞行动作，现在，我们来定义实现飞行动作的对象。<br />我们定义一个鸭子抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Duck</span>&#123;</span><br><span class="line"><span class="comment">// 声明引用变量</span></span><br><span class="line">FlyBehavior flyBehavior;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Duck</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类的函数，子类必须实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 委托给行为类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performFly</span><span class="params">()</span> &#123;</span><br><span class="line">flyBehavior.fly();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先声明了一个FlyBehavior类型的引用变量，表示鸭子的飞行行为，当调用performFly()时，实际上调用的是flyBehavior对象的fly()方法。</p><p>好的，那么我们可以新建一个子类了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MallardDuck</span> <span class="keyword">extends</span> <span class="title class_">Duck</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MallardDuck</span><span class="params">()</span>&#123;</span><br><span class="line">flyBehavior = <span class="keyword">new</span> <span class="title class_">FlyNoWings</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;im MallardDuck&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 MallardDuck 构造函数里，给继承自父类的 flyBehavior 变量赋值为 new FlyWithWings() 实例。这样调用 performFly() 就会调用 FlyWithWings 类的 fly() 方法，实现“飞”的动作。<br />入口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunDuck</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Duck</span> <span class="variable">mallard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MallardDuck</span>();</span><br><span class="line">mallard.performFly();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出： cannot fly!!!</p><p><strong>但是</strong>，这样还是不够灵活，我们还想要让鸭子具有动态行为。为了实现这个目的，我们只需要在抽象类中加入一个设定方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Duck</span>&#123;</span><br><span class="line">FlyBehavior flyBehavior;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Duck</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performFly</span><span class="params">()</span> &#123;</span><br><span class="line">flyBehavior.fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新加入的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlyBehavior</span><span class="params">(FlyBehavior fb)</span>&#123;</span><br><span class="line">flyBehavior = fb;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后，在实现时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunDuck</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Duck</span> <span class="variable">mallard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MallardDuck</span>();</span><br><span class="line">mallard.performFly();</span><br><span class="line">mallard.setFlyBehavior(<span class="keyword">new</span> <span class="title class_">FlyWithWings</span>());</span><br><span class="line">mallard.performFly();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即可动态设定其行为，输出为：<br />cannot fly!!!<br />fly!!!</p><p><strong>这种通过组合行为接口的方式实现动态切换行为的设计模式，称为策略模式（Strategy Pattern），是面向对象设计中的重要思想</strong>。<br /><img src="https://atffang.github.io/2025/06/29/从0开始学java2/策略模式.png"/></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;生活所迫呀。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>美团商业分析精英大赛亚军</title>
    <link href="https://atffang.github.io/2025/06/25/%E7%BE%8E%E5%9B%A2%E5%95%86%E4%B8%9A%E5%88%86%E6%9E%90%E7%B2%BE%E8%8B%B1%E5%A4%A7%E8%B5%9B%E4%BA%9A%E5%86%9B/"/>
    <id>https://atffang.github.io/2025/06/25/%E7%BE%8E%E5%9B%A2%E5%95%86%E4%B8%9A%E5%88%86%E6%9E%90%E7%B2%BE%E8%8B%B1%E5%A4%A7%E8%B5%9B%E4%BA%9A%E5%86%9B/</id>
    <published>2025-06-25T01:29:59.000Z</published>
    <updated>2025-06-25T02:13:11.955Z</updated>
    
    <content type="html"><![CDATA[<p>一起聚——面向聚餐场景的智能餐厅推荐系统</p><span id="more"></span><p>从1206支队伍里杀到了第二，获此殊荣确实在我们意料之外。感谢美团提供的机会与money。<br /><img src="https://atffang.github.io/2025/06/25/美团商业分析精英大赛亚军/决赛-终稿2.5_01.png"/><br /><img src="https://atffang.github.io/2025/06/25/美团商业分析精英大赛亚军/决赛-终稿2.5_02.png"/><br /><img src="https://atffang.github.io/2025/06/25/美团商业分析精英大赛亚军/决赛-终稿2.5_03.png"/><br /><img src="https://atffang.github.io/2025/06/25/美团商业分析精英大赛亚军/决赛-终稿2.5_04.png"/><br /><img src="https://atffang.github.io/2025/06/25/美团商业分析精英大赛亚军/决赛-终稿2.5_05.png"/><br /><img src="https://atffang.github.io/2025/06/25/美团商业分析精英大赛亚军/决赛-终稿2.5_06.png"/><br /><img src="https://atffang.github.io/2025/06/25/美团商业分析精英大赛亚军/决赛-终稿2.5_07.png"/><br /><img src="https://atffang.github.io/2025/06/25/美团商业分析精英大赛亚军/决赛-终稿2.5_08.png"/><br /><img src="https://atffang.github.io/2025/06/25/美团商业分析精英大赛亚军/决赛-终稿2.5_09.png"/><br /><img src="https://atffang.github.io/2025/06/25/美团商业分析精英大赛亚军/决赛-终稿2.5_10.png"/><br /><img src="https://atffang.github.io/2025/06/25/美团商业分析精英大赛亚军/决赛-终稿2.5_11.png"/><br /><img src="https://atffang.github.io/2025/06/25/美团商业分析精英大赛亚军/决赛-终稿2.5_12.png"/><br /><img src="https://atffang.github.io/2025/06/25/美团商业分析精英大赛亚军/决赛-终稿2.5_13.png"/><br /><img src="https://atffang.github.io/2025/06/25/美团商业分析精英大赛亚军/决赛-终稿2.5_14.png"/></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一起聚——面向聚餐场景的智能餐厅推荐系统&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>ijgis online</title>
    <link href="https://atffang.github.io/2025/06/14/online%E5%BC%80%E9%A6%99%E6%A7%9F/"/>
    <id>https://atffang.github.io/2025/06/14/online%E5%BC%80%E9%A6%99%E6%A7%9F/</id>
    <published>2025-06-14T01:59:02.000Z</published>
    <updated>2025-06-14T02:11:11.658Z</updated>
    
    <content type="html"><![CDATA[<p>祝贺舒姐的ijgis上线。</p><span id="more"></span><p>从idea到online，前前后后花了一年多的时间，我在其中也只能提供一些微薄的帮助。作者真的太不容易了。<br />虽然现在没有机会主导撰写论文，但看到朋友的成功也会宽慰不少，共勉吧。</p><p>Xu, Y., Gong, Z., Fang, T., Zhang, H., &amp; Tang, G. (2025). Intercity human dynamics during holidays through the lens of travel movement–intention interactions in the hybrid physical–virtual space. <em>International Journal of Geographical Information Science</em>, 1–29. <a href="https://doi.org/10.1080/13658816.2025.2515200">https://doi.org/10.1080/13658816.2025.2515200</a></p><p><strong>Abstract</strong>:<br />Intercity human dynamics has involved increasing interactions between the physical world and cyberspace with the boom of the Internet and social media, expanding traditional intercity activities from a single dimension of physical space to a multidimensional hybrid space. Revealing the dynamics of intercity activities in a hybrid physical–virtual space requires considering interactions between human activities in both the physical world and cyberspace. However, existing studies often overlook cross-space interactions, failing to adequately model interactions between virtual and physical spaces in terms of the network structure and spatial effects. To address these gaps, this study investigates intercity human dynamics through travel movement–intention interactions. A multilayer network framework is proposed to represent the hybrid space, where travel movement–intention interactions can be conceptualized and measured. Using travel and search flows in China during the ‘Labor Day’ holiday periods in a three-year period of the pandemic, we demonstrate the proposed approach’s utility through an analysis of city centrality of multilayer networks. Results find that travel movement–intention interactions exhibit dynamic patterns that vary with city size and geographic distance. This approach is broadly applicable to studies of hybrid physical–virtual spaces, aiding the evaluation of human dynamics beyond intercity activities.</p><p>代码开源至：<br /><a href="https://doi.org/10.6084/m9.figshare.27929466">https://doi.org/10.6084/m9.figshare.27929466</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;祝贺舒姐的ijgis上线。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>从0开始学java 01 ：java面向对象的基础知识</title>
    <link href="https://atffang.github.io/2025/06/05/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6java1/"/>
    <id>https://atffang.github.io/2025/06/05/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6java1/</id>
    <published>2025-06-05T11:54:41.000Z</published>
    <updated>2025-06-29T07:47:09.474Z</updated>
    
    <content type="html"><![CDATA[<p>生活所迫呀。</p><span id="more"></span><p>由于生活所迫，我宣布我现在开始学java。</p><h3 id="第-1-章类与对象实战"><a class="markdownIt-Anchor" href="#第-1-章类与对象实战"></a> 第 1 章：类与对象实战</h3><h4 id="11-定义类-属性-方法"><a class="markdownIt-Anchor" href="#11-定义类-属性-方法"></a> 1.1 定义类、属性、方法</h4><p>在 Java 中，<strong>类（class）是对象的模板</strong>，<strong>对象（object）是类的实例</strong>。类中可以包含：</p><ul><li>属性（字段、变量）：描述对象的特征</li><li>方法：描述对象的行为<br />如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="comment">// 属性（成员变量）</span></span><br><span class="line">String name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法（成员方法）</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-创建对象并调用方法"><a class="markdownIt-Anchor" href="#12-创建对象并调用方法"></a> 1.2 创建对象并调用方法</h4><p>创建对象用关键字 <code>new</code>。创建后可以访问属性或调用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();</span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.name = <span class="string">&quot;fty&quot;</span>;</span><br><span class="line">p.age = <span class="number">23</span>;</span><br><span class="line">p.sayHellow();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13-构造方法编写与重载"><a class="markdownIt-Anchor" href="#13-构造方法编写与重载"></a> 1.3 构造方法编写与重载</h4><p><strong>构造方法（Constructor）</strong> 是在 <code>new</code> 一个对象时调用的方法，用来初始化属性。</p><ul><li>构造方法名必须与类名相同</li><li>构造方法可以有多个（重载）<br />如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">name = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">age = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参构造方法（重载）</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14-使用-this-关键字"><a class="markdownIt-Anchor" href="#14-使用-this-关键字"></a> 1.4 使用 <code>this</code> 关键字</h4><p><code>this</code> 是 Java 中的一个关键字，代表“当前对象”。<br />用在两个场景中：</p><ol><li>解决<strong>方法参数名和属性名冲突</strong></li><li>在类的方法中调用该对象自己的属性或方法<br />如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">showInfo</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="built_in">this</span>.name + <span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h3 id="第-2-章封装与访问控制实践"><a class="markdownIt-Anchor" href="#第-2-章封装与访问控制实践"></a> 第 2 章：封装与访问控制实践</h3><h4 id="21-使用-private-属性封装数据"><a class="markdownIt-Anchor" href="#21-使用-private-属性封装数据"></a> 2.1 使用 <code>private</code> 属性封装数据</h4><p>在 Java 中，<strong>封装（Encapsulation）</strong> 是把对象的属性隐藏起来，只通过方法进行访问和修改。<br />这通常通过把属性设为 <code>private</code> 实现，防止外部直接访问。<br />如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;   <span class="comment">// 私有属性，外部无法直接访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">introduce</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hi, my name is &quot;</span> + name + <span class="string">&quot;, I’m &quot;</span> + age + <span class="string">&quot; years old.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="comment">// ❌ 不能直接访问私有属性</span></span><br><span class="line">        <span class="comment">// p.name = &quot;Tom&quot;;  // 编译错误！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="22-编写-getter-setter"><a class="markdownIt-Anchor" href="#22-编写-getter-setter"></a> 2.2 编写 Getter / Setter</h4><p><strong>Getter/Setter</strong> 是访问私有属性的“通道”：</p><ul><li><code>getXxx()</code> 获取属性值</li><li><code>setXxx()</code> 设置属性值<br />如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="comment">// 可以加判断逻辑，防止非法年龄</span></span><br><span class="line">        <span class="keyword">if</span> (age &gt;= <span class="number">0</span> &amp;&amp; age &lt;= <span class="number">150</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Invalid age.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p.setName(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        p.setAge(<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + p.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;Age: &quot;</span> + p.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="23-类的访问控制修饰符应用"><a class="markdownIt-Anchor" href="#23-类的访问控制修饰符应用"></a> 2.3 类的访问控制修饰符应用</h4><p>Java 提供四种访问修饰符控制类和类成员的访问范围：</p><table><thead><tr><th>修饰符</th><th>类内</th><th>同包</th><th>子类</th><th>其他包</th></tr></thead><tbody><tr><td><code>private</code></td><td>✅</td><td>❌</td><td>❌</td><td>❌</td></tr><tr><td><code>default</code>（无修饰）</td><td>✅</td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td><code>protected</code></td><td>✅</td><td>✅</td><td>✅</td><td>❌</td></tr><tr><td><code>public</code></td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>如：</td><td></td><td></td><td></td><td></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> <span class="string">&quot;Mammal&quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">String</span> <span class="variable">sound</span> <span class="operator">=</span> <span class="string">&quot;Growl&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">color</span> <span class="operator">=</span> <span class="string">&quot;Brown&quot;</span>;         <span class="comment">// default</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal info: &quot;</span> + type + <span class="string">&quot;, &quot;</span> + sound + <span class="string">&quot;, &quot;</span> + color + <span class="string">&quot;, &quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        System.out.println(a.type);   <span class="comment">// ✅ public</span></span><br><span class="line">        System.out.println(a.sound);  <span class="comment">// ✅ 同包可访问 protected</span></span><br><span class="line">        System.out.println(a.color);  <span class="comment">// ✅ 同包可访问 default</span></span><br><span class="line">        <span class="comment">// System.out.println(a.age); // ❌ private，不能访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h3 id="第-3-章继承语法与调用关系"><a class="markdownIt-Anchor" href="#第-3-章继承语法与调用关系"></a> 第 3 章：继承语法与调用关系</h3><h4 id="31-使用-extends-实现继承"><a class="markdownIt-Anchor" href="#31-使用-extends-实现继承"></a> 3.1 使用 <code>extends</code> 实现继承</h4><p>ava 使用 <code>extends</code> 关键字让一个类继承另一个类的属性和方法。<br />✅ 继承的作用：</p><ul><li>子类拥有父类的<strong>非 private 成员</strong>（属性和方法）</li><li>避免重复代码</li><li>体现「是一种（is-a）」的关系<br />如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal is eating...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Dog is barking...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        dog.eat();  <span class="comment">// 继承自 Animal</span></span><br><span class="line">        dog.bark(); <span class="comment">// 自己的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="32-子类调用父类构造器与方法"><a class="markdownIt-Anchor" href="#32-子类调用父类构造器与方法"></a> 3.2 子类调用父类构造器与方法</h4><ul><li>构造器<strong>不能继承</strong>，但可以通过 <code>super()</code> 调用父类构造器。</li><li>子类实例化时，<strong>默认会先调用父类的无参构造器</strong>。<br />如：</li></ul><h5 id="321-父类有无参构造"><a class="markdownIt-Anchor" href="#321-父类有无参构造"></a> 3.2.1 父类有无参构造</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal constructor called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog constructor called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="322-父类只有有参构造时子类必须显式调用"><a class="markdownIt-Anchor" href="#322-父类只有有参构造时子类必须显式调用"></a> 3.2.2  父类只有有参构造时，子类必须显式调用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;Buddy&quot;</span>); <span class="comment">// 必须显式调用父类构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Dog created&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="33-使用-super-调用父类成员"><a class="markdownIt-Anchor" href="#33-使用-super-调用父类成员"></a> 3.3 使用 <code>super</code> 调用父类成员</h4><ul><li><code>super.变量名</code>：访问父类的属性</li><li><code>super.方法名()</code>：调用父类的方法<br />通常在<strong>子类重写父类方法</strong>时，用 <code>super</code> 调用原始实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal moves&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.move(); <span class="comment">// 调用父类方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Bird flies&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="34-子类方法重写override"><a class="markdownIt-Anchor" href="#34-子类方法重写override"></a> 3.4 子类方法重写（<code>@Override</code>）</h4><p>当子类对父类已有方法进行<strong>重新实现</strong>，称为“方法重写”或“覆盖”。<br />必须：</p><ul><li>方法名、参数列表相同</li><li>使用 <code>@Override</code> 注解（推荐）<br />如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal makes a sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat meows&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(); <span class="comment">// 向上转型</span></span><br><span class="line">        a.sound();            <span class="comment">// 输出 &quot;Cat meows&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然类型是 <code>Animal</code>，但调用的是 <code>Cat</code> 的实现 —— 这就是<strong>多态</strong>的表现。</p><hr /><h3 id="第-4-章方法重载与重写"><a class="markdownIt-Anchor" href="#第-4-章方法重载与重写"></a> 第 4 章：方法重载与重写</h3><h4 id="41-方法重载实现"><a class="markdownIt-Anchor" href="#41-方法重载实现"></a> 4.1 方法重载实现</h4><p><strong>方法重载</strong>是指在<strong>同一个类中</strong>，方法名相同，但参数列表不同（个数或类型）。其特点为：</p><ul><li>与返回值无关</li><li>是编译时多态的一种形式<br />如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calculator</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">        System.out.println(c.add(<span class="number">1</span>, <span class="number">2</span>));           <span class="comment">// int + int</span></span><br><span class="line">        System.out.println(c.add(<span class="number">1.5</span>, <span class="number">2.5</span>));       <span class="comment">// double + double</span></span><br><span class="line">        System.out.println(c.add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));        <span class="comment">// 三个 int</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="42-方法重写规则"><a class="markdownIt-Anchor" href="#42-方法重写规则"></a> 4.2 方法重写规则</h4><p><strong>方法重写</strong>发生在<strong>继承结构中</strong>，子类重写父类已有方法，必须满足以下规则：</p><table><thead><tr><th>要求</th><th>内容</th></tr></thead><tbody><tr><td>方法名</td><td>必须相同</td></tr><tr><td>参数列表</td><td>必须相同</td></tr><tr><td>返回值类型</td><td>必须相同或子类型</td></tr><tr><td>访问权限</td><td>不能低于父类</td></tr><tr><td>抛出异常</td><td>不能抛出更多的受检异常</td></tr><tr><td>标记</td><td>建议使用 <code>@Override</code> 注解</td></tr><tr><td>如：</td><td></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog barks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        a.makeSound(); <span class="comment">// 输出：Dog barks</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="43-重写-vs-重载对比实战"><a class="markdownIt-Anchor" href="#43-重写-vs-重载对比实战"></a> 4.3 重写 vs 重载对比实战</h4><table><thead><tr><th>特性</th><th>重载（Overload）</th><th>重写（Override）</th></tr></thead><tbody><tr><td>定义位置</td><td>同一个类中</td><td>子类与父类之间</td></tr><tr><td>方法名</td><td>相同</td><td>相同</td></tr><tr><td>参数列表</td><td>必须不同</td><td>必须相同</td></tr><tr><td>返回值</td><td>可不同（不构成重载）</td><td>必须相同或是子类类型</td></tr><tr><td>访问修饰符</td><td>无限制</td><td>子类不能比父类更严格</td></tr><tr><td>多态</td><td>编译时多态</td><td>运行时多态</td></tr></tbody></table><hr /><h3 id="第-5-章多态与父类引用"><a class="markdownIt-Anchor" href="#第-5-章多态与父类引用"></a> 第 5 章：多态与父类引用</h3><h4 id="51-父类引用指向子类对象"><a class="markdownIt-Anchor" href="#51-父类引用指向子类对象"></a> 5.1 父类引用指向子类对象</h4><p>在Java中，<strong>父类类型的引用变量</strong>可以指向<strong>子类对象</strong>。这称为“向上转型”（Upcasting），是多态的基础。<br />如上面提到的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br></pre></td></tr></table></figure><ul><li>这里<code>a</code>的类型是<code>Animal</code>，但实际引用的是<code>Dog</code>对象。</li><li>父类引用只能访问父类中声明的成员（变量和方法）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog barks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wagTail</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog wags tail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();  <span class="comment">// 父类引用指向子类对象</span></span><br><span class="line">        a.makeSound();         <span class="comment">// 调用的是子类重写的方法</span></span><br><span class="line">        <span class="comment">// a.wagTail();        // 编译错误，父类引用不能调用子类独有方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="52-多态方法调用效果"><a class="markdownIt-Anchor" href="#52-多态方法调用效果"></a> 5.2 多态方法调用效果</h4><p>虽然引用类型是父类，但<strong>方法调用执行的是子类重写后的版本</strong>，体现“运行时绑定”。这让程序更加灵活，接口统一，具体实现多样。</p><ul><li>调用<strong>方法</strong>时，会执行子类重写的方法（如果有）；</li><li>访问<strong>成员变量</strong>时，访问的是引用类型所属类的变量（不支持多态）；<br />如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Animal&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Cat&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        System.out.println(a.name);  <span class="comment">// 输出 &quot;Animal&quot;</span></span><br><span class="line">        a.printName();               <span class="comment">// 输出 &quot;Cat&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="53-多态与数组-集合应用"><a class="markdownIt-Anchor" href="#53-多态与数组-集合应用"></a> 5.3 多态与数组、集合应用</h4><p>多态也可以与数组和集合结合使用，方便统一管理不同子类对象。<br />如：</p><h5 id="531-多态数组"><a class="markdownIt-Anchor" href="#531-多态数组"></a> 5.3.1 多态数组</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Animal[] animals = <span class="keyword">new</span> <span class="title class_">Animal</span>[<span class="number">3</span>];</span><br><span class="line">animals[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">animals[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">animals[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Animal a : animals) &#123;</span><br><span class="line">    a.makeSound();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="532-多态集合"><a class="markdownIt-Anchor" href="#532-多态集合"></a> 5.3.2 多态集合</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line">List&lt;Animal&gt; animalList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">animalList.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">animalList.add(<span class="keyword">new</span> <span class="title class_">Cat</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Animal a : animalList) &#123;</span><br><span class="line">    a.makeSound();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h3 id="第-6-章object-类与常用方法"><a class="markdownIt-Anchor" href="#第-6-章object-类与常用方法"></a> 第 6 章：<code>Object</code> 类与常用方法</h3><h4 id="61-tostring-方法重写"><a class="markdownIt-Anchor" href="#61-tostring-方法重写"></a> 6.1 <code>toString()</code> 方法重写</h4><p><code>toString()</code> 是 <code>Object</code> 类中定义的方法，所有Java类默认继承。 默认实现返回的是对象的<strong>类名 + @ + 哈希码</strong>，不够直观。 重写 <code>toString()</code> 让对象打印时更具可读性，常用于调试和日志。<br />如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;name=&#x27;&quot;</span> + name + <span class="string">&quot;&#x27;, age=&quot;</span> + age + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br><span class="line">        System.out.println(p);  <span class="comment">// 自动调用 toString()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="62-equals-比较对象内容"><a class="markdownIt-Anchor" href="#62-equals-比较对象内容"></a> 6.2 <code>equals()</code> 比较对象内容</h4><p>默认 <code>equals()</code> 方法是比较两个对象的<strong>引用地址</strong>（即是否是同一个对象）, 重写 <code>equals()</code> 方法，通常基于对象的<strong>属性内容</strong>进行比较。常与 <code>hashCode()</code> 一起重写，以保证集合中的正确行为。<br />如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数和 getter/setter 省略</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 比较同一个对象</span></span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span> || getClass() != obj.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 类型检查</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">other</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line">        <span class="keyword">return</span> age == other.age &amp;&amp; (name != <span class="literal">null</span> ? name.equals(other.name) : other.name == <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        System.out.println(p1.equals(p2));  <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="63-clone-方法与浅拷贝"><a class="markdownIt-Anchor" href="#63-clone-方法与浅拷贝"></a> 6.3 <code>clone()</code> 方法与浅拷贝</h4><p><code>clone()</code> 是 <code>Object</code> 中的一个方法，用来复制对象。 默认实现是<strong>浅拷贝</strong>：基本类型拷贝，引用类型只复制引用。 需要实现 <code>Cloneable</code> 接口并重写 <code>clone()</code>，否则会抛出异常。浅拷贝对于对象中有引用类型字段时，拷贝后两个对象会共享同一个引用字段。<br />如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String city)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Address <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (Address) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter/setter 省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, Address address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Person <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">cloned</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">        <span class="comment">// 浅拷贝：address对象引用被复制，两个Person共享同一个Address对象</span></span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter/setter 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Person</code> 的 <code>clone()</code> 是浅拷贝，拷贝的 <code>Person</code> 对象和原对象的 <code>address</code> 指向同一个 <code>Address</code> 实例。</li><li>若需完全拷贝（深拷贝），需要对引用字段也进行 <code>clone()</code>。</li></ul><hr /><h3 id="第-7-章static-与-final-关键字用法"><a class="markdownIt-Anchor" href="#第-7-章static-与-final-关键字用法"></a> 第 7 章：<code>static</code> 与 <code>final</code> 关键字用法</h3><h4 id="71-静态属性与静态方法"><a class="markdownIt-Anchor" href="#71-静态属性与静态方法"></a> 7.1 静态属性与静态方法</h4><ul><li><strong><code>static</code></strong> 修饰的成员属于类本身，而不是某个对象。</li><li>静态属性（变量）在内存中只有一份，所有对象共享。</li><li>静态方法可以直接通过类名调用，无需创建实例。</li><li>静态方法中不能访问非静态成员（因为非静态属于对象）。<br />如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 静态变量，所有对象共享</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Counter</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;  <span class="comment">// 每创建一个对象，count自增</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;  <span class="comment">// 静态方法，访问静态变量</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line">        System.out.println(Counter.getCount());  <span class="comment">// 输出 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="72-静态代码块"><a class="markdownIt-Anchor" href="#72-静态代码块"></a> 7.2 静态代码块</h4><ul><li>静态代码块用于类加载时执行一次的初始化操作。</li><li>适合做复杂的静态变量初始化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String ENV;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> MAX_USERS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ENV = <span class="string">&quot;production&quot;</span>;</span><br><span class="line">        MAX_USERS = <span class="number">1000</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Config 类被加载，静态代码块执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Config.ENV);       <span class="comment">// &quot;production&quot;</span></span><br><span class="line">        System.out.println(Config.MAX_USERS); <span class="comment">// 1000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：静态代码块只执行一次，且在类被首次加载时执行。</p><h4 id="73-final-类-方法-变量使用"><a class="markdownIt-Anchor" href="#73-final-类-方法-变量使用"></a> 7.3 <code>final</code> 类、方法、变量使用</h4><p><code>final</code> 可以修饰变量、方法、类，含义不同：</p><table><thead><tr><th>用法</th><th>说明</th></tr></thead><tbody><tr><td>final 变量</td><td>常量，一旦赋值不可更改</td></tr><tr><td>final 方法</td><td>不可被子类重写</td></tr><tr><td>final 类</td><td>不能被继承的类（比如 <code>String</code> 类）</td></tr><tr><td>如：</td><td></td></tr></tbody></table><h5 id="731-final变量"><a class="markdownIt-Anchor" href="#731-final变量"></a> 7.3.1 final变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constants</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14159</span>;  <span class="comment">// 常量，命名规范全部大写</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// PI = 3.14;  // 编译错误，final变量不可修改</span></span><br><span class="line">        System.out.println(Constants.PI);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="732-final方法"><a class="markdownIt-Anchor" href="#732-final方法"></a> 7.3.2 final方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent final method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="comment">// public void show() &#123;  // 编译错误，final方法不能被重写</span></span><br><span class="line">    <span class="comment">//     System.out.println(&quot;Child override&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="733-final类"><a class="markdownIt-Anchor" href="#733-final类"></a> 7.3.3 final类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Utility</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">help</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Helping...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class ExtendedUtility extends Utility &#123;  // 编译错误，final类不能被继承</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><hr /><h3 id="第-8-章抽象类与接口"><a class="markdownIt-Anchor" href="#第-8-章抽象类与接口"></a> 第 8 章：抽象类与接口</h3><h4 id="81-抽象类与抽象方法编写"><a class="markdownIt-Anchor" href="#81-抽象类与抽象方法编写"></a> 8.1 抽象类与抽象方法编写</h4><ul><li><strong>抽象类</strong> 是不能被实例化的类，用于被继承。</li><li>抽象类中可以包含抽象方法（没有方法体，只定义方法签名），必须由子类实现。</li><li>抽象类也可以有普通方法和成员变量。</li><li>用 <code>abstract</code> 关键字声明。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法，没有方法体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is sleeping.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; says: Woof!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Buddy&quot;</span>);</span><br><span class="line">        dog.sound();  <span class="comment">// 输出 Buddy says: Woof!</span></span><br><span class="line">        dog.sleep();  <span class="comment">// 输出 Buddy is sleeping.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="82-接口的定义与实现"><a class="markdownIt-Anchor" href="#82-接口的定义与实现"></a> 8.2 接口的定义与实现</h4><ul><li><strong>接口</strong> 是一种纯抽象的规范，只有方法签名和常量（Java 8+ 支持默认方法和静态方法）。</li><li>类通过 <code>implements</code> 关键字实现接口，必须实现接口中的所有抽象方法。</li><li>接口体现的是“能做什么”的能力，抽象类体现的是“是什么”的属性和行为。<br />如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Swimmable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span>, Swimmable &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Duck is flying.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Duck is swimming.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Duck</span> <span class="variable">duck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Duck</span>();</span><br><span class="line">        duck.fly();</span><br><span class="line">        duck.swim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="83-接口多实现-向上转型"><a class="markdownIt-Anchor" href="#83-接口多实现-向上转型"></a> 8.3 接口多实现、向上转型</h4><ul><li>一个类可以实现多个接口（多继承的替代方案）。</li><li>可以将实现类对象向上转型为接口类型，利用多态调用接口方法。</li><li>接口变量只能调用接口中声明的方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Duck</span> <span class="variable">duck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Duck</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Flyable</span> <span class="variable">f</span> <span class="operator">=</span> duck;   <span class="comment">// 向上转型为Flyable接口</span></span><br><span class="line">        <span class="type">Swimmable</span> <span class="variable">s</span> <span class="operator">=</span> duck; <span class="comment">// 向上转型为Swimmable接口</span></span><br><span class="line"></span><br><span class="line">        f.fly();  <span class="comment">// 调用Flyable的方法</span></span><br><span class="line">        s.swim(); <span class="comment">// 调用Swimmable的方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// duck.fly();  // 直接调用实现类方法也可以</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="84-继承和实现的混合使用"><a class="markdownIt-Anchor" href="#84-继承和实现的混合使用"></a> 8.4 继承和实现的混合使用</h4><ul><li>一个类只能继承<strong>一个</strong>直接父类（单继承）。</li><li>但可以实现<strong>多个</strong>接口（多实现）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal is eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类继承父类，同时实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bird is flying&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">        bird.eat();  <span class="comment">// 继承自 Animal</span></span><br><span class="line">        bird.fly();  <span class="comment">// 实现自 Flyable</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第-8-章示例-地理要素系统"><a class="markdownIt-Anchor" href="#第-8-章示例-地理要素系统"></a> 第 8 章：示例-地理要素系统</h3><h4 id="设计说明"><a class="markdownIt-Anchor" href="#设计说明"></a> 设计说明</h4><ul><li>抽象类 <code>GeoFeature</code>（地理要素），定义公共属性和抽象方法</li><li>子类：<code>PointFeature</code>（点）、<code>LineFeature</code>（线）、<code>PolygonFeature</code>（多边形）</li><li>接口 <code>Renderable</code>（可渲染），<code>Calculable</code>（可计算面积或长度）</li><li>利用封装隐藏属性，提供 getter/setter</li><li>使用 <code>static</code> 统计创建的地理要素数量</li><li>使用 <code>final</code> 定义常量和禁止修改的方法</li><li>重写 <code>toString()</code>, <code>equals()</code>, <code>clone()</code></li><li>演示多态和接口多实现</li></ul><h4 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 抽象类，定义基础地理要素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">GeoFeature</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">featureCount</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 统计创建要素数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GeoFeature</span><span class="params">(String id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        featureCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123; <span class="built_in">this</span>.id = id; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getFeatureCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> featureCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法，必须子类实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// final方法，不能被子类覆盖，打印信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">showInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;GeoFeature: &quot;</span> + toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写toString()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ID=&quot;</span> + id + <span class="string">&quot;, Name=&quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写equals，按id判断</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> GeoFeature)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">GeoFeature</span> <span class="variable">other</span> <span class="operator">=</span> (GeoFeature) obj;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.id.equals(other.id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现clone浅拷贝</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GeoFeature <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (GeoFeature) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 接口：可渲染</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Renderable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 接口：可计算长度或面积</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Calculable</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">calculate</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 点要素</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PointFeature</span> <span class="keyword">extends</span> <span class="title class_">GeoFeature</span> <span class="keyword">implements</span> <span class="title class_">Renderable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PointFeature</span><span class="params">(String id, String name, <span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(id, name);</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getX</span><span class="params">()</span> &#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(<span class="type">double</span> x)</span> &#123; <span class="built_in">this</span>.x = x; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getY</span><span class="params">()</span> &#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setY</span><span class="params">(<span class="type">double</span> y)</span> &#123; <span class="built_in">this</span>.y = y; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing Point at (&quot;</span> + x + <span class="string">&quot;,&quot;</span> + y + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Rendering Point: &quot;</span> + getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.toString() + <span class="string">&quot;, Point(&quot;</span> + x + <span class="string">&quot;,&quot;</span> + y + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 线要素</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LineFeature</span> <span class="keyword">extends</span> <span class="title class_">GeoFeature</span> <span class="keyword">implements</span> <span class="title class_">Renderable</span>, Calculable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LineFeature</span><span class="params">(String id, String name, <span class="type">double</span> length)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(id, name);</span><br><span class="line">        <span class="built_in">this</span>.length = length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getLength</span><span class="params">()</span> &#123; <span class="keyword">return</span> length; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLength</span><span class="params">(<span class="type">double</span> length)</span> &#123; <span class="built_in">this</span>.length = length; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing Line of length &quot;</span> + length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Rendering Line: &quot;</span> + getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法重载：计算长度乘以比例尺</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculate</span><span class="params">(<span class="type">double</span> scale)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> length * scale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.toString() + <span class="string">&quot;, Line length=&quot;</span> + length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 多边形要素</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PolygonFeature</span> <span class="keyword">extends</span> <span class="title class_">GeoFeature</span> <span class="keyword">implements</span> <span class="title class_">Renderable</span>, Calculable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> area;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PolygonFeature</span><span class="params">(String id, String name, <span class="type">double</span> area)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(id, name);</span><br><span class="line">        <span class="built_in">this</span>.area = area;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getArea</span><span class="params">()</span> &#123; <span class="keyword">return</span> area; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setArea</span><span class="params">(<span class="type">double</span> area)</span> &#123; <span class="built_in">this</span>.area = area; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing Polygon of area &quot;</span> + area);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Rendering Polygon: &quot;</span> + getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.toString() + <span class="string">&quot;, Polygon area=&quot;</span> + area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;生活所迫呀。&lt;/p&gt;</summary>
    
    
    
    <category term="编程学习-java" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-java/"/>
    
    
  </entry>
  
  <entry>
    <title>继续聊聊异步</title>
    <link href="https://atffang.github.io/2025/05/29/%E7%BB%A7%E7%BB%AD%E8%81%8A%E8%81%8A%E5%BC%82%E6%AD%A5/"/>
    <id>https://atffang.github.io/2025/05/29/%E7%BB%A7%E7%BB%AD%E8%81%8A%E8%81%8A%E5%BC%82%E6%AD%A5/</id>
    <published>2025-05-29T15:39:59.000Z</published>
    <updated>2025-05-29T15:46:47.446Z</updated>
    
    <content type="html"><![CDATA[<p>和之前的文章呼应下，继续介绍python的异步机制。</p><span id="more"></span><p>在之前的文章中（指路[<a href="https://atffang.github.io/2025/02/21/asyncio%E6%B5%85%E6%9E%90/#more">https://atffang.github.io/2025/02/21/asyncio浅析/#more</a>]），我们简单学习了python的asynicio机制，但当我回看这篇文章时，仍然觉得许多东西——特别是概念，没有讲清楚。因此有了这篇文章，我们将从底层机制开始介绍python中的异步操作。</p><h3 id="为什么要异步"><a class="markdownIt-Anchor" href="#为什么要异步"></a> 为什么要异步？</h3><p>中国人应该都听过华罗庚烧开水的故事。其中办法甲是洗好水壶，灌上凉水，放在火上；在等待水开的时间里，洗茶壶、洗茶杯、拿茶叶；等水开了，泡茶喝。等待某个事件完成（比如水开）时，如果一直干等，时间就被浪费了；如果能利用等待时间去做其他有意义的事情，效率就会更高。在程序设计中，也是如此：</p><p>当程序遇到“必须等待”的操作时，比如等待网络响应、磁盘读写、用户输入，如果我们像传统方式那样干等，就会浪费大量宝贵时间。而如果我们能在等待的间隙去做别的事情，整体运行效率就能大幅提升。</p><p>这就是 <strong>异步编程（Asynchronous Programming）</strong> 的核心思想。异步编程是一种程序设计方式，它允许程序在遇到耗时操作时“暂时挂起当前任务”，去执行其他任务，待耗时操作完成后再回来继续执行。这样，程序不会因为等待某个操作而“卡死”或闲置，特别适合处理大量 I/O 操作的场景。</p><h3 id="协程"><a class="markdownIt-Anchor" href="#协程"></a> 协程</h3><p>协程（Coroutine）是一种程序结构，允许函数在执行过程中暂停（挂起）并在未来某个时间恢复执行。它是一种“可暂停的函数”，实现了非抢占式的多任务协作。通俗来说，协程可以在执行中途“让出控制权”，让其他协程运行，等到时机合适再“继续执行”，而不是像线程那样被操作系统抢占。</p><p>Python中的协程，特别是用 async def 定义的异步协程，实际上是基于<strong>生成器（generator）</strong> 机制演化而来的。生成器是一种特殊的迭代器，它可以在执行过程中暂停，并在需要时恢复执行。生成器函数使用 yield 关键字来生成值，每次调用 yield 时，函数会暂停执行，并返回一个值给调用者。下次调用生成器时，函数会从上次暂停的地方继续执行。这种暂停等待执行的状态成为<strong>挂起</strong>，传统函数调用有自己的调用栈，调用结束后栈帧销毁，而挂起状态的函数并不会销毁内部变量和参数。</p><p>Python中，每次函数调用都会创建一个 帧对象（PyFrameObject，C语言结构体），它包含了函数执行的所有上下文信息：</p><ul><li>当前指令指针（程序计数器，PC），指示下一条要执行的字节码位置</li><li>局部变量和参数</li><li>操作数栈状态</li><li>代码对象引用</li></ul><p>生成器和协程本质上也是函数调用，只不过在挂起时不会销毁帧对象，而是把它冻结保存起来。当协程执行到await或者yield时，Python解释器暂停执行当前帧，保存当前指令指针位置（即当前字节码执行到哪一步了）。局部变量、操作栈以及执行环境的状态都保存在该帧对象内，这个帧对象作为生成器/协程对象的内部状态，存活在内存中。当事件循环或调度器认为条件满足（比如等待的异步I/O完成），它会调用生成器/协程的 <code>.send()</code> 或 <code>.__await__()</code> 方法，让Python解释器加载之前保存的帧对象状态，从断点处继续执行字节码。</p><h3 id="事件循环"><a class="markdownIt-Anchor" href="#事件循环"></a> 事件循环</h3><p><strong>事件循环（Event Loop）</strong> 是异步编程的核心调度机制，它不断循环监视“任务队列”或“事件源”，并在任务准备好执行时唤醒它们。我们在之前的文章中已经提到，协程对象执行到 <code>await</code> 会挂起并返回控制权，而要继续执行，就必须有一个机制来等待 <code>await</code> 的异步任务完成，再恢复暂停的协程。这个“等待+恢复”的过程，由事件循环自动调度完成。事件循环由下面四个关键部分组成：</p><ul><li><p><strong>Task 队列（任务队列）</strong><br />一个 Task 是对协程的封装，用于注册到事件循环中，并自动驱动协程的执行流程。协程对象会被封装为 asyncio.Task 对象，并加入事件循环管理的队列。</p></li><li><p><strong>Future 对象</strong><br />表示一个尚未完成的异步操作，类似于 JavaScript 的 Promise。Future是Task的父类，而await 的结果通常是 Future。</p></li><li><p><strong>IO 多路复用器</strong><br />使用操作系统的 select/epoll/kqueue/IOCP 来等待 I/O 事件。每个 await 的对象会注册一个 I/O 事件（如 socket 可读、定时器到期），这些事件会被提交到 selector，操作系统会在事件准备好时通知事件循环，事件循环再调用回调函数恢复协程。</p></li><li><p><strong>调度器</strong><br />调度器是事件循环的大脑，它控制协程的暂停与恢复。协程本质是生成器（generator）的拓展，调度行为是调用其 <code>send()</code> 或 <code>throw()</code> 方法。协程首次执行相当于 <code>coro.send(None)</code>，遇到 <code>await</code> 时将控制权交还给事件循环，并返回一个 <code>Future</code> 对象。事件循环等待 <code>Future</code> 对象完成，然后调用 <code>task._step()</code> 方法，执行 <code>coro.send(result)</code> ，恢复协程执行直到下一个 <code>await</code> 或结束。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+---------------------------+</span><br><span class="line">| asyncio.Task |</span><br><span class="line">| - 包含一个协程对象 |</span><br><span class="line">+---------------------------+</span><br><span class="line">↓</span><br><span class="line">初始执行 coro.send(<span class="literal">None</span>)</span><br><span class="line">↓</span><br><span class="line">协程执行 → 遇到 <span class="keyword">await</span></span><br><span class="line">↓</span><br><span class="line">返回 Future，挂起协程</span><br><span class="line">↓</span><br><span class="line">Future 注册到底层 IO selector</span><br><span class="line">↓</span><br><span class="line">事件完成 → Future 被标记为 done</span><br><span class="line">↓</span><br><span class="line">唤醒 Task → 再次执行 coro.send(result)</span><br><span class="line">↓</span><br><span class="line">直至结束</span><br></pre></td></tr></table></figure><h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h3><h4 id="爬虫"><a class="markdownIt-Anchor" href="#爬虫"></a> 爬虫</h4><p>任务目标：我们有 5 个网页，要同时请求它们的内容并提取标题。我们希望在不阻塞主线程的情况下完成所有请求。如果使用串行执行的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">  </span><br><span class="line">urls = [</span><br><span class="line"><span class="string">&quot;https://1.com&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://2.com&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://3.com&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://4.com&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://5.com&quot;</span></span><br><span class="line">] </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_title</span>(<span class="params">url</span>):</span><br><span class="line">response = requests.get(url)</span><br><span class="line"><span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;url&#125;</span> - status: <span class="subst">&#123;response.status_code&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line"><span class="built_in">print</span>(get_title(url))</span><br></pre></td></tr></table></figure><p>所有请求会一个接一个等。<br />如果使用异步方式（并发请求，非阻塞）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_title</span>(<span class="params">session, url</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">        text = <span class="keyword">await</span> response.text()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;url&#125;</span> - status: <span class="subst">&#123;response.status&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        tasks = [get_title(session, url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">        results = <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> results:</span><br><span class="line">            <span class="built_in">print</span>(r)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><h4 id="处理大量文件上传"><a class="markdownIt-Anchor" href="#处理大量文件上传"></a> 处理大量文件上传</h4><p>你在做一个网站，有很多用户同时上传文件（比如照片），你需要接收上传请求/将文件保存到磁盘或对象存储/同时记录用户上传日志（如用户名、时间、文件名）到数据库或日志文件中。<br />如果使用同步方式，所有请求会一个接一个等，用户上传文件时，其他用户只能等待:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_file</span>(<span class="params">user, file_name</span>):</span><br><span class="line">    time.sleep(<span class="number">2</span>)  <span class="comment"># 模拟写文件</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[保存] 用户 <span class="subst">&#123;user&#125;</span> 上传了 <span class="subst">&#123;file_name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log_upload</span>(<span class="params">user, file_name</span>):</span><br><span class="line">    time.sleep(<span class="number">1</span>)  <span class="comment"># 模拟写日志</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[日志] 记录 <span class="subst">&#123;user&#125;</span> 上传了 <span class="subst">&#123;file_name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_upload</span>(<span class="params">user, file_name</span>):</span><br><span class="line">    save_file(user, file_name)</span><br><span class="line">    log_upload(user, file_name)</span><br><span class="line"></span><br><span class="line">users = [(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;a.png&quot;</span>), (<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;b.jpg&quot;</span>), (<span class="string">&quot;Carol&quot;</span>, <span class="string">&quot;c.docx&quot;</span>)]</span><br><span class="line"><span class="keyword">for</span> user, file <span class="keyword">in</span> users:</span><br><span class="line">    handle_upload(user, file)</span><br></pre></td></tr></table></figure><p>如果使用异步方式，所有请求可以同时处理，用户上传文件时，其他用户可以继续上传。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">save_file</span>(<span class="params">user, file_name</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)  <span class="comment"># 模拟异步写文件</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[保存] 用户 <span class="subst">&#123;user&#125;</span> 上传了 <span class="subst">&#123;file_name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">log_upload</span>(<span class="params">user, file_name</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)  <span class="comment"># 模拟异步写日志</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[日志] 记录 <span class="subst">&#123;user&#125;</span> 上传了 <span class="subst">&#123;file_name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_upload</span>(<span class="params">user, file_name</span>):</span><br><span class="line">    <span class="keyword">await</span> save_file(user, file_name)</span><br><span class="line">    <span class="keyword">await</span> log_upload(user, file_name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    users = [(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;a.png&quot;</span>), (<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;b.jpg&quot;</span>), (<span class="string">&quot;Carol&quot;</span>, <span class="string">&quot;c.docx&quot;</span>)]</span><br><span class="line">    tasks = [handle_upload(user, file) <span class="keyword">for</span> user, file <span class="keyword">in</span> users]</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;和之前的文章呼应下，继续介绍python的异步机制。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>重返统计学1：从最大似然开始</title>
    <link href="https://atffang.github.io/2025/05/28/%E9%87%8D%E8%BF%94%E7%BB%9F%E8%AE%A1%E5%AD%A62%E4%BB%8E%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E5%BC%80%E5%A7%8B/"/>
    <id>https://atffang.github.io/2025/05/28/%E9%87%8D%E8%BF%94%E7%BB%9F%E8%AE%A1%E5%AD%A62%E4%BB%8E%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E5%BC%80%E5%A7%8B/</id>
    <published>2025-05-28T14:24:16.000Z</published>
    <updated>2025-05-28T14:28:10.645Z</updated>
    
    <content type="html"><![CDATA[<p>介绍一下最大似然</p><span id="more"></span><img src="https://atffang.github.io/2025/05/28/重返统计学2从最大似然开始/MLE.png"/>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍一下最大似然&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>重返统计学0：绪论</title>
    <link href="https://atffang.github.io/2025/05/27/%E9%87%8D%E8%BF%94%E7%BB%9F%E8%AE%A1%E5%AD%A60%E7%BB%AA%E8%AE%BA/"/>
    <id>https://atffang.github.io/2025/05/27/%E9%87%8D%E8%BF%94%E7%BB%9F%E8%AE%A1%E5%AD%A60%E7%BB%AA%E8%AE%BA/</id>
    <published>2025-05-27T12:20:35.000Z</published>
    <updated>2025-05-27T12:21:22.983Z</updated>
    
    <content type="html"><![CDATA[<p>挖个坑</p><span id="more"></span><p>作为一个地理系的学生，诚实的说，我对数学与统计学的认识十分有限而肤浅。唯一的训练是在本科时的基础课程概率论课上，那时正值南京新冠最严重的22年年初，多数的课通过网课的形式完成，或许这里面一多半时间还在睡梦中。在此之后，除了零零碎碎接触的知识，再也没系统性的学习过统计学，以至于现在总是力不从心。因此，打算新开一个坑，从一个小白的角度重新学习面向机器学习与地理的统计学知识，共勉！</p><p>统计学（Statistics）一词源自拉丁语 status（意为“国家事务”），最早在17世纪的德意志地区，用于指代关于国家人口、土地、税收的系统性数据收集与描述，被称为“政治算术”（Political Arithmetic）。随着时代发展，它逐渐脱离行政统计的原始功能，<strong>成为一门研究不确定性、分析数据规律、从样本推断总体的科学</strong>。</p><p>统计学的形成并非一蹴而就，而是在长期应对不确定性与社会复杂性的历史进程中逐步建立起来的。最初，17世纪的“政治算术”是统计思想的雏形，约翰·格朗特与威廉·配第通过对伦敦死亡票据的分析，首次尝试利用数据揭示人口规律，这种自国家行政管理中抽离出的数量思维，构成了统计学最早的社会实践背景。18世纪，雅各布·伯努利提出了大数定律，强调了样本频率与真实概率之间的趋同关系，拉开了从经验总结向概率理论过渡的序幕。同一时期，贝叶斯定理的提出标志着另一种思维路径的诞生，即将先验知识与数据更新相结合，探索对不确定现象进行概率建模的可能性</p><p>进入19世纪，随着数学分析的发展，统计学逐渐获得更加严密的形式化基础。高斯在误差理论中提出正态分布和最小二乘估计，拉普拉斯则将概率方法应用于天体运动分析，他们的工作将统计方法首次嵌入自然科学建模之中，也开启了参数估计与模型拟合的时代。到20世纪，统计学迎来了系统化的理论建构。罗纳德·费雪被广泛认为是现代统计学的奠基者之一，他不仅提出了极大似然估计、方差分析、设计实验等核心概念，还在哲学上确立了频率派立场，主张在重复试验中定义概率，并强调统计推断的客观性。与之并立的则是以杰弗里斯和萨维奇为代表的贝叶斯学派，强调知识的不确定性来源于认知主体本身，通过主观先验与后验更新，实现具有解释力的模型推理。这一“客观 vs 主观”、“频率 vs 信念”的思想分歧，至今仍构成统计方法论上的根本张力。</p><p>到了21世纪，随着计算能力的跃升与数据体量的激增，统计学与人工智能、机器学习逐步融合，形成了以预测精度、模型泛化能力为导向的新范式。在这一背景下，统计学习理论、正则化方法、贝叶斯推理和高维建模成为主流应用技术的理论支柱。统计模型不再仅仅用于科学实验与假设检验，而广泛应用于图像识别、自然语言处理、医疗诊断、政策评估等复杂系统的建模中，进一步模糊了“推断”与“预测”的边界。</p><p><strong>统计学的核心使命，是在面对不确定性和变异性的现实世界中，从有限样本中提取信息、推断总体特征，建立描述或解释变量间关系的模型</strong>。</p><p>频率与概率的区别，是统计学中一个根本而经典的问题，也正是区分统计学两大主要流派——频率派（Frequentist）和贝叶斯派（Bayesian）的核心所在。</p><p>在频率派统计学中，概率被严格定义为在大量重复独立试验中某事件发生的相对频率的极限。也就是说，概率是一个长期稳定出现的频率值，它是客观存在且可通过反复实验验证的数值。例如，抛硬币时正面朝上的概率是0.5，是在无限次抛掷中正面次数与总次数的比值趋近的极限。这种定义强调概率的客观性和实验可重复性，概率不存在于单次试验，而是长期统计规律的体现。</p><p>而在贝叶斯派中，概率则被解释为个体对某一事件发生不确定性的主观信念程度。概率是描述“知识状态”或“信息”的工具，可以用来表达对单个事件的可信度。贝叶斯概率不需要重复试验的物理基础，而是通过先验知识与新观测的结合，利用贝叶斯定理动态更新。比如，你对某个病人患病概率的估计，既包含医学知识，也包含个人观察结果，这种概率更像是“信念”的度量。</p><p>总结而言，频率派认为，参数是自然界固定的未知常数，数据是随机变量。统计推断的目标是利用样本数据来估计这些固定参数。而贝叶斯派则认为，参数本身就是随机变量，参数的不确定性通过一个先验分布来描述。在下一章中，我们将首先对这两个概念进行介绍，作为整个系列的引子。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;挖个坑&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>typing：规范友好的代码</title>
    <link href="https://atffang.github.io/2025/05/23/typing%E8%A7%84%E8%8C%83%E5%8F%8B%E5%A5%BD%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
    <id>https://atffang.github.io/2025/05/23/typing%E8%A7%84%E8%8C%83%E5%8F%8B%E5%A5%BD%E7%9A%84%E4%BB%A3%E7%A0%81/</id>
    <published>2025-05-23T02:27:49.000Z</published>
    <updated>2025-05-23T03:03:31.548Z</updated>
    
    <content type="html"><![CDATA[<p>使用typing增强Python代码的可读性、可维护性，并帮助静态分析工具进行错误检查。</p><span id="more"></span><p>Python 的 typing 模块是用于 <strong>类型注解和静态类型检查</strong> 的标准库工具。它为你编写类型安全、可读性强的大型代码提供了支持。</p><h3 id="基础类型和泛型容器类型"><a class="markdownIt-Anchor" href="#基础类型和泛型容器类型"></a> 基础类型和泛型容器类型</h3><p><strong>基础类型注解</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>, <span class="built_in">float</span>, <span class="built_in">str</span>, <span class="built_in">bool</span>, <span class="built_in">bytes</span></span><br></pre></td></tr></table></figure><ul><li>Python 内置类型就可以直接用作注解</li></ul><p><strong>泛型容器类型</strong></p><table><thead><tr><th><strong>类型</strong></th><th><strong>用法示例</strong></th></tr></thead><tbody><tr><td>List</td><td>List[int] — 整数列表</td></tr><tr><td>Dict</td><td>Dict[str, float] — 键为字符串，值为浮点数</td></tr><tr><td>Tuple</td><td>Tuple[int, str] — 二元组</td></tr><tr><td>Set</td><td>Set[int]</td></tr><tr><td>FrozenSet</td><td>FrozenSet[str]</td></tr></tbody></table><ul><li>Python 3.9+ 支持原生写法，如 <code>list[int]</code>替代 <code>List[int]</code>。<br />例如：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">average</span>(<span class="params">scores: <span class="type">List</span>[<span class="built_in">float</span>]</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(scores) / <span class="built_in">len</span>(scores)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(average([<span class="number">90.0</span>, <span class="number">85.5</span>, <span class="number">78.0</span>]))  <span class="comment"># 输出：84.5</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_student_score</span>(<span class="params">name: <span class="built_in">str</span>, records: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">float</span>]</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">    <span class="keyword">return</span> records[name]</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&quot;Alice&quot;</span>: <span class="number">91.5</span>, <span class="string">&quot;Bob&quot;</span>: <span class="number">88.0</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(get_student_score(<span class="string">&quot;Alice&quot;</span>, data))  <span class="comment"># 输出：91.5</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Tuple</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_student_info</span>() -&gt; <span class="type">Tuple</span>[<span class="built_in">str</span>, <span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">&quot;Alice&quot;</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">name, age = get_student_info()</span><br><span class="line"><span class="built_in">print</span>(name, age)  <span class="comment"># 输出：Alice 20</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span>, <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">total_scores</span>(<span class="params">data: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">return</span> &#123;name: <span class="built_in">sum</span>(scores) <span class="keyword">for</span> name, scores <span class="keyword">in</span> data.items()&#125;</span><br><span class="line"></span><br><span class="line">records = &#123;</span><br><span class="line">    <span class="string">&quot;Alice&quot;</span>: [<span class="number">90</span>, <span class="number">85</span>, <span class="number">92</span>],</span><br><span class="line">    <span class="string">&quot;Bob&quot;</span>: [<span class="number">78</span>, <span class="number">80</span>, <span class="number">74</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(total_scores(records))  <span class="comment"># 输出：&#123;&#x27;Alice&#x27;: 267, &#x27;Bob&#x27;: 232&#125;</span></span><br></pre></td></tr></table></figure><h3 id="通用类型工具"><a class="markdownIt-Anchor" href="#通用类型工具"></a> 通用类型工具</h3><table><thead><tr><th><strong>工具</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Any</td><td>任意类型</td></tr><tr><td>Union</td><td>多种类型之一，例如 Union[int, str]</td></tr><tr><td>Optional</td><td>可以是某种类型或 None，等价于 Union[T, None]</td></tr><tr><td>Callable</td><td>函数类型，例如 Callable[[int, int], str] 表示接受两个 int 返回 str 的函数</td></tr><tr><td>Literal</td><td>指定字面值，例如 Literal[‘yes’, ‘no’]</td></tr><tr><td>TypeVar</td><td>泛型类型变量（定义泛型函数或类时使用）</td></tr><tr><td>Generic</td><td>创建自定义泛型类时用</td></tr><tr><td>Final</td><td>声明不能被重写或赋值的变量/属性</td></tr><tr><td>ClassVar</td><td>用于声明类变量，而非实例变量</td></tr><tr><td>例如：</td><td></td></tr></tbody></table><h4 id="typevar"><a class="markdownIt-Anchor" href="#typevar"></a> TypeVar</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar, <span class="type">Tuple</span></span><br><span class="line"></span><br><span class="line">T = TypeVar(<span class="string">&#x27;T&#x27;</span>)  <span class="comment"># 声明一个通用类型变量 T</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">a: T, b: T</span>) -&gt; <span class="type">Tuple</span>[T, T]:</span><br><span class="line">    <span class="keyword">return</span> b, a</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(swap(<span class="number">1</span>, <span class="number">2</span>))          <span class="comment"># 输出: (2, 1)  —— T 被推断为 int</span></span><br><span class="line"><span class="built_in">print</span>(swap(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;bye&quot;</span>))   <span class="comment"># 输出: (&#x27;bye&#x27;, &#x27;hi&#x27;)  —— T 被推断为 str</span></span><br></pre></td></tr></table></figure><ul><li>T 可以是任何类型（int、str、float…）</li></ul><h4 id="generic"><a class="markdownIt-Anchor" href="#generic"></a> Generic</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar, <span class="type">Generic</span></span><br><span class="line"></span><br><span class="line">T = TypeVar(<span class="string">&#x27;T&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>(<span class="type">Generic</span>[T]):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, content: T</span>):</span><br><span class="line">        self.content = content</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>) -&gt; T:</span><br><span class="line">        <span class="keyword">return</span> self.content</span><br><span class="line"></span><br><span class="line">int_box = Box </span><br><span class="line"><span class="built_in">print</span>(int_box.get())  <span class="comment"># 输出: 123</span></span><br><span class="line"></span><br><span class="line">str_box = Box[<span class="built_in">str</span>](<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str_box.get())  <span class="comment"># 输出: hello</span></span><br></pre></td></tr></table></figure><ul><li><code>Box[T]</code> 表示这是一个“存放任意类型 T 的盒子”</li><li><code>Generic[T]</code> 表示类是“泛型类”</li></ul><h4 id="any"><a class="markdownIt-Anchor" href="#any"></a> Any</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Any</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_anything</span>(<span class="params">x: <span class="type">Any</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Received: <span class="subst">&#123;x&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">print_anything(<span class="number">42</span>)            <span class="comment"># int</span></span><br><span class="line">print_anything(<span class="string">&quot;hello&quot;</span>)       <span class="comment"># str</span></span><br><span class="line">print_anything([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])     <span class="comment"># list</span></span><br></pre></td></tr></table></figure><ul><li>Any 表示函数接受任何类型的数据</li></ul><h3 id="结构化和协议"><a class="markdownIt-Anchor" href="#结构化和协议"></a> 结构化和协议</h3><table><thead><tr><th><strong>类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Protocol</td><td>定义接口或行为协议（Python 3.8+）</td></tr><tr><td>TypedDict</td><td>类似 dict 的结构化类型注解</td></tr><tr><td>NamedTuple</td><td>类型注解版本的命名元组</td></tr><tr><td>dataclass</td><td>与 @dataclass 一起使用可以加注解</td></tr><tr><td>例如：</td><td></td></tr></tbody></table><h4 id="typeddict"><a class="markdownIt-Anchor" href="#typeddict"></a> TypedDict</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypedDict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">TypedDict</span>):</span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    is_active: <span class="built_in">bool</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">user: User</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Hello, <span class="subst">&#123;user[<span class="string">&#x27;name&#x27;</span>]&#125;</span>!&quot;</span></span><br><span class="line"></span><br><span class="line">u = &#123;<span class="string">&quot;id&quot;</span>: <span class="number">1</span>, <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;is_active&quot;</span>: <span class="literal">True</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(greet(u))  <span class="comment"># 输出: Hello, Alice!</span></span><br></pre></td></tr></table></figure><ul><li>明确了 user 必须包含哪些字段</li><li>静态检查工具（如 mypy）可以发现拼写错误或字段缺失</li></ul><h4 id="protocol"><a class="markdownIt-Anchor" href="#protocol"></a> Protocol</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Protocol</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reader</span>(<span class="title class_ inherited__">Protocol</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileReader</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;data from file&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dummy</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test data&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load</span>(<span class="params">r: Reader</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> r.read()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(load(FileReader()))  <span class="comment"># 输出: data from file</span></span><br><span class="line"><span class="built_in">print</span>(load(Dummy()))       <span class="comment"># 输出: test data</span></span><br></pre></td></tr></table></figure><p>当你只关心某个对象是否有某些方法或属性（而不是它的具体类型），使用 Protocol 可以定义“接口”，实现 Python 的“结构子类型检查”。</p><ul><li>load() 不关心对象的真实类型，只要有 .read() 方法就行</li><li>非侵入式，“只要像鸭子，它就能飞”（典型的 duck typing）</li></ul><h4 id="dataclasses"><a class="markdownIt-Anchor" href="#dataclasses"></a> dataclasses</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    is_active: <span class="built_in">bool</span> = <span class="literal">True</span>  <span class="comment"># 可以设置默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">u = User(<span class="built_in">id</span>=<span class="number">1</span>, name=<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(u)  <span class="comment"># 输出: User(id=1, name=&#x27;Alice&#x27;, is_active=True)</span></span><br></pre></td></tr></table></figure><ul><li>自动生成了 <strong>init</strong>() 方法</li><li>自动实现了 <strong>repr</strong>() 和 <strong>eq</strong>() 等方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass(<span class="params">order=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span>:</span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line">p1 = Product(<span class="number">19.9</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">p2 = Product(<span class="number">29.9</span>, <span class="string">&quot;B&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p1 &lt; p2)  <span class="comment"># True，按字段顺序比较（先比 price）</span></span><br></pre></td></tr></table></figure><ul><li>支持比较大小</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass, field</span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Token</span>:</span><br><span class="line">    value: <span class="built_in">str</span></span><br><span class="line">    secret: <span class="built_in">str</span> = field(<span class="built_in">repr</span>=<span class="literal">False</span>, compare=<span class="literal">False</span>)  <span class="comment"># 不显示、也不参与比较</span></span><br><span class="line"></span><br><span class="line">t1 = Token(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;secret123&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(t1)  <span class="comment"># 输出: Token(value=&#x27;abc&#x27;)</span></span><br></pre></td></tr></table></figure><p>忽略某个字段：field(repr=False, compare=False, default=…)</p><h3 id="特殊类型工具"><a class="markdownIt-Anchor" href="#特殊类型工具"></a> 特殊类型工具</h3><table><thead><tr><th><strong>类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>NewType</td><td>定义新的类型别名，例如：UserId = NewType(‘UserId’, int)</td></tr><tr><td>Type</td><td>类对象的类型，例如 Type[BaseClass]</td></tr><tr><td>Self</td><td>指代自身（Python 3.11+）</td></tr><tr><td>例如：</td><td></td></tr></tbody></table><h4 id="newtype"><a class="markdownIt-Anchor" href="#newtype"></a> NewType</h4><p>创建“伪新类型”，用于静态类型区分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> NewType</span><br><span class="line"></span><br><span class="line">UserId = NewType(<span class="string">&#x27;UserId&#x27;</span>, <span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_user_name</span>(<span class="params">user_id: UserId</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;User#<span class="subst">&#123;user_id&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">get_user_name(UserId(<span class="number">123</span>))  <span class="comment"># ✅ 正确</span></span><br><span class="line"><span class="comment"># get_user_name(123)        # ❌ mypy 会报错：需要 UserId，而不是 int</span></span><br></pre></td></tr></table></figure><h4 id="type"><a class="markdownIt-Anchor" href="#type"></a> Type</h4><p><code>Type[T]</code> 接收一个类对象（而不是实例）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Type</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Woof!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_animal</span>(<span class="params">animal_cls: <span class="type">Type</span>[Animal]</span>) -&gt; Animal:</span><br><span class="line">    <span class="keyword">return</span> animal_cls()</span><br><span class="line"></span><br><span class="line">a = make_animal(Dog)  <span class="comment"># ✅ 传类不是传对象</span></span><br><span class="line"><span class="built_in">print</span>(a.speak())      <span class="comment"># Woof!</span></span><br></pre></td></tr></table></figure><ul><li><code>Type[Animal]</code> 表示“Animal 的子类”，不是实例。</li></ul><h4 id="selfpython-311"><a class="markdownIt-Anchor" href="#selfpython-311"></a> Self(Python 3.11+)</h4><p>用于方法返回当前类类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Self</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Builder</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_name</span>(<span class="params">self, name: <span class="built_in">str</span></span>) -&gt; Self:</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_age</span>(<span class="params">self, age: <span class="built_in">int</span></span>) -&gt; Self:</span><br><span class="line">        self.age = age</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">b = Builder().set_name(<span class="string">&quot;Alice&quot;</span>).set_age(<span class="number">30</span>)</span><br></pre></td></tr></table></figure><ul><li>Self 解决了链式调用返回类型难以表达的问题。</li><li>自动适配子类返回自身，无需硬编码类名。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用typing增强Python代码的可读性、可维护性，并帮助静态分析工具进行错误检查。&lt;/p&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
  <entry>
    <title>不要用危险的字符拼接sql查询</title>
    <link href="https://atffang.github.io/2025/05/16/%E4%B8%8D%E8%A6%81%E7%94%A8%E5%8D%B1%E9%99%A9%E7%9A%84%E5%AD%97%E7%AC%A6%E6%8B%BC%E6%8E%A5sql%E6%9F%A5%E8%AF%A2/"/>
    <id>https://atffang.github.io/2025/05/16/%E4%B8%8D%E8%A6%81%E7%94%A8%E5%8D%B1%E9%99%A9%E7%9A%84%E5%AD%97%E7%AC%A6%E6%8B%BC%E6%8E%A5sql%E6%9F%A5%E8%AF%A2/</id>
    <published>2025-05-16T02:38:11.000Z</published>
    <updated>2025-05-16T02:49:44.281Z</updated>
    
    <content type="html"><![CDATA[<p>解决 SQL 注入问题，在于不去拼接字符串构造 SQL，而是使用“预编译 + 参数绑定”的方式（即参数化查询）来处理 SQL 请求。抑或是使用ORM。</p><span id="more"></span><p><strong>什么是 SQL 注入？</strong></p><p>SQL 注入（SQL Injection）是指攻击者通过构造恶意输入，插入到 SQL 查询语句中，从而<strong>操控数据库</strong>执行非预期的操作，如绕过登录、删除数据等。<br />例如：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名：&quot;</span>)</span><br><span class="line">sql = <span class="string">&quot;SELECT * FROM users WHERE username = &#x27;&quot;</span> + username + <span class="string">&quot;&#x27;;&quot;</span></span><br></pre></td></tr></table></figure><p>当用户输入 <code>admin' OR '1'='1</code> 时，SQL 变成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE username = <span class="string">&#x27;admin&#x27;</span> OR <span class="string">&#x27;1&#x27;</span>=<span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这会导致永远为真，绕过认证。</p><h3 id="解决方案1预编译参数绑定prepared-statements"><a class="markdownIt-Anchor" href="#解决方案1预编译参数绑定prepared-statements"></a> 解决方案1：预编译+参数绑定（Prepared Statements）</h3><p>将 SQL 语句结构提前固定好，<strong>只在后续绑定参数，而不是拼接字符串</strong>，数据库系统会提前“准备”好 SQL 的执行计划。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> psycopg2</span><br><span class="line"></span><br><span class="line">conn = psycopg2.connect(database=<span class="string">&quot;testdb&quot;</span>, user=<span class="string">&quot;postgres&quot;</span>, password=<span class="string">&quot;yourpassword&quot;</span>)</span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户输入</span></span><br><span class="line">username = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名：&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 安全的方式：参数化查询，防止SQL注入</span></span><br><span class="line">sql = <span class="string">&quot;SELECT * FROM users WHERE username = %s;&quot;</span></span><br><span class="line">cursor.execute(sql, (username,))  <span class="comment"># 第二个参数是 tuple，即使用户输入恶意内容也不会被执行为SQL代码</span></span><br><span class="line"></span><br><span class="line">rows = cursor.fetchall()</span><br><span class="line"><span class="built_in">print</span>(rows)</span><br></pre></td></tr></table></figure><p>这里的 %s 是占位符，(username,) 是绑定参数。<strong>PostgreSQL 会自动对输入内容进行转义和类型处理</strong>，用户输入的内容只会当作“数据”，不会被解释为 SQL 代码。</p><h3 id="解决方案2-ormobject-relational-mapping"><a class="markdownIt-Anchor" href="#解决方案2-ormobject-relational-mapping"></a> 解决方案2: ORM（Object-Relational Mapping）</h3><p><strong>ORM 是一种将数据库表映射为程序中的对象</strong> 的工具，它允许你用“面向对象的方式”来操作数据库，而不是手写 SQL。</p><p>优点包括：</p><ul><li>代码更简洁、抽象</li><li>更容易维护和迁移数据库</li><li>内置 <strong>参数化查询机制</strong>，天然避免 SQL 注入</li></ul><p>一个python+postgresql的简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine, Column, Integer, String</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker, declarative_base</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据库连接</span></span><br><span class="line">engine = create_engine(<span class="string">&quot;postgresql://postgres:yourpassword@localhost/testdb&quot;</span>)</span><br><span class="line">Session = sessionmaker(bind=engine)</span><br><span class="line">session = Session()</span><br><span class="line"></span><br><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个 User 模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    __tablename__ = <span class="string">&#x27;users&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    username = Column(String)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询一个用户（安全）</span></span><br><span class="line">username_input = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名：&quot;</span>)</span><br><span class="line">user = session.query(User).<span class="built_in">filter</span>(User.username == username_input).first()</span><br><span class="line"><span class="built_in">print</span>(user)</span><br></pre></td></tr></table></figure><p>当然，orm实际上更有益于我们进行数据库控制，即增删改查等操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine, Column, Integer, String</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker, declarative_base</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库连接设置（请修改为你的实际用户名、密码和数据库名）</span></span><br><span class="line">engine = create_engine(<span class="string">&quot;postgresql://postgres:yourpassword@localhost/testdb&quot;</span>)</span><br><span class="line">Session = sessionmaker(bind=engine)</span><br><span class="line">session = Session()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 ORM 基类</span></span><br><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 User 模型（对应 users 表）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    __tablename__ = <span class="string">&#x27;users&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    username = Column(String)</span><br><span class="line">    email = Column(String)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建表（如果尚不存在）</span></span><br><span class="line">Base.metadata.create_all(engine)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------- 增（Insert） ----------</span></span><br><span class="line">new_user = User(username=<span class="string">&quot;alice&quot;</span>, email=<span class="string">&quot;alice@example.com&quot;</span>)</span><br><span class="line">session.add(new_user)</span><br><span class="line">session.commit()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;插入用户 ID：<span class="subst">&#123;new_user.<span class="built_in">id</span>&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------- 查（Query） ----------</span></span><br><span class="line"><span class="comment"># 查询所有用户</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;所有用户：&quot;</span>)</span><br><span class="line">users = session.query(User).<span class="built_in">all</span>()</span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> users:</span><br><span class="line">    <span class="built_in">print</span>(user.<span class="built_in">id</span>, user.username, user.email)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询特定用户</span></span><br><span class="line">user = session.query(User).<span class="built_in">filter</span>(User.username == <span class="string">&quot;alice&quot;</span>).first()</span><br><span class="line"><span class="keyword">if</span> user:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;找到用户：&quot;</span>, user.username, user.email)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------- 改（Update） ----------</span></span><br><span class="line"><span class="keyword">if</span> user:</span><br><span class="line">    user.email = <span class="string">&quot;alice_updated@example.com&quot;</span></span><br><span class="line">    session.commit()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;已更新用户邮箱：&quot;</span>, user.email)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------- 删（Delete） ----------</span></span><br><span class="line"><span class="keyword">if</span> user:</span><br><span class="line">    session.delete(user)</span><br><span class="line">    session.commit()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;已删除用户：&quot;</span>, user.username)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------- 关闭会话 ----------</span></span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;解决 SQL 注入问题，在于不去拼接字符串构造 SQL，而是使用“预编译 + 参数绑定”的方式（即参数化查询）来处理 SQL 请求。抑或是使用ORM。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>geohash与geotree</title>
    <link href="https://atffang.github.io/2025/05/10/geohash%E4%B8%8Egeotree/"/>
    <id>https://atffang.github.io/2025/05/10/geohash%E4%B8%8Egeotree/</id>
    <published>2025-05-10T15:50:09.000Z</published>
    <updated>2025-05-11T14:32:48.908Z</updated>
    
    <content type="html"><![CDATA[<p>介绍一下geohash与geotree</p><span id="more"></span><h3 id="geohash"><a class="markdownIt-Anchor" href="#geohash"></a> Geohash</h3><p><strong>Geohash</strong> 是一种将二维地理坐标（经度 Longitude 和 纬度 Latitude）编码为一个可排序的字符串的空间索引方法。由 Gustavo Niemeyer 于 2008 年提出，并被广泛用于分布式地理数据索引、近邻搜索、区域聚合等场景。</p><p>核心特征为：</p><ul><li>编码结果是<strong>Base32 字符串</strong></li><li>字符越多，<strong>空间精度越高</strong></li><li>相近位置编码字符串有<strong>公共前缀</strong></li></ul><h4 id="geohash-编码原理"><a class="markdownIt-Anchor" href="#geohash-编码原理"></a> Geohash 编码原理</h4><p>Geohash 使用<strong>经纬度交替二分</strong>的方式，将整个地球的经纬度范围不断缩小，直到定位到目标点。过程主要分为以下 4 步：</p><p><strong>步骤 1：初始化经纬度范围</strong></p><ul><li>经度范围 lon_range = [-180, 180]</li><li>纬度范围 lat_range = [-90, 90]</li></ul><p><strong>步骤 2：交替二分编码，生成二进制序列</strong><br />使用**二分法（Binary Search）**编码纬度和经度：</p><ul><li>从经度开始（偶数位处理经度，奇数位处理纬度）</li><li>每次比较当前坐标是否大于区间中点，如果是，记为 1，否则为 0</li><li>并更新范围（左/右半区）<br />这个过程交替进行直到你得到足够数量的位，比如 5 位 * 7 字符 = 35 位。</li></ul><p><strong>步骤 3：每 5 位为一组，转为十进制索引</strong><br />将所得的长二进制串，<strong>每 5 位一组</strong>，转为十进制，然后用 Base32 映射表替换。</p><p><strong>步骤 4：生成最终字符串</strong><br />每 5 位 → 1 个字符，共 n 个字符（通常精度为 6~9 个字符）。</p><h4 id="geohash优点"><a class="markdownIt-Anchor" href="#geohash优点"></a> Geohash优点</h4><p><strong>1.</strong> <strong>支持空间邻近查询</strong></p><ul><li>Geohash 编码相邻的区域通常具有<strong>相似前缀</strong>，适合使用前缀匹配（如 LIKE ‘wx4g0%’）实现快速范围查询。</li><li>特别适合在数据库中对空间对象做索引。</li></ul><p><strong>2.</strong>  <strong>分级精度（多级网格）</strong></p><ul><li>编码长度越长，表示区域越小，精度越高。</li><li>可动态控制精度，适合不同缩放层级的空间分析。</li></ul><p><strong>3.</strong>  <strong>文本存储，易于索引</strong></p><ul><li>Geohash 是字符串格式，便于存储、索引（B-Tree、Trie）、压缩和分布式传输。</li></ul><p><strong>4.</strong> <strong>无依赖的数据结构</strong></p><ul><li>不依赖复杂的空间数据结构（如 R-Tree、QuadTree），适用于轻量级地理索引服务。</li></ul><p><strong>5.</strong> <strong>适合分布式系统</strong></p><ul><li>Geohash 可直接用于 Sharding，例如前缀作为分片 key，天然适配大数据平台如 HBase、Elasticsearch。</li></ul><h4 id="geohash的不足"><a class="markdownIt-Anchor" href="#geohash的不足"></a> Geohash的不足</h4><p><strong>1.</strong> <strong>经纬度不均匀映射</strong></p><ul><li>纬度范围 [-90, 90]，经度 [-180, 180]，导致赤道附近一个 Geohash 单元的面积大于极地。</li><li>地球是球体，Geohash 假设平面映射，有畸变。</li></ul><p><strong>2.</strong>  <strong>边界误差问题</strong></p><ul><li>相邻的两个地理位置如果落在不同的 Geohash 网格单元中，会出现<strong>编码前缀差异</strong>，影响邻近判断。</li><li>需要额外处理“邻居格子”。</li></ul><p><strong>3.</strong> <strong>形状不规则</strong></p><ul><li>Geohash 网格在地图上是<strong>长方形</strong>而非正方形，且每一级的比例不均一，查询时常需额外扩大范围。</li></ul><p><strong>4.</strong>  <strong>二维信息压缩成一维有信息损失</strong></p><ul><li>经纬度交替合并会丢失部分空间关系（例如正方形邻域判断更复杂）。</li></ul><p><strong>5.</strong> <strong>精度和效率权衡</strong></p><ul><li>长 Geohash 字符串意味着更高精度，但也带来索引增长和性能损耗问题。</li></ul><p>总的来说，Geohash 是一种优雅的地理编码方案，它以轻量、易索引的方式，在现代数据库和分布式系统中广泛应用。然而，在面对高精度、复杂空间关系时，它也暴露出一定的局限性。因此，在实际使用中，应结合业务需求，评估其合适性，并配合如邻接格补全、R-Tree 等技术优化空间查询性能。</p><h3 id="geotree"><a class="markdownIt-Anchor" href="#geotree"></a> GeoTree</h3><p><strong>GeoTree</strong> 是一种基于空间层级划分的地理编码体系，它将地球表面按不同层级进行规则划分，并通过编码的方式表达空间单元的层级和位置关系。相比 Geohash 等网格编码，GeoTree 更强调“树结构”和“地理拓扑”的结合，适用于需要空间聚合、路径查询、空间层次建模的应用场景。</p><p>GeoTree 的思想与四叉树（QuadTree）类似，但更灵活，支持<strong>多尺度编码</strong>与<strong>空间父子继承关系表达</strong>，广泛用于如地空一体化管理、空域划分、地理分区治理等空间应用。</p><h4 id="核心特征"><a class="markdownIt-Anchor" href="#核心特征"></a> <strong>核心特征：</strong></h4><ul><li>每个节点表示一个空间区域，节点 ID 为<strong>可排序的字符串或整数</strong></li><li>子区域编码在父编码基础上扩展（<strong>继承性编码</strong>）</li><li>层级结构清晰，便于表示“包含关系”和<strong>层次聚合</strong></li><li>支持<strong>三维空间索引</strong>（经度、纬度、高度）</li></ul><h4 id="geotree-编码原理"><a class="markdownIt-Anchor" href="#geotree-编码原理"></a> <strong>GeoTree 编码原理</strong></h4><p>GeoTree 并非采用经纬度交替压缩为二进制，而是按照空间网格划分规则，分层递归构建编码。过程一般如下：<br /><strong>步骤 1：定义根层空间范围（Level 0）</strong></p><ul><li>将地球划分为若干大格（如全球 8 区或全球 6 面体）</li><li>每个大格分配一个唯一编码（如 “1”、“A”、“R0”）</li></ul><p><strong>步骤 2：递归划分子区域（Level 1~n）</strong></p><ul><li>每个区域根据固定或可变规则继续划分为子区域（如 4 等分、9 等分、3D 立方等）</li><li>子区域编码在父编码基础上追加子代标识（如 “1-3” 表示根节点 1 的第 3 个子区）</li></ul><p><strong>步骤 3：形成空间编码树</strong></p><ul><li>所有区域构成一棵空间树：根为地球、分支为区域、叶子为最小单元</li><li>编码如 A-1-2-0 表示：区域 A → 子区 1 → 子区 2 → 子区 0</li></ul><p><strong>步骤 4：支持三维编码（可选）</strong></p><ul><li>对于需要高空建模的场景，每层子区可增加“高度切分”，编码如：A-1-2-0-H2</li></ul><h4 id="geotree-的优势"><a class="markdownIt-Anchor" href="#geotree-的优势"></a> <strong>GeoTree 的优势</strong></h4><p><strong>1.</strong>  <strong>天然支持空间层次结构</strong></p><ul><li>每个编码天然携带层级信息，如 A-2-3 表示第 2 层、第 3 区</li><li>支持区域归属、包含、父子导航等空间树操作</li></ul><p><strong>2.</strong> <strong>邻接关系明确，便于空间合并</strong></p><ul><li>可快速判断相邻区域是否有共同父节点，从而实现区域合并、聚合分析</li></ul><p><strong>3.</strong> <strong>便于多尺度查询</strong></p><ul><li>查询精度可控制在某一层级，例如只查询第 3 层的所有编码</li></ul><p><strong>4.</strong> <strong>编码形式灵活</strong></p><ul><li>可以使用字符串（如 “E-3-1”）或整型编码（如位运算 0b010101）支持高效索引</li></ul><p><strong>5.</strong> <strong>支持三维空间编码</strong></p><ul><li>除经纬度之外，GeoTree 可扩展高度维度，适用于低空空域、建筑分层、空间管网等场景</li></ul><p><strong>6.</strong> <strong>更强的空间拓扑表达能力</strong></p><ul><li>相比 Geohash 的“前缀相似”，GeoTree 明确建模空间父子关系，有助于空间推理和规划控制</li></ul><h4 id="geotree-的不足"><a class="markdownIt-Anchor" href="#geotree-的不足"></a> <strong>GeoTree 的不足</strong></h4><p><strong>1.</strong> <strong>空间分区规则需自定义</strong></p><ul><li>没有标准化的编码划分规则，不同业务可能用不同树型划分方式</li></ul><p><strong>2.</strong> <strong>区域形状不规则</strong></p><ul><li>编码背后代表的空间单元可能非正方形（视分割策略），可能导致某些计算复杂</li></ul><p><strong>3.</strong> <strong>实现成本略高</strong></p><ul><li>相比 Geohash 纯字符串压缩，GeoTree 需要维护树结构、支持路径解析和层级操作</li></ul><p><strong>4.</strong> <strong>邻接格查找略繁琐</strong></p><ul><li>查找空间邻居不像 Geohash 可以通过简单变换字符实现，而需要访问同层兄弟节点</li></ul><p>GeoTree 是一种<strong>结构化、层级化、拓扑清晰的地理编码体系</strong>，它从空间组织结构出发，更适合表达“地理分区与归属”这一类场景。在复杂区域管理、空间权限控制、多尺度数据建模等领域，比 Geohash 更具表达力。<br />然而，由于 GeoTree 没有统一标准实现，初始设计需结合业务规则规划编码体系。在面向大规模分布式查询的场景下，GeoTree 可与 Geohash 等轻量编码联合使用，取长补短，实现高效、结构清晰的空间信息处理。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍一下geohash与geotree&lt;/p&gt;</summary>
    
    
    
    <category term="空间分析与GIS算法" scheme="https://atffang.github.io/categories/%E7%A9%BA%E9%97%B4%E5%88%86%E6%9E%90%E4%B8%8EGIS%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Python中的闭包</title>
    <link href="https://atffang.github.io/2025/05/09/Python%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/"/>
    <id>https://atffang.github.io/2025/05/09/Python%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/</id>
    <published>2025-05-09T02:39:33.000Z</published>
    <updated>2025-05-09T03:06:18.554Z</updated>
    
    <content type="html"><![CDATA[<p>Python中的闭包机制简介</p><span id="more"></span><h3 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h3><p>闭包（<strong>Closure</strong>）是 Python 中一个非常重要且常用的概念，它是函数式编程的核心特性之一。闭包是一个函数，它“记住”了它被创建时的环境，即使在其环境之外被调用，这些变量仍然可用。换句话说：<strong>一个函数返回了另一个函数，这个返回的函数引用了其外部函数的变量</strong>，这个内部函数就是一个闭包。</p><p><strong>闭包的三个必要条件</strong>：</p><ol><li><strong>嵌套函数</strong>：函数内部定义了另一个函数；</li><li><strong>内部函数引用了外部函数的变量（自由变量）</strong>；</li><li><strong>外部函数返回了内部函数</strong>。</li></ol><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">y</span>):</span><br><span class="line">        <span class="keyword">return</span> x + y  <span class="comment"># inner 使用了 outer 的变量 x</span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">f = outer(<span class="number">10</span>)  <span class="comment"># outer 返回了 inner 函数</span></span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">5</span>))    <span class="comment"># 输出 15，等于 10 + 5</span></span><br></pre></td></tr></table></figure><p>每当函数内部引用了外部作用域的变量时，Python 会将这些变量“捕获”并保存在闭包中。<br />我们可以用函数的 <strong>closure</strong> 属性查看闭包中存储的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(f.__closure__[<span class="number">0</span>].cell_contents)  <span class="comment"># 输出 10</span></span><br></pre></td></tr></table></figure><h3 id="usage"><a class="markdownIt-Anchor" href="#usage"></a> Usage</h3><h4 id="数据隐藏类似于私有变量"><a class="markdownIt-Anchor" href="#数据隐藏类似于私有变量"></a> 数据隐藏（类似于私有变量）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_counter</span>():</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">counter</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> count</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line"></span><br><span class="line">c1 = make_counter()</span><br><span class="line"><span class="built_in">print</span>(c1())  <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(c1())  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">c2 = make_counter()</span><br><span class="line"><span class="built_in">print</span>(c2())  <span class="comment"># 1（新的闭包）</span></span><br></pre></td></tr></table></figure><p>如果你在一个函数内定义了另一个函数（形成闭包），而你想<strong>在内部函数中修改外部函数的变量</strong>，就需要用 nonlocal 来声明这个变量。nonlocal 是 Python 3 中引入的一个关键字，用于在<strong>嵌套函数中声明一个变量不是局部变量</strong>，而是来自于<strong>最近一层的外部（非全局）作用域</strong>。</p><h4 id="回调函数"><a class="markdownIt-Anchor" href="#回调函数"></a> 回调函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_multiplier</span>(<span class="params">factor</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">multiply</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="keyword">return</span> n * factor</span><br><span class="line">    <span class="keyword">return</span> multiply</span><br><span class="line"></span><br><span class="line">double = make_multiplier(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(double(<span class="number">10</span>))  <span class="comment"># 20</span></span><br></pre></td></tr></table></figure><h4 id="函数工厂"><a class="markdownIt-Anchor" href="#函数工厂"></a> 函数工厂</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">power_factory</span>(<span class="params">exp</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> x ** exp</span><br><span class="line">    <span class="keyword">return</span> power</span><br><span class="line"></span><br><span class="line">square = power_factory(<span class="number">2</span>)</span><br><span class="line">cube = power_factory(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(square(<span class="number">5</span>))  <span class="comment"># 25</span></span><br><span class="line"><span class="built_in">print</span>(cube(<span class="number">2</span>))    <span class="comment"># 8</span></span><br></pre></td></tr></table></figure><h4 id="装饰器的本质也是闭包"><a class="markdownIt-Anchor" href="#装饰器的本质也是闭包"></a> 装饰器的本质也是闭包！</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Before function call&quot;</span>)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;After function call&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@my_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">greet(<span class="string">&quot;Alice&quot;</span>)</span><br></pre></td></tr></table></figure><p>进一步的，我们可以使用装饰器来为函数计时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start = time.time()  <span class="comment"># 开始时间</span></span><br><span class="line">        result = func(*args, **kwargs)  <span class="comment"># 调用被装饰的函数</span></span><br><span class="line">        end = time.time()  <span class="comment"># 结束时间</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;函数 `<span class="subst">&#123;func.__name__&#125;</span>` 运行耗时：<span class="subst">&#123;end - start:<span class="number">.6</span>f&#125;</span> 秒&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">slow_function</span>():</span><br><span class="line">    time.sleep(<span class="number">2</span>)  <span class="comment"># 模拟耗时操作</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务完成&quot;</span>)</span><br><span class="line"></span><br><span class="line">slow_function()</span><br></pre></td></tr></table></figure><p>再进一步的，我们对装饰器进行增强，使其能够同时实现：</p><ul><li>✅ 打印日志（函数名称和参数）</li><li>⏱ 计时执行时间</li><li>⚠️ 自动捕获异常并打印错误信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log_timer_exception</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[LOG] 正在调用函数 `<span class="subst">&#123;func.__name__&#125;</span>`&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[LOG] 参数: args=<span class="subst">&#123;args&#125;</span>, kwargs=<span class="subst">&#123;kwargs&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        start_time = time.time()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            result = func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[ERROR] 函数 `<span class="subst">&#123;func.__name__&#125;</span>` 执行出错: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            traceback.print_exc()</span><br><span class="line">            result = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[LOG] 函数 `<span class="subst">&#123;func.__name__&#125;</span>` 返回结果: <span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            end_time = time.time()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[TIME] 函数 `<span class="subst">&#123;func.__name__&#125;</span>` 执行耗时: <span class="subst">&#123;end_time - start_time:<span class="number">.6</span>f&#125;</span> 秒\n&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@log_timer_exception</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br><span class="line"></span><br><span class="line"><span class="meta">@log_timer_exception</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sleep_task</span>(<span class="params">seconds</span>):</span><br><span class="line">    time.sleep(seconds)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;休眠 <span class="subst">&#123;seconds&#125;</span> 秒完成&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">divide(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">divide(<span class="number">10</span>, <span class="number">0</span>)  <span class="comment"># 除零错误</span></span><br><span class="line"></span><br><span class="line">sleep_task(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[LOG] 正在调用函数 `divide`</span><br><span class="line">[LOG] 参数: args=(10, 2), kwargs=&#123;&#125;</span><br><span class="line">[LOG] 函数 `divide` 返回结果: 5.0</span><br><span class="line">[TIME] 函数 `divide` 执行耗时: 0.000002 秒</span><br><span class="line"></span><br><span class="line">[LOG] 正在调用函数 `divide`</span><br><span class="line">[LOG] 参数: args=(10, 0), kwargs=&#123;&#125;</span><br><span class="line">[ERROR] 函数 `divide` 执行出错: division by zero</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line">[TIME] 函数 `divide` 执行耗时: 0.000004 秒</span><br></pre></td></tr></table></figure><h4 id="闭包lamba表达式"><a class="markdownIt-Anchor" href="#闭包lamba表达式"></a> 闭包+lamba表达式</h4><p>lambda 常用于创建简单闭包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_adder</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> y: x + y</span><br><span class="line"></span><br><span class="line">add5 = make_adder(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(add5(<span class="number">3</span>))  <span class="comment"># 8</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Python中的闭包机制简介&lt;/p&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
  <entry>
    <title>工厂函数与工厂方法</title>
    <link href="https://atffang.github.io/2025/05/09/%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0/"/>
    <id>https://atffang.github.io/2025/05/09/%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0/</id>
    <published>2025-05-09T01:51:56.000Z</published>
    <updated>2025-05-09T03:16:35.605Z</updated>
    
    <content type="html"><![CDATA[<p>本文以python为例，简单介绍工厂函数。</p><span id="more"></span><h3 id="工厂函数"><a class="markdownIt-Anchor" href="#工厂函数"></a> 工厂函数</h3><p>工厂函数（Factory Function）是一种常见的设计模式，尤其适用于面向对象编程和函数式编程场景中，用来 <strong>动态创建对象</strong> 或 <strong>封装复杂初始化逻辑</strong>。</p><h4 id="definition"><a class="markdownIt-Anchor" href="#definition"></a> Definition</h4><p>工厂函数本质上是一个<strong>返回对象的函数</strong>，而不是类的构造函数（<strong>init</strong>）。它根据传入的参数决定返回什么类型或配置的对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">animal_factory</span>(<span class="params">animal_type</span>):</span><br><span class="line">    <span class="keyword">if</span> animal_type == <span class="string">&quot;dog&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> Dog()</span><br><span class="line">    <span class="keyword">elif</span> animal_type == <span class="string">&quot;cat&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> Cat()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Unknown animal type&quot;</span>)</span><br></pre></td></tr></table></figure><p>工厂函数的优势在于：</p><ol><li><strong>封装复杂逻辑</strong>：隐藏创建对象所需的复杂初始化步骤；</li><li><strong>运行时类型决定</strong>：可以在运行时根据参数决定返回何种子类；</li><li><strong>返回同一类的多个变种</strong>：支持不同配置、不同状态的实例；</li><li><strong>替代类继承</strong>：在某些函数式编程场景中，不用类继承，也可以通过工厂函数生成封装好的行为；</li><li><strong>支持缓存或单例</strong>：结合缓存机制（比如字典）可复用实例。</li></ol><h4 id="usage"><a class="markdownIt-Anchor" href="#usage"></a> Usage</h4><p>数据库连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MySQLConnection</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MySQL connected&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PostgreSQLConnection</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;PostgreSQL connected&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">db_connection_factory</span>(<span class="params">db_type</span>):</span><br><span class="line">    <span class="keyword">if</span> db_type == <span class="string">&quot;mysql&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> MySQLConnection()</span><br><span class="line">    <span class="keyword">elif</span> db_type == <span class="string">&quot;postgres&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> PostgreSQLConnection()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Unsupported DB type&quot;</span>)</span><br><span class="line"></span><br><span class="line">conn = db_connection_factory(<span class="string">&quot;mysql&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(conn.connect())  <span class="comment"># 输出: MySQL connected</span></span><br></pre></td></tr></table></figure><p>工厂函数封装初始化参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_logger</span>(<span class="params">log_type=<span class="string">&quot;file&quot;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> log_type == <span class="string">&quot;file&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span> msg: <span class="built_in">print</span>(<span class="string">f&quot;[FILE] <span class="subst">&#123;datetime.now()&#125;</span>: <span class="subst">&#123;msg&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> log_type == <span class="string">&quot;console&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span> msg: <span class="built_in">print</span>(<span class="string">f&quot;[CONSOLE] <span class="subst">&#123;datetime.now()&#125;</span>: <span class="subst">&#123;msg&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Unknown log type&quot;</span>)</span><br><span class="line"></span><br><span class="line">logger = create_logger(<span class="string">&quot;console&quot;</span>)</span><br><span class="line">logger(<span class="string">&quot;Something happened&quot;</span>)  <span class="comment"># 输出: [CONSOLE] 时间: Something happened</span></span><br></pre></td></tr></table></figure><p>结合缓存，返回单例或共享对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">_instances = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">singleton_factory</span>(<span class="params">cls</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_instance</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> _instances:</span><br><span class="line">            _instances[cls] = cls(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> _instances[cls]</span><br><span class="line">    <span class="keyword">return</span> get_instance</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton_factory</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Configuration</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.settings = &#123;&#125;</span><br><span class="line"></span><br><span class="line">config1 = Configuration()</span><br><span class="line">config2 = Configuration()</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> config1 <span class="keyword">is</span> config2</span><br></pre></td></tr></table></figure><h4 id="在类中使用工厂函数"><a class="markdownIt-Anchor" href="#在类中使用工厂函数"></a> 在类中使用工厂函数</h4><p>现在有一需求，我们想为每个宠物自动分配一个出生时间，给它一个独立的玩具箱（字典），这些值在每次创建时应该不同。<br />✅ 正确做法：使用<strong>default_factory</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass, field</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pet</span>:</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    kind: <span class="built_in">str</span>  <span class="comment"># &quot;cat&quot; or &quot;dog&quot;</span></span><br><span class="line">    born_time: datetime = field(default_factory=datetime.now)</span><br><span class="line">    toys: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">int</span>] = field(default_factory=<span class="built_in">dict</span>)  <span class="comment"># 玩具名 -&gt; 数量</span></span><br></pre></td></tr></table></figure><p><strong>field函数</strong>: 使用 field(default_factory=datetime.now) 表示：每次创建 Pet 实例时，都调用 datetime.now() 来自动生成时间戳（不是在类加载时就固定）。</p><p>field 是 Python dataclasses 模块中的一个函数，用来<strong>给类的属性定义更复杂的行为或默认值</strong>。default_factory 是 field() 函数的一个<strong>参数</strong>，它的作用是指定一个“工厂函数”，每次创建 dataclass 实例时调用它来生成字段的默认值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat = Pet(name=<span class="string">&quot;Mimi&quot;</span>, kind=<span class="string">&quot;cat&quot;</span>)</span><br><span class="line">dog = Pet(name=<span class="string">&quot;Doudou&quot;</span>, kind=<span class="string">&quot;dog&quot;</span>)</span><br><span class="line"></span><br><span class="line">cat.toys[<span class="string">&quot;ball&quot;</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cat.born_time)     <span class="comment"># 每个宠物自己的出生时间</span></span><br><span class="line"><span class="built_in">print</span>(dog.born_time)     <span class="comment"># 不同时间</span></span><br><span class="line"><span class="built_in">print</span>(dog.toys)          <span class="comment"># &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cat.toys <span class="keyword">is</span> dog.toys)  <span class="comment"># False ✅，玩具箱不共享</span></span><br></pre></td></tr></table></figure><p>❌ 错误示范：不使用default_factory，所有宠物共享玩具箱和出生时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BrokenPet</span>:</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    kind: <span class="built_in">str</span></span><br><span class="line">    born_time: datetime = datetime.now()  <span class="comment"># ❌ 类加载时固定</span></span><br><span class="line">    toys: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">int</span>] = &#123;&#125;             <span class="comment"># ❌ 所有宠物共享一套玩具</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat = BrokenPet(name=<span class="string">&quot;Mimi&quot;</span>, kind=<span class="string">&quot;cat&quot;</span>)</span><br><span class="line">dog = BrokenPet(name=<span class="string">&quot;Doudou&quot;</span>, kind=<span class="string">&quot;dog&quot;</span>)</span><br><span class="line"></span><br><span class="line">cat.toys[<span class="string">&quot;fish&quot;</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dog.toys)  <span class="comment"># ❌ &#123;&#x27;fish&#x27;: 1&#125;，狗和猫共用玩具箱</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cat.born_time == dog.born_time)  <span class="comment"># True ❌，出生时间完全相同</span></span><br></pre></td></tr></table></figure><p>有时人们会混淆<strong>类属性</strong>和<strong>实例属性</strong>，导致共享值错误！！！！</p><h3 id="工厂方法"><a class="markdownIt-Anchor" href="#工厂方法"></a> 工厂方法</h3><p><strong>厂方法模式（Factory Method Pattern</strong>本质是定义一个接口（抽象方法），让子类决定要实例化的类：</p><ul><li>是 GoF 的正式设计模式之一；</li><li>基于类继承；</li><li>通常用在面向对象的架构中；</li><li>Python中可以用 abc（抽象基类）来实现。</li></ul><p>一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Woof&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Meow&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 工厂方法基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnimalFactory</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_animal</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogFactory</span>(<span class="title class_ inherited__">AnimalFactory</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_animal</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> Dog()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CatFactory</span>(<span class="title class_ inherited__">AnimalFactory</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_animal</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> Cat()</span><br><span class="line"></span><br><span class="line">factory = DogFactory()</span><br><span class="line">animal = factory.create_animal()</span><br><span class="line"><span class="built_in">print</span>(animal.speak())  <span class="comment"># 输出：Woof</span></span><br></pre></td></tr></table></figure><p>DogFactory 和 CatFactory 继承了 AnimalFactory，并各自实现了创建逻辑。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文以python为例，简单介绍工厂函数。&lt;/p&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
  <entry>
    <title>详解Python类的装饰器和魔法方法</title>
    <link href="https://atffang.github.io/2025/03/30/%E8%AF%A6%E8%A7%A3Python%E7%B1%BB%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"/>
    <id>https://atffang.github.io/2025/03/30/%E8%AF%A6%E8%A7%A3Python%E7%B1%BB%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/</id>
    <published>2025-03-30T07:51:52.000Z</published>
    <updated>2025-03-30T07:55:53.030Z</updated>
    
    <content type="html"><![CDATA[<p>介绍一下Python类的装饰器和魔法方法，以及参数的下划线前缀</p><span id="more"></span><p>一个记性并不好的人将在工作中学习到的碎片化的知识统筹起来必须要依靠记录，非常不幸的是鄙人在记忆力不强的前提下依然没有良好的记录习惯，加之跑通万岁的实用主义，使得写的代码总是看起来比较低级而缺乏优雅的气息，与本人气质强烈不符。痛定思痛，痛改前非，先从一个相对基础但极其重要的机制开始记起：Python中类的装饰器与魔法方法。</p><h3 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h3><h4 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h4><p>在 Python 中，类是面向对象编程（OOP）的核心概念，它用于定义对象的蓝图。类封装了数据（属性）和行为（方法），通过类可以创建多个具有相同结构的实例对象。通过使用类，代码可以更具组织性和模块化，易于扩展和维护。</p><p>在 Python 中定义一个基本的类非常简单，使用关键字 <code>class</code> 进行定义。以下是一个简单的类定义的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="comment"># 这是一个类属性</span></span><br><span class="line">    class_variable = <span class="string">&quot;I am a class variable&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这是初始化方法（构造函数），当类实例化时会自动调用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="comment"># 这是实例属性</span></span><br><span class="line">        self.instance_variable = value</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这是一个实例方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">instance_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;This is an instance method and instance_variable is: <span class="subst">&#123;self.instance_variable&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这是一个类方法，使用 @classmethod 装饰器定义</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">class_method</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;This is a class method and class_variable is: <span class="subst">&#123;cls.class_variable&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这是一个静态方法，使用 @staticmethod 装饰器定义</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">static_method</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;This is a static method&quot;</span></span><br></pre></td></tr></table></figure><p>在上述代码中，展现了类的各个组成部分为：</p><ul><li><p><strong>类属性</strong>：</p><ul><li>类属性是类级别的属性，它们对于所有实例都是共享的。类属性通常定义在类体中，独立于任何方法。</li><li>在上例中，<code>class_variable</code> 就是一个类属性，所有对象共享同一个值。</li></ul></li><li><p><strong>实例属性</strong>：</p><ul><li>实例属性是在类的实例化过程中通过 <code>__init__()</code> 方法（也叫构造函数）动态创建的，每个实例有独立的属性值。</li><li>通过 <code>self.instance_variable = value</code>，我们为每个实例赋予不同的 <code>instance_variable</code> 值。</li></ul></li><li><p><strong>实例方法</strong>：</p><ul><li>实例方法是类中定义的普通方法，它们操作实例属性，且必须接受参数 <code>self</code>，<code>self</code> 代表的是实例本身。</li><li>实例方法通常用于定义对象的行为。</li></ul></li><li><p><strong>类方法</strong>：</p><ul><li>类方法是作用于类本身的方法，使用 <code>@classmethod</code> 装饰器定义。它接收 <code>cls</code> 参数，表示类对象，而不是实例对象。</li><li>类方法可以访问和修改类属性。</li></ul></li><li><p><strong>静态方法</strong>：</p><ul><li>静态方法是类中的方法，但它既不依赖类属性也不依赖实例属性。静态方法使用<code>@staticmethod</code> 装饰器定义，通常用于执行与类相关但不需要访问类或实例的逻辑。</li></ul></li></ul><p>通过实例化类，可以获得对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实例化类，创建对象</span></span><br><span class="line">obj1 = MyClass(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">obj2 = MyClass(<span class="string">&quot;World&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>类</strong> 是抽象的模板，用于创建对象，它定义了对象的属性和行为。</li><li><strong>对象</strong> 是类的实例，每个对象都有自己独立的属性值和行为表现。</li></ul><h4 id="类的继承inheritance"><a class="markdownIt-Anchor" href="#类的继承inheritance"></a> 类的继承（Inheritance）</h4><p>继承是面向对象编程的核心概念之一，它允许一个类继承另一个类的属性和方法，从而避免代码重复，并能够对现有的类进行扩展。被继承的类称为<strong>父类（基类或超类）</strong>，继承的类称为<strong>子类（派生类）</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> makes a sound.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义子类，继承父类 Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> barks.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> meows.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化子类</span></span><br><span class="line">dog = Dog(<span class="string">&quot;Buddy&quot;</span>)</span><br><span class="line">cat = Cat(<span class="string">&quot;Whiskers&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dog.speak())  <span class="comment"># 输出: Buddy barks.</span></span><br><span class="line"><span class="built_in">print</span>(cat.speak())  <span class="comment"># 输出: Whiskers meows.</span></span><br></pre></td></tr></table></figure><p>继承的特点：</p><ul><li>子类继承父类的所有属性和方法，并且可以<strong>重写</strong>（override）父类的方法。</li><li>可以通过 <code>super()</code> 调用父类的方法。</li><li>支持多重继承，子类可以从多个父类继承。</li></ul><h4 id="类的多态polymorphism"><a class="markdownIt-Anchor" href="#类的多态polymorphism"></a> 类的多态（Polymorphism）</h4><p>多态允许不同的类实现相同的方法，而表现出不同的行为。它是一种编程能力，能够让相同的接口对不同的数据类型做出不同的响应，具体行为由具体的对象来决定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&quot;Subclass must implement this method.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Woof!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Meow!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">animal_sound</span>(<span class="params">animal</span>):</span><br><span class="line">    <span class="built_in">print</span>(animal.speak())</span><br><span class="line"></span><br><span class="line">dog = Dog()</span><br><span class="line">cat = Cat()</span><br><span class="line"></span><br><span class="line">animal_sound(dog)  <span class="comment"># 输出: Woof!</span></span><br><span class="line">animal_sound(cat)  <span class="comment"># 输出: Meow!</span></span><br></pre></td></tr></table></figure><h4 id="抽象类abstract-class"><a class="markdownIt-Anchor" href="#抽象类abstract-class"></a> 抽象类（Abstract Class）</h4><p>抽象类是不能被实例化的类，它用于定义方法的模板，而子类必须实现这些方法。Python 通过 <code>abc</code> 模块中的 <code>ABC</code> 类和 <code>abstractmethod</code> 装饰器来实现抽象类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Woof!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Meow!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># animal = Animal()  # 这会抛出错误，因为抽象类不能实例化</span></span><br><span class="line">dog = Dog()</span><br><span class="line"><span class="built_in">print</span>(dog.speak())  <span class="comment"># 输出: Woof!</span></span><br></pre></td></tr></table></figure><ul><li>抽象类定义了抽象方法，子类必须实现这些抽象方法。</li><li>抽象类提供了代码结构的基础框架，具体实现由子类负责。</li></ul><h4 id="组合composition"><a class="markdownIt-Anchor" href="#组合composition"></a> 组合（Composition）</h4><p>组合是一种设计原则，通过将对象的实例作为其他类的属性来实现。这种方法允许类之间的松散耦合。相比继承，组合通常提供了更大的灵活性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Engine started&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.engine = Engine()  <span class="comment"># 将 Engine 类实例作为 Car 的属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.engine.start()</span><br><span class="line"></span><br><span class="line">car = Car()</span><br><span class="line"><span class="built_in">print</span>(car.start())  <span class="comment"># 输出: Engine started</span></span><br></pre></td></tr></table></figure><h3 id="装饰器"><a class="markdownIt-Anchor" href="#装饰器"></a> 装饰器</h3><h4 id="装饰器的定义"><a class="markdownIt-Anchor" href="#装饰器的定义"></a> 装饰器的定义</h4><p>在 Python 中，<strong>装饰器</strong>（Decorator）是一种函数，允许你在不修改原有函数代码的情况下，动态地增加或修改该函数的功能。简单来说，装饰器是用来&quot;包装&quot;其他函数的函数，它允许你在运行时增加函数的功能，通常用于日志记录、权限检查、缓存、计时等功能。</p><p>装饰器本质上是一个函数，它接受一个函数作为输入，并返回一个新的函数（通常是原函数的增强版本）。这种方式可以帮助我们在不改变原函数代码的前提下，对其进行修改或扩展。</p><p>在 Python 中，装饰器使用 <code>@decorator_name</code> 语法应用到一个函数上。这个语法等价于调用装饰器函数并将目标函数作为参数传递给它。</p><p>下面是一系列针对装饰器的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个装饰器函数decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="comment"># 我们用函数wrapper来代表被装饰后的func函数，最后返回wrapper</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;end_time - start_time&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面这段代码在wrapper函数外面包裹了一个装饰器函数decorator，</span></span><br><span class="line"><span class="comment"># 使得wrapper函数的运行时间可以被检测。(*args, **kwargs)这两个参数可以代表传入的一切参数。</span></span><br><span class="line"><span class="comment"># 我们来看看如何使用它：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先定义一个square函数：</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span>  a*b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随后，使用装饰器装饰他，生成一个新的函数</span></span><br><span class="line">decorated_square = decorator(square)</span><br><span class="line"><span class="comment">#print(decorated_square(10,10))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际上，python提供了一个更简单的方法：</span></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span>  a*b</span><br><span class="line"><span class="comment"># 这样，直接执行square(10,10)，就能输出运行的时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然，我们也可以定义一个装饰器生成器:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">threshold</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="comment"># 这是一个python中自带的装饰器，可以使得wrapper函数继承func的名字等</span></span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            start_time = time.time()</span><br><span class="line">            result = func(*args, **kwargs)</span><br><span class="line">            end_time = time.time()</span><br><span class="line">            <span class="keyword">if</span> start_time - end_time &gt; threshold:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;超时&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰这个函数</span></span><br><span class="line"><span class="meta">@timer(<span class="params"><span class="number">0.1</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sleep_04</span>():</span><br><span class="line">    time.sleep(<span class="number">0.4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sleep_04()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者生成一个新函数</span></span><br><span class="line">sleep_04 = timer(<span class="number">0.1</span>)(sleep_04)</span><br><span class="line"><span class="built_in">print</span>(sleep_04.__name__)</span><br></pre></td></tr></table></figure><p>装饰器概念：用来装饰其他函数的，即为其他函数添加特定功能的函数 装饰器的基本原则：</p><ol><li>不能修改被装饰函数的源码</li><li>不能修改被装饰函数的调用方式</li></ol><h4 id="类中内置装饰器"><a class="markdownIt-Anchor" href="#类中内置装饰器"></a> 类中内置装饰器</h4><p>ython 类中自带的装饰器是一些内置的、专门用于修改类行为的装饰器。这些装饰器可以帮助你更方便地实现特定的类行为或功能扩展。常见的内置类装饰器包括 <code>@staticmethod</code>、<code>@classmethod</code>、<code>@property</code> 和 <code>@abstractmethod</code> 等。</p><h5 id="staticmethod"><a class="markdownIt-Anchor" href="#staticmethod"></a> @staticmethod</h5><p><code>@staticmethod</code> 装饰器用于将一个方法声明为静态方法。静态方法属于类本身，而不是类的实例。它不需要访问类实例或类本身，因此不需要传递 <code>self</code> 或 <code>cls</code> 参数。静态方法通常用于执行一些与类本身相关的任务，但不需要访问类的属性或实例数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用静态方法</span></span><br><span class="line">result = MyClass.add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出: 5</span></span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>静态方法不依赖于类的实例化。</li><li>可以通过类名或实例来调用静态方法，但通常通过类名调用。</li><li>适用于那些不需要访问实例或类属性的方法。</li></ul><h5 id="classmethod"><a class="markdownIt-Anchor" href="#classmethod"></a> @classmethod</h5><p><code>@classmethod</code> 装饰器用于将一个方法声明为类方法。类方法第一个参数是类本身（通常命名为 <code>cls</code>），而不是实例对象。类方法通常用于访问类属性或修改类状态，而不是实例状态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">increment_count</span>(<span class="params">cls</span>):</span><br><span class="line">        cls.count += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Count: <span class="subst">&#123;cls.count&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 调用类方法</span></span><br><span class="line">MyClass.increment_count()  <span class="comment"># 输出: Count: 1</span></span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>类方法不需要类的实例，可以通过类本身直接调用。</li><li>类方法第一个参数是类 <code>cls</code>，而不是实例 <code>self</code>。</li><li>类方法适用于操作类级别的数据或状态。</li></ul><h5 id="property"><a class="markdownIt-Anchor" href="#property"></a> @property</h5><p><code>@property</code> 装饰器用于将一个方法定义为属性。这意味着你可以像访问属性一样访问这个方法，而无需显式调用它。<code>@property</code> 是一种将类的方法转换为只读属性的方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, radius</span>):</span><br><span class="line">        self._radius = radius</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">radius</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._radius</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @radius.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">radius</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;Radius cannot be negative.&quot;</span>)</span><br><span class="line">        self._radius = value</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * self._radius * self._radius</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建圆对象</span></span><br><span class="line">circle = Circle(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(circle.area)  <span class="comment"># 输出: 78.5</span></span><br><span class="line">circle.radius = <span class="number">10</span>  <span class="comment"># 使用setter修改半径</span></span><br><span class="line"><span class="built_in">print</span>(circle.area)  <span class="comment"># 输出: 314.0</span></span><br></pre></td></tr></table></figure><p><strong>特点</strong></p><ul><li><code>@property</code> 使方法像属性一样访问。</li><li>可以使用 <code>@property</code> 和 <code>@property.setter</code> 来定义可读和可写的属性。</li><li>用于将计算逻辑封装成属性访问的形式。</li></ul><h5 id="abstractmethod"><a class="markdownIt-Anchor" href="#abstractmethod"></a> @abstractmethod</h5><p>详见上文</p><h3 id="魔法方法"><a class="markdownIt-Anchor" href="#魔法方法"></a> 魔法方法</h3><h4 id="重要的魔法方法"><a class="markdownIt-Anchor" href="#重要的魔法方法"></a> 重要的魔法方法</h4><p>在 Python 中，<strong>魔法方法</strong>（Magic Methods）又称为 <strong>特殊方法</strong>（Special Methods），是类中以双下划线 <code>__</code> 开头和结尾的方法。这些方法允许你对对象进行特定的操作或赋予对象特殊行为，从而让你可以定制 Python 对象的内建操作，比如加法、字符串表示、索引操作等。</p><p>魔法方法使得 Python 对象能够参与各种语言层面的操作，如算术运算、比较运算、类型转换、函数调用等，通常这些方法被 Python 内部调用，但你也可以自定义实现它们以修改对象行为。</p><p><strong><code>__new__(cls)</code></strong>：</p><ul><li>用于创建对象实例的方法。它通常与 <code>__init__</code> 一起使用，在实例化对象时首先被调用。<code>__new__</code> 返回一个新的对象实例，而 <code>__init__</code> 则用来初始化该实例。</li><li>当你继承 <code>__new__</code> 方法时，你可以控制对象创建的过程。</li></ul><p><strong><code>__init__(self, ...)</code></strong>：</p><ul><li>构造器，用于初始化对象实例。<code>__init__</code> 在 <code>__new__</code> 方法之后调用，并且在对象实例创建后立即执行。</li><li>它允许你在对象创建时设置初始属性。</li></ul><p><strong><code>__str__(self)</code></strong>：</p><ul><li>用于定义对象的字符串表示。当使用 <code>print()</code> 打印对象或使用 <code>str()</code> 函数时，<code>__str__</code> 方法被调用。</li><li>这个方法应该返回一个友好的、可读性强的字符串，用于展示对象的内容。</li></ul><p><strong><code>__getitem__(self, key)</code></strong>：</p><ul><li>用于定义对象的索引访问（例如 <code>obj[key]</code>）。<br /><strong><code>__setitem__(self, key, value)</code></strong>：</li><li>用于定义对象的索引赋值（例如 <code>obj[key] = value</code>）。<br /><strong><code>__delitem__(self, key)</code></strong>：</li><li>用于定义删除索引元素（例如 <code>del obj[key]</code>）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.data = data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data[index]</span><br><span class="line"></span><br><span class="line">my_list = MyList([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">1</span>])  <span class="comment"># 输出: 2</span></span><br></pre></td></tr></table></figure><p><strong><code>__call__(self, ...)</code></strong>：</p><ul><li>使对象成为可调用的（例如 <code>obj()</code>）。当对象像函数一样被调用时，Python 会调用 <code>obj.__call__()</code> 方法。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Adder</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> self.value + x</span><br><span class="line"></span><br><span class="line">add_five = Adder(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(add_five(<span class="number">3</span>))  <span class="comment"># 输出: 8</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>__enter__(self)</code></strong>：<ul><li>用于定义进入 <code>with</code> 语句时的行为。</li></ul></li><li><strong><code>__exit__(self, exc_type, exc_val, exc_tb)</code></strong>：<ul><li>用于定义退出 <code>with</code> 语句时的行为，处理异常等。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyContextManager</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Entering the context&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Exiting the context&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> exc_type:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Exception: <span class="subst">&#123;exc_val&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> MyContextManager():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Inside the context&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="类的参数下划线前缀"><a class="markdownIt-Anchor" href="#类的参数下划线前缀"></a> 类的参数下划线前缀</h3><h4 id="单下划线-_-前缀"><a class="markdownIt-Anchor" href="#单下划线-_-前缀"></a> 单下划线 <code>_</code> 前缀</h4><p>单下划线是 Python 的一种约定，用来标识一个变量或方法是“内部使用的”，即它不应该被外部直接访问。这种标识并不影响属性或方法的访问权限，但它是对其他开发者的一种提醒，告诉他们这些属性或方法是属于类的实现细节，应该尽量避免直接使用。</p><h4 id="双下划线-__-前缀"><a class="markdownIt-Anchor" href="#双下划线-__-前缀"></a> 双下划线 <code>__</code> 前缀</h4><p>双下划线前缀通常用于表示变量或方法是类的“私有”成员。它使得这些属性或方法不会被外部直接访问，而是通过名称修饰（name mangling）进行修改，使其在外部不可直接访问。这种命名约定旨在避免类的子类或外部代码意外覆盖或访问这些“私有”成员。</p><p><strong>用途：</strong></p><ul><li>强制私有化（name mangling）——Python 在名称前加上 <code>_ClassName</code>，使得外部不容易访问这些变量或方法。</li><li>通过这种方式，Python 希望防止类的外部代码直接访问和修改这些变量，但仍然允许子类通过继承来访问和修改这些变量。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__private_value = <span class="number">100</span>  <span class="comment"># 私有属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__private_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This is a private method.&quot;</span>)</span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line"><span class="built_in">print</span>(obj.__private_value)  <span class="comment"># 报错: AttributeError</span></span><br><span class="line">obj.__private_method()  <span class="comment"># 报错: AttributeError</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍一下Python类的装饰器和魔法方法，以及参数的下划线前缀&lt;/p&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
  <entry>
    <title>局域网访问服务器Docker下psql数据库的若干问题</title>
    <link href="https://atffang.github.io/2025/03/29/%E5%B1%80%E5%9F%9F%E7%BD%91%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8Docker%E4%B8%8Bpsql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/"/>
    <id>https://atffang.github.io/2025/03/29/%E5%B1%80%E5%9F%9F%E7%BD%91%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8Docker%E4%B8%8Bpsql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/</id>
    <published>2025-03-29T15:45:34.000Z</published>
    <updated>2025-03-30T01:41:37.613Z</updated>
    
    <content type="html"><![CDATA[<p>瞎捣鼓</p><span id="more"></span><p>最近有在实验室服务器的docker上部署服务的需求，将数据注入psql数据库并在docker环境中访问一切正常，然而在局域网下其他设备访问数据时，出现了一些问题，遂简单记录。</p><p>首先，由于postgresql数据库的默认端口为5432，然而docker仅仅预留了几个映射端口与外部通信，因此，需要修改psql的运行端口，这里我选择的映射端口为25002:2002。在 Docker 中，端口映射的格式通常是 host_port:container_port，即 宿主机端口:容器内端口。因此，首先需要修改psql的运行端口为2002。</p><p>找到<code>/etc/postgresql/14/main/postgresql.conf</code>配置文件，将<code>port = 5432</code>修改为制定端口，我这里为2002。</p><p>并添加：<code>listen_addresses = '*'</code>开启远程访问。</p><p>随后修改<code>/etc/postgresql/14/main/pg_hba.conf</code>来设置放行ip。设置规则为在实验室局域网下的ip全部放行，那么添加规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host    all             all             192.168.41.0/24          md5</span><br></pre></td></tr></table></figure><p>最后，重启服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/postgresql restart</span><br></pre></td></tr></table></figure><p>那么通过局域网下其他设备访问服务器的25002端口即可访问数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql -h 192.168.41.56 -p 25002 -U postgres -d shanghaipoidb</span><br></pre></td></tr></table></figure><p>尝试在命令行中远程连接，并未发生什么问题，但在pgadmin中连接却提示错误为一个172.x.x.x的ip被拒绝访问，如果出现这种情况，意味着 Docker 容器内的 PostgreSQL 服务绑定的是容器的内部网络 IP（例如 <code>172.x.x.x</code>），而不是宿主机的 IP 地址（例如 <code>192.x.x.x</code>）。当你使用 pgAdmin 连接时，pgAdmin 可能尝试直接连接容器的内部 IP 地址，而不是宿主机的地址，因此连接被拒绝。只需将改ip使用上面相同的方式加入放行ip即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;瞎捣鼓&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Entropy and Cross Entropy</title>
    <link href="https://atffang.github.io/2025/03/15/Entropy%20and%20Cross%20Entropy/"/>
    <id>https://atffang.github.io/2025/03/15/Entropy%20and%20Cross%20Entropy/</id>
    <published>2025-03-15T07:50:46.000Z</published>
    <updated>2025-03-15T07:54:54.142Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍一下熵与交叉熵</p><span id="more"></span><img src="https://atffang.github.io/2025/03/15/Entropy and Cross Entropy/Entropy and Cross Entropy.png"/>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单介绍一下熵与交叉熵&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>3D Guassian Splatting</title>
    <link href="https://atffang.github.io/2025/03/12/3D%20Guassian%20Splatting/"/>
    <id>https://atffang.github.io/2025/03/12/3D%20Guassian%20Splatting/</id>
    <published>2025-03-12T15:12:43.000Z</published>
    <updated>2025-03-14T14:20:08.440Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/graphdeco-inria/gaussian-splatting">https://github.com/graphdeco-inria/gaussian-splatting</a> 复现</p><span id="more"></span><h3 id="环境构建"><a class="markdownIt-Anchor" href="#环境构建"></a> 环境构建</h3><p>首先clone仓库<a href="https://github.com/graphdeco-inria/gaussian-splatting">https://github.com/graphdeco-inria/gaussian-splatting</a></p><p>理论上应该按照源码提供的environment.yml文件创建环境，即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env create --file environment.<span class="property">yml</span></span><br></pre></td></tr></table></figure><p>然而，实验室服务器CUDA版本为12.2，environment.yml中指定的python和pytorch版本过低，因此，选择自己配置环境python3.10, cuda12.1对应的pytorch（适用于12.2）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">conda create -n gaussian_splatting python=<span class="number">3.10</span></span><br><span class="line">conda activate gaussian_splatting</span><br><span class="line">pip3 install torch torchvision torchaudio --index-url <span class="attr">https</span>:<span class="comment">//download.pytorch.org/whl/cu121</span></span><br><span class="line"></span><br><span class="line">pip install submodules\diff-gaussian-rasterization</span><br><span class="line">pip install submodules\simple-knn</span><br><span class="line">pip install plyfile</span><br><span class="line">pip install tqdm</span><br><span class="line">pip install opencv-python</span><br><span class="line">pip install joblib</span><br></pre></td></tr></table></figure><h3 id="数据前期处理程序"><a class="markdownIt-Anchor" href="#数据前期处理程序"></a> 数据前期处理程序</h3><p>都是在Windows端下载。</p><p>下载ffmep <a href="http://www.gyan.dev/ffmpeg/builds/">www.gyan.dev/ffmpeg/builds/</a></p><p>将文件夹重命名为ffmep，将bin文件路径加入系统变量</p><p>下载COLMAP</p><p><a href="https://github.com/colmap/colmap/releases">https://github.com/colmap/colmap/releases</a></p><p>将文件夹重命名为COLMAP，将bin文件路径加入系统变量</p><p>下载ImageMagick</p><h3 id="训练流程"><a class="markdownIt-Anchor" href="#训练流程"></a> 训练流程</h3><ul><li>Step1：录制视频，使用ffmep进行抽帧</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.<span class="property">mp4</span> -vf <span class="string">&quot;setpts=0.2*PTS&quot;</span> input/input_%4d.<span class="property">jpg</span></span><br></pre></td></tr></table></figure><p>-i input.mp4：指定输入视频文件为 input.mp4。<br />-vf “setpts=0.2 PTS”：这是一个视频过滤器选项，其中 setpts 指令用来设置帧的时间戳（Presentation TimeStamps）。这里的表达式 0.2PTS 表示将当前帧的时间戳乘以0.2，这意味着抽取出来的帧之间的间隔被拉长了5倍，所以生成的图像序列将以视频原始速度的五分之一进行播放。<br />input/input_%4d.jpg：这是输出文件格式及路径，其中 %4d 是一个格式化占位符，它会被自增的整数所替换，确保每个输出文件名是唯一的。例如，输出的第一帧将会被保存为 input/input_0001.jpg，第二帧为 input/input_0002.jpg，依此类推。同时，输出目录被指定为 input/ 目录下。</p><ul><li>Step2：使用3D Guassian Splatting仓库中包含的convert.py完成图像数据转换。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python convert.<span class="property">py</span> -s &lt;location&gt; [--resize]</span><br></pre></td></tr></table></figure><p>location：代表需要转化的图像位置，图像必须被放在一个input文件夹下，location则为其父文件夹。<br />[–resize]：表示是否变化图像尺寸，可选</p><ul><li>Step3：将转换完成的图像，包括images和sparse两个文件夹，放在一个父文件夹下作为输入数据，进行训练。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train.py -s &lt;location&gt;</span><br></pre></td></tr></table></figure><p>location：代表数据路径</p><h3 id="结果预览"><a class="markdownIt-Anchor" href="#结果预览"></a> 结果预览</h3><p>拉取代码：<a href="https://github.com/kishimisu/Gaussian-Splatting-WebGL.git%EF%BC%8C%E5%9C%A8live">https://github.com/kishimisu/Gaussian-Splatting-WebGL.git，在live</a> server中打开网页，上传ply数据：<br /><img src="https://atffang.github.io/2025/03/12/3D Guassian Splatting/try.png"/></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/graphdeco-inria/gaussian-splatting&quot;&gt;https://github.com/graphdeco-inria/gaussian-splatting&lt;/a&gt; 复现&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>GNNWR</title>
    <link href="https://atffang.github.io/2025/03/06/GNNWR/"/>
    <id>https://atffang.github.io/2025/03/06/GNNWR/</id>
    <published>2025-03-06T06:47:14.000Z</published>
    <updated>2025-03-06T11:57:51.840Z</updated>
    
    <content type="html"><![CDATA[<p>Geographically neural network weighted regression for the accurate estimation of spatial non-stationarity</p><span id="more"></span><img src="https://atffang.github.io/2025/03/06/GNNWR/GNNWR.png">]]></content>
    
    
    <summary type="html">&lt;p&gt;Geographically neural network weighted regression for the accurate estimation of spatial non-stationarity&lt;/p&gt;</summary>
    
    
    
    <category term="空间分析与GIS算法" scheme="https://atffang.github.io/categories/%E7%A9%BA%E9%97%B4%E5%88%86%E6%9E%90%E4%B8%8EGIS%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>threading or multiprocessing?</title>
    <link href="https://atffang.github.io/2025/02/26/threading%20or%20multiprocessing/"/>
    <id>https://atffang.github.io/2025/02/26/threading%20or%20multiprocessing/</id>
    <published>2025-02-26T02:06:23.000Z</published>
    <updated>2025-05-09T02:35:29.499Z</updated>
    
    <content type="html"><![CDATA[<p>Python  两种并发机制</p><span id="more"></span><h4 id="threading"><a class="markdownIt-Anchor" href="#threading"></a> Threading</h4><p><strong>threading（线程编程）</strong> 是一种通过在程序中创建多个执行单元（线程），来实现并发执行的技术。线程共享同一个进程的内存空间，并且可以并行处理任务，因此能够更好地利用多核CPU资源。</p><p><strong>线程</strong>是进程中的一个轻量级执行单元，一个进程可以包含多个线程。这些线程共享相同的内存和资源（如文件句柄），但每个线程有自己的栈和指令指针。由于共享内存，线程间通信非常快速，但也更容易出现竞争条件、死锁等同步问题。</p><p><strong>threading经典应用场景</strong></p><ul><li><strong>I/O操作</strong>：在等待I/O操作完成（如文件读写、网络请求）时，其他线程可以继续执行任务，提高程序响应速度。</li><li><strong>并发任务</strong>：例如图形界面的响应式编程、并行数据处理。</li></ul><p><strong>An Example</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_data</span>(<span class="params">url</span>):</span><br><span class="line">response = request.get(url)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;response.status_code&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">urls = [url1, url2……]</span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">t = threading.Thread(target=fetch_data, args=(url,))</span><br><span class="line">threads.append(t)</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">t.join()</span><br></pre></td></tr></table></figure><p>多进程虽然能够处理并行任务，但每个进程的上下文切换会有额外的开销，这会影响程序的性能。因此，此类简单的请求工作更加适合使用多线程。</p><p><strong>optimize</strong>：<br />concurrent 是 Python 标准库中的一个模块，专门用于支持 <strong>并发编程</strong>。它提供了高层次的接口来管理多个任务的并发执行，主要包括线程和进程池的管理。<br />如果存在大量需要访问的url，可以使用concurrent.futures进行线程池创建。通过线程池，可以控制同时运行的线程数，避免一次性创建过多的线程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 任务函数：访问URL</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_data</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Finished download from: <span class="subst">&#123;url&#125;</span>, Status Code: <span class="subst">&#123;response.status_code&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> requests.RequestException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error downloading <span class="subst">&#123;url&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># URL列表（假设有1000个）</span></span><br><span class="line">urls = [<span class="string">&quot;http://example.com&quot;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用ThreadPoolExecutor</span></span><br><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">20</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    <span class="comment"># 提交所有任务</span></span><br><span class="line">    futures = [executor.submit(fetch_data, url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等待任务完成</span></span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> concurrent.futures.as_completed(futures):</span><br><span class="line">        future.result()  <span class="comment"># 可以获取返回结果，若不关心结果，可以省略这行</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;All downloads complete.&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="multiprocessing"><a class="markdownIt-Anchor" href="#multiprocessing"></a> Multiprocessing</h4><p><strong>multiprocessing（多进程编程）</strong> 是通过在程序中创建多个独立的进程，每个进程都有自己的内存空间、资源和执行单元，以实现并行处理。多进程能够避免线程竞争带来的问题，因为各个进程之间是独立的。</p><p><strong>进程</strong>是操作系统中资源分配的基本单位。每个进程都有自己的地址空间、文件句柄、栈、堆等资源。不同于线程，进程之间不共享内存，这意味着它们更加安全，但也需要更复杂的通信方式（如管道、消息队列）来进行数据交换。</p><p><strong>multiprocessing的典型应用场景：</strong></p><ul><li><strong>高可靠性任务</strong>：当某些任务必须完全隔离，不能因为其他任务的崩溃而被干扰时（如服务器进程、数据库进程等）。</li><li><strong>CPU密集型任务</strong>：需要大量的计算资源时（如图像处理、科学计算），使用多进程可以充分利用多核CPU的性能。</li></ul><p>关于multiprocessing的基础应用，在之前的文章《python并行运算》中做过大致介绍。<br /><strong>An Example</strong><br />并行矩阵运算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义矩阵计算任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">matrix_square</span>(<span class="params">matrix</span>):</span><br><span class="line">    <span class="keyword">return</span> np.dot(matrix, matrix)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 创建一个随机矩阵</span></span><br><span class="line">    matrices = [np.random.rand(<span class="number">1000</span>, <span class="number">1000</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用进程池进行并行计算</span></span><br><span class="line">    <span class="keyword">with</span> mp.Pool(processes=<span class="number">4</span>) <span class="keyword">as</span> pool:</span><br><span class="line">        results = pool.<span class="built_in">map</span>(matrix_square, matrices)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Matrix calculations completed.&quot;</span>)</span><br></pre></td></tr></table></figure><p>并行蒙特卡洛模拟：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义蒙特卡罗模拟任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">monte_carlo_pi</span>(<span class="params">num_samples</span>):</span><br><span class="line">    inside_circle = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_samples):</span><br><span class="line">        x, y = random.random(), random.random()</span><br><span class="line">        <span class="keyword">if</span> x**<span class="number">2</span> + y**<span class="number">2</span> &lt;= <span class="number">1</span>:</span><br><span class="line">            inside_circle += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> inside_circle / num_samples * <span class="number">4</span>  <span class="comment"># 估算π值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 每个进程处理100万次采样</span></span><br><span class="line">    num_samples = <span class="number">1000000</span></span><br><span class="line">    num_processes = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用进程池并行运行蒙特卡罗模拟</span></span><br><span class="line">    <span class="keyword">with</span> mp.Pool(processes=num_processes) <span class="keyword">as</span> pool:</span><br><span class="line">        pi_estimates = pool.<span class="built_in">map</span>(monte_carlo_pi, [num_samples] * num_processes)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算平均值</span></span><br><span class="line">    pi_average = <span class="built_in">sum</span>(pi_estimates) / num_processes</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Estimated Pi: <span class="subst">&#123;pi_average&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>optimize</strong>：<br />concurrent.futures的ProcessPoolExecutor ，类似于multiprocessing.Pool</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义蒙特卡罗模拟任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">monte_carlo_pi</span>(<span class="params">num_samples</span>):</span><br><span class="line">    inside_circle = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_samples):</span><br><span class="line">        x, y = random.random(), random.random()</span><br><span class="line">        <span class="keyword">if</span> x**<span class="number">2</span> + y**<span class="number">2</span> &lt;= <span class="number">1</span>:</span><br><span class="line">            inside_circle += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> inside_circle / num_samples * <span class="number">4</span>  <span class="comment"># 估算π值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    num_samples = <span class="number">1000000</span>  <span class="comment"># 每个进程采样的数量</span></span><br><span class="line">    num_processes = <span class="number">4</span>      <span class="comment"># 进程数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用 ProcessPoolExecutor 并行执行任务</span></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ProcessPoolExecutor(max_workers=num_processes) <span class="keyword">as</span> executor:</span><br><span class="line">        futures = [executor.submit(monte_carlo_pi, num_samples) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_processes)]</span><br><span class="line">        pi_estimates = [f.result() <span class="keyword">for</span> f <span class="keyword">in</span> concurrent.futures.as_completed(futures)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算平均估算值</span></span><br><span class="line">    pi_average = <span class="built_in">sum</span>(pi_estimates) / num_processes</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Estimated Pi: <span class="subst">&#123;pi_average&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="concurrentfeatures优势"><a class="markdownIt-Anchor" href="#concurrentfeatures优势"></a> concurrent.features优势</h4><ol><li><p><strong>统一接口</strong>：无论是使用 ThreadPoolExecutor 还是 ProcessPoolExecutor，它们的 API 是统一的，可以很方便地根据任务类型选择是使用线程还是进程。</p></li><li><p><strong>简化代码</strong>：相比 multiprocessing.Pool，concurrent.futures 提供了更高层的接口，如 submit() 和 as_completed()，减少了复杂度。</p></li><li><p><strong>Future 对象</strong>：submit() 方法返回 Future 对象，允许在任务完成后方便地获取结果、检查任务状态或处理异常。</p></li><li><p><strong>自动资源管理</strong>：concurrent.futures 支持上下文管理（with 语句），能够自动管理进程或线程池的生命周期，避免资源泄漏。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;Python  两种并发机制&lt;/p&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript异步机制浅析</title>
    <link href="https://atffang.github.io/2025/02/22/JavaScript%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/"/>
    <id>https://atffang.github.io/2025/02/22/JavaScript%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/</id>
    <published>2025-02-22T02:02:54.000Z</published>
    <updated>2025-02-22T02:02:54.948Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>asyncio浅析</title>
    <link href="https://atffang.github.io/2025/02/21/asyncio%E6%B5%85%E6%9E%90/"/>
    <id>https://atffang.github.io/2025/02/21/asyncio%E6%B5%85%E6%9E%90/</id>
    <published>2025-02-21T02:10:09.000Z</published>
    <updated>2025-05-09T02:35:09.879Z</updated>
    
    <content type="html"><![CDATA[<p>Python  asyncio机制</p><span id="more"></span><h4 id="event-loop"><a class="markdownIt-Anchor" href="#event-loop"></a> Event Loop</h4><p>Python 的事件循环（Event Loop）是异步编程中的核心概念，通常与 <code>asyncio</code> 库（Python3.5引入）一起使用。事件循环负责管理和调度异步任务，确保这些任务在适当的时机运行，而不会阻塞主线程。事件循环是基于“协程”的模型，它允许 Python 程序在进行 I/O 操作或等待某些事件时不会阻塞其他操作，从而提高程序的效率。<br /><strong>event loop</strong>的基本流程：</p><ul><li><strong>定义协程（coroutines）</strong>: 协程是 Python 中的异步函数（Asynchronous Functions），通常用 <code>async def</code> 定义，执行时不会立即执行，而是返回一个 “awaitable” 对象。</li><li><strong>创建事件循环</strong>: <code>asyncio.get_event_loop()</code> 创建一个事件循环，它负责管理和调度所有异步任务。</li><li><strong>运行事件循环</strong>: 使用 <code>loop.run_until_complete()</code> 来启动事件循环，直到指定的任务完成。</li><li><strong>任务调度</strong>: 事件循环会根据任务的状态（是否可以执行）决定哪个任务应该被调度执行。</li></ul><h4 id="asyncio-的基本使用规范"><a class="markdownIt-Anchor" href="#asyncio-的基本使用规范"></a> asyncio 的基本使用规范</h4><p>异步函数是使用 <code>async def</code> 语法定义的，它们返回一个协程对象，而不是直接执行函数体。当你调用这个函数时，实际上返回的是一个尚未完成的协程对象，需要通过事件循环来执行。<br />定义一个异步函数如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">my_coroutine</span>():</span><br><span class="line"><span class="keyword">await</span> asynico.sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><strong><code>await</code></strong> 用于挂起协程的执行，等待一个异步操作完成后再继续执行。</p><p><code>asyncio</code> 提供了事件循环来调度异步任务。事件循环负责执行异步任务，并管理任务的调度。</p><ul><li><strong><code>asyncio.run()</code></strong>：用于运行一个顶层的异步函数。它创建一个事件循环并运行直到协程执行完成，最后关闭事件循环。通常用于程序的入口。</li><li><strong><code>asyncio.run(main())</code></strong>：该方法会运行 <code>main()</code> 协程，并在执行完毕后关闭事件循环。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 asyncio.run() 启动事件循环</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">await</span> my_coroutine()</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><ul><li><strong><code>asyncio.gather()</code></strong>：用于并发执行多个协程，等到所有协程都完成后，才继续执行后面的代码。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">another_coroutine</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始执行另一个协程&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;另一个协程执行结束&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(my_coroutine(), another_coroutine())  <span class="comment"># 并发执行</span></span><br></pre></td></tr></table></figure><p>除了 <code>asyncio.run()</code>，还可以手动管理事件循环和任务，使用 <code>loop.create_task()</code> 和 <code>loop.run_until_complete()</code> 来调度任务。</p><ul><li><strong><code>loop.create_task()</code></strong>：用于创建一个协程任务，返回一个任务对象。</li><li><strong><code>loop.run_until_complete()</code></strong>：用于启动事件循环并直到某个任务完成。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">task1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务 1 开始&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务 1 完成&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">task2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务 2 开始&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务 2 完成&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动创建事件循环并执行任务</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">tasks = [loop.create_task(task1()), loop.create_task(task2())]</span><br><span class="line">loop.run_until_complete(asyncio.gather(*tasks))</span><br></pre></td></tr></table></figure><ul><li>在协程中使用 <code>try...except</code> 来捕获异常。</li><li>异常会在协程执行过程中抛出并传播，直到被捕获为止。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">my_coroutine</span>():</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;发生错误&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> my_coroutine()</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;捕获异常: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><ul><li>事件循环会在程序执行完毕后自动关闭，但如果需要提前停止，可以调用 <code>loop.stop()</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始任务&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;结束任务&quot;</span>)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(main())</span><br><span class="line">loop.stop()  <span class="comment"># 关闭事件循环</span></span><br></pre></td></tr></table></figure><h4 id="简单的上手"><a class="markdownIt-Anchor" href="#简单的上手"></a> 简单的上手</h4><p>以下代码请在python3.7及以上运行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#这是一个coroutine</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="comment">#await将asyncio.sleep(delay)这个coroutine转化为task</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="built_in">print</span>(what)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;start at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment">#await将say_after()这个coroutine转化为task，并告知Event Loop</span></span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">2</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finish at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start at 15:46:50</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">finish at 15:46:53</span><br></pre></td></tr></table></figure><p>花费三秒。整个事件过程为：<br />asyncio.run将main()包装为了一个task，然后加入Event Loop。Event Loop中此时只有一个task即main，随即运行main()，控制权交付于main。<br />随后，main将控制权交给say_after，运行say_after(1, “hello”)这个coroutine function得到一个coroutine object（代码并不会在这里阻塞），而await将coroutine object转化为task，放到Event Loop中，并告知需要等待这个sleep，控制权交给sleep。<br />1s后，sleep这个task完成，Event Loop将控制权交还给main，main运行下一个task，重复上述步骤。</p><p>但是这样并没有意义，运行的事件并没有缩短。因此，我们改变策略为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="built_in">print</span>(what)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">task1 = asyncio.create_task(say_after(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>))</span><br><span class="line">task2 = asyncio.create_task(say_after(<span class="number">2</span>, <span class="string">&quot;world&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;start at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finish at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start at 16:23:01</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">finish at 16:23:03</span><br></pre></td></tr></table></figure><p>这次，我们预先包装了两个task，在其放到Event Loop后，Event Loop并不会将控制权交由task，从而实现串行。</p><p>如何返回task的值？<br />最简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">await</span> task1</span><br></pre></td></tr></table></figure><p>使用gather:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">await</span> asyncio.gather(task1, taske)</span><br></pre></td></tr></table></figure><p>gather还有一个好处，可以不需要包装为task再输入，可以直接读取coroutine：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">say_after(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>), </span><br><span class="line">say_after(<span class="number">2</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Python  asyncio机制&lt;/p&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
</feed>
