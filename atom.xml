<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ATField&#39; s BLOG</title>
  
  <subtitle>ATField</subtitle>
  <link href="https://atffang.github.io/atom.xml" rel="self"/>
  
  <link href="https://atffang.github.io/"/>
  <updated>2025-03-30T07:55:53.030Z</updated>
  <id>https://atffang.github.io/</id>
  
  <author>
    <name>FangTianYao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>详解Python类的装饰器和魔法方法</title>
    <link href="https://atffang.github.io/2025/03/30/%E8%AF%A6%E8%A7%A3Python%E7%B1%BB%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"/>
    <id>https://atffang.github.io/2025/03/30/%E8%AF%A6%E8%A7%A3Python%E7%B1%BB%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/</id>
    <published>2025-03-30T07:51:52.000Z</published>
    <updated>2025-03-30T07:55:53.030Z</updated>
    
    <content type="html"><![CDATA[<p>介绍一下Python类的装饰器和魔法方法，以及参数的下划线前缀</p><span id="more"></span><p>一个记性并不好的人将在工作中学习到的碎片化的知识统筹起来必须要依靠记录，非常不幸的是鄙人在记忆力不强的前提下依然没有良好的记录习惯，加之跑通万岁的实用主义，使得写的代码总是看起来比较低级而缺乏优雅的气息，与本人气质强烈不符。痛定思痛，痛改前非，先从一个相对基础但极其重要的机制开始记起：Python中类的装饰器与魔法方法。</p><h3 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h3><h4 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h4><p>在 Python 中，类是面向对象编程（OOP）的核心概念，它用于定义对象的蓝图。类封装了数据（属性）和行为（方法），通过类可以创建多个具有相同结构的实例对象。通过使用类，代码可以更具组织性和模块化，易于扩展和维护。</p><p>在 Python 中定义一个基本的类非常简单，使用关键字 <code>class</code> 进行定义。以下是一个简单的类定义的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="comment"># 这是一个类属性</span></span><br><span class="line">    class_variable = <span class="string">&quot;I am a class variable&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这是初始化方法（构造函数），当类实例化时会自动调用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="comment"># 这是实例属性</span></span><br><span class="line">        self.instance_variable = value</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这是一个实例方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">instance_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;This is an instance method and instance_variable is: <span class="subst">&#123;self.instance_variable&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这是一个类方法，使用 @classmethod 装饰器定义</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">class_method</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;This is a class method and class_variable is: <span class="subst">&#123;cls.class_variable&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这是一个静态方法，使用 @staticmethod 装饰器定义</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">static_method</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;This is a static method&quot;</span></span><br></pre></td></tr></table></figure><p>在上述代码中，展现了类的各个组成部分为：</p><ul><li><p><strong>类属性</strong>：</p><ul><li>类属性是类级别的属性，它们对于所有实例都是共享的。类属性通常定义在类体中，独立于任何方法。</li><li>在上例中，<code>class_variable</code> 就是一个类属性，所有对象共享同一个值。</li></ul></li><li><p><strong>实例属性</strong>：</p><ul><li>实例属性是在类的实例化过程中通过 <code>__init__()</code> 方法（也叫构造函数）动态创建的，每个实例有独立的属性值。</li><li>通过 <code>self.instance_variable = value</code>，我们为每个实例赋予不同的 <code>instance_variable</code> 值。</li></ul></li><li><p><strong>实例方法</strong>：</p><ul><li>实例方法是类中定义的普通方法，它们操作实例属性，且必须接受参数 <code>self</code>，<code>self</code> 代表的是实例本身。</li><li>实例方法通常用于定义对象的行为。</li></ul></li><li><p><strong>类方法</strong>：</p><ul><li>类方法是作用于类本身的方法，使用 <code>@classmethod</code> 装饰器定义。它接收 <code>cls</code> 参数，表示类对象，而不是实例对象。</li><li>类方法可以访问和修改类属性。</li></ul></li><li><p><strong>静态方法</strong>：</p><ul><li>静态方法是类中的方法，但它既不依赖类属性也不依赖实例属性。静态方法使用<code>@staticmethod</code> 装饰器定义，通常用于执行与类相关但不需要访问类或实例的逻辑。</li></ul></li></ul><p>通过实例化类，可以获得对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实例化类，创建对象</span></span><br><span class="line">obj1 = MyClass(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">obj2 = MyClass(<span class="string">&quot;World&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>类</strong> 是抽象的模板，用于创建对象，它定义了对象的属性和行为。</li><li><strong>对象</strong> 是类的实例，每个对象都有自己独立的属性值和行为表现。</li></ul><h4 id="类的继承inheritance"><a class="markdownIt-Anchor" href="#类的继承inheritance"></a> 类的继承（Inheritance）</h4><p>继承是面向对象编程的核心概念之一，它允许一个类继承另一个类的属性和方法，从而避免代码重复，并能够对现有的类进行扩展。被继承的类称为<strong>父类（基类或超类）</strong>，继承的类称为<strong>子类（派生类）</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> makes a sound.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义子类，继承父类 Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> barks.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> meows.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化子类</span></span><br><span class="line">dog = Dog(<span class="string">&quot;Buddy&quot;</span>)</span><br><span class="line">cat = Cat(<span class="string">&quot;Whiskers&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dog.speak())  <span class="comment"># 输出: Buddy barks.</span></span><br><span class="line"><span class="built_in">print</span>(cat.speak())  <span class="comment"># 输出: Whiskers meows.</span></span><br></pre></td></tr></table></figure><p>继承的特点：</p><ul><li>子类继承父类的所有属性和方法，并且可以<strong>重写</strong>（override）父类的方法。</li><li>可以通过 <code>super()</code> 调用父类的方法。</li><li>支持多重继承，子类可以从多个父类继承。</li></ul><h4 id="类的多态polymorphism"><a class="markdownIt-Anchor" href="#类的多态polymorphism"></a> 类的多态（Polymorphism）</h4><p>多态允许不同的类实现相同的方法，而表现出不同的行为。它是一种编程能力，能够让相同的接口对不同的数据类型做出不同的响应，具体行为由具体的对象来决定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&quot;Subclass must implement this method.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Woof!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Meow!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">animal_sound</span>(<span class="params">animal</span>):</span><br><span class="line">    <span class="built_in">print</span>(animal.speak())</span><br><span class="line"></span><br><span class="line">dog = Dog()</span><br><span class="line">cat = Cat()</span><br><span class="line"></span><br><span class="line">animal_sound(dog)  <span class="comment"># 输出: Woof!</span></span><br><span class="line">animal_sound(cat)  <span class="comment"># 输出: Meow!</span></span><br></pre></td></tr></table></figure><h4 id="抽象类abstract-class"><a class="markdownIt-Anchor" href="#抽象类abstract-class"></a> 抽象类（Abstract Class）</h4><p>抽象类是不能被实例化的类，它用于定义方法的模板，而子类必须实现这些方法。Python 通过 <code>abc</code> 模块中的 <code>ABC</code> 类和 <code>abstractmethod</code> 装饰器来实现抽象类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Woof!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Meow!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># animal = Animal()  # 这会抛出错误，因为抽象类不能实例化</span></span><br><span class="line">dog = Dog()</span><br><span class="line"><span class="built_in">print</span>(dog.speak())  <span class="comment"># 输出: Woof!</span></span><br></pre></td></tr></table></figure><ul><li>抽象类定义了抽象方法，子类必须实现这些抽象方法。</li><li>抽象类提供了代码结构的基础框架，具体实现由子类负责。</li></ul><h4 id="组合composition"><a class="markdownIt-Anchor" href="#组合composition"></a> 组合（Composition）</h4><p>组合是一种设计原则，通过将对象的实例作为其他类的属性来实现。这种方法允许类之间的松散耦合。相比继承，组合通常提供了更大的灵活性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Engine started&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.engine = Engine()  <span class="comment"># 将 Engine 类实例作为 Car 的属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.engine.start()</span><br><span class="line"></span><br><span class="line">car = Car()</span><br><span class="line"><span class="built_in">print</span>(car.start())  <span class="comment"># 输出: Engine started</span></span><br></pre></td></tr></table></figure><h3 id="装饰器"><a class="markdownIt-Anchor" href="#装饰器"></a> 装饰器</h3><h4 id="装饰器的定义"><a class="markdownIt-Anchor" href="#装饰器的定义"></a> 装饰器的定义</h4><p>在 Python 中，<strong>装饰器</strong>（Decorator）是一种函数，允许你在不修改原有函数代码的情况下，动态地增加或修改该函数的功能。简单来说，装饰器是用来&quot;包装&quot;其他函数的函数，它允许你在运行时增加函数的功能，通常用于日志记录、权限检查、缓存、计时等功能。</p><p>装饰器本质上是一个函数，它接受一个函数作为输入，并返回一个新的函数（通常是原函数的增强版本）。这种方式可以帮助我们在不改变原函数代码的前提下，对其进行修改或扩展。</p><p>在 Python 中，装饰器使用 <code>@decorator_name</code> 语法应用到一个函数上。这个语法等价于调用装饰器函数并将目标函数作为参数传递给它。</p><p>下面是一系列针对装饰器的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个装饰器函数decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="comment"># 我们用函数wrapper来代表被装饰后的func函数，最后返回wrapper</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;end_time - start_time&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面这段代码在wrapper函数外面包裹了一个装饰器函数decorator，</span></span><br><span class="line"><span class="comment"># 使得wrapper函数的运行时间可以被检测。(*args, **kwargs)这两个参数可以代表传入的一切参数。</span></span><br><span class="line"><span class="comment"># 我们来看看如何使用它：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先定义一个square函数：</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span>  a*b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随后，使用装饰器装饰他，生成一个新的函数</span></span><br><span class="line">decorated_square = decorator(square)</span><br><span class="line"><span class="comment">#print(decorated_square(10,10))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际上，python提供了一个更简单的方法：</span></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span>  a*b</span><br><span class="line"><span class="comment"># 这样，直接执行square(10,10)，就能输出运行的时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然，我们也可以定义一个装饰器生成器:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">threshold</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="comment"># 这是一个python中自带的装饰器，可以使得wrapper函数继承func的名字等</span></span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            start_time = time.time()</span><br><span class="line">            result = func(*args, **kwargs)</span><br><span class="line">            end_time = time.time()</span><br><span class="line">            <span class="keyword">if</span> start_time - end_time &gt; threshold:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;超时&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰这个函数</span></span><br><span class="line"><span class="meta">@timer(<span class="params"><span class="number">0.1</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sleep_04</span>():</span><br><span class="line">    time.sleep(<span class="number">0.4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sleep_04()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者生成一个新函数</span></span><br><span class="line">sleep_04 = timer(<span class="number">0.1</span>)(sleep_04)</span><br><span class="line"><span class="built_in">print</span>(sleep_04.__name__)</span><br></pre></td></tr></table></figure><p>装饰器概念：用来装饰其他函数的，即为其他函数添加特定功能的函数 装饰器的基本原则：</p><ol><li>不能修改被装饰函数的源码</li><li>不能修改被装饰函数的调用方式</li></ol><h4 id="类中内置装饰器"><a class="markdownIt-Anchor" href="#类中内置装饰器"></a> 类中内置装饰器</h4><p>ython 类中自带的装饰器是一些内置的、专门用于修改类行为的装饰器。这些装饰器可以帮助你更方便地实现特定的类行为或功能扩展。常见的内置类装饰器包括 <code>@staticmethod</code>、<code>@classmethod</code>、<code>@property</code> 和 <code>@abstractmethod</code> 等。</p><h5 id="staticmethod"><a class="markdownIt-Anchor" href="#staticmethod"></a> @staticmethod</h5><p><code>@staticmethod</code> 装饰器用于将一个方法声明为静态方法。静态方法属于类本身，而不是类的实例。它不需要访问类实例或类本身，因此不需要传递 <code>self</code> 或 <code>cls</code> 参数。静态方法通常用于执行一些与类本身相关的任务，但不需要访问类的属性或实例数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用静态方法</span></span><br><span class="line">result = MyClass.add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出: 5</span></span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>静态方法不依赖于类的实例化。</li><li>可以通过类名或实例来调用静态方法，但通常通过类名调用。</li><li>适用于那些不需要访问实例或类属性的方法。</li></ul><h5 id="classmethod"><a class="markdownIt-Anchor" href="#classmethod"></a> @classmethod</h5><p><code>@classmethod</code> 装饰器用于将一个方法声明为类方法。类方法第一个参数是类本身（通常命名为 <code>cls</code>），而不是实例对象。类方法通常用于访问类属性或修改类状态，而不是实例状态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">increment_count</span>(<span class="params">cls</span>):</span><br><span class="line">        cls.count += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Count: <span class="subst">&#123;cls.count&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 调用类方法</span></span><br><span class="line">MyClass.increment_count()  <span class="comment"># 输出: Count: 1</span></span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>类方法不需要类的实例，可以通过类本身直接调用。</li><li>类方法第一个参数是类 <code>cls</code>，而不是实例 <code>self</code>。</li><li>类方法适用于操作类级别的数据或状态。</li></ul><h5 id="property"><a class="markdownIt-Anchor" href="#property"></a> @property</h5><p><code>@property</code> 装饰器用于将一个方法定义为属性。这意味着你可以像访问属性一样访问这个方法，而无需显式调用它。<code>@property</code> 是一种将类的方法转换为只读属性的方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, radius</span>):</span><br><span class="line">        self._radius = radius</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">radius</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._radius</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @radius.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">radius</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;Radius cannot be negative.&quot;</span>)</span><br><span class="line">        self._radius = value</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * self._radius * self._radius</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建圆对象</span></span><br><span class="line">circle = Circle(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(circle.area)  <span class="comment"># 输出: 78.5</span></span><br><span class="line">circle.radius = <span class="number">10</span>  <span class="comment"># 使用setter修改半径</span></span><br><span class="line"><span class="built_in">print</span>(circle.area)  <span class="comment"># 输出: 314.0</span></span><br></pre></td></tr></table></figure><p><strong>特点</strong></p><ul><li><code>@property</code> 使方法像属性一样访问。</li><li>可以使用 <code>@property</code> 和 <code>@property.setter</code> 来定义可读和可写的属性。</li><li>用于将计算逻辑封装成属性访问的形式。</li></ul><h5 id="abstractmethod"><a class="markdownIt-Anchor" href="#abstractmethod"></a> @abstractmethod</h5><p>详见上文</p><h3 id="魔法方法"><a class="markdownIt-Anchor" href="#魔法方法"></a> 魔法方法</h3><h4 id="重要的魔法方法"><a class="markdownIt-Anchor" href="#重要的魔法方法"></a> 重要的魔法方法</h4><p>在 Python 中，<strong>魔法方法</strong>（Magic Methods）又称为 <strong>特殊方法</strong>（Special Methods），是类中以双下划线 <code>__</code> 开头和结尾的方法。这些方法允许你对对象进行特定的操作或赋予对象特殊行为，从而让你可以定制 Python 对象的内建操作，比如加法、字符串表示、索引操作等。</p><p>魔法方法使得 Python 对象能够参与各种语言层面的操作，如算术运算、比较运算、类型转换、函数调用等，通常这些方法被 Python 内部调用，但你也可以自定义实现它们以修改对象行为。</p><p><strong><code>__new__(cls)</code></strong>：</p><ul><li>用于创建对象实例的方法。它通常与 <code>__init__</code> 一起使用，在实例化对象时首先被调用。<code>__new__</code> 返回一个新的对象实例，而 <code>__init__</code> 则用来初始化该实例。</li><li>当你继承 <code>__new__</code> 方法时，你可以控制对象创建的过程。</li></ul><p><strong><code>__init__(self, ...)</code></strong>：</p><ul><li>构造器，用于初始化对象实例。<code>__init__</code> 在 <code>__new__</code> 方法之后调用，并且在对象实例创建后立即执行。</li><li>它允许你在对象创建时设置初始属性。</li></ul><p><strong><code>__str__(self)</code></strong>：</p><ul><li>用于定义对象的字符串表示。当使用 <code>print()</code> 打印对象或使用 <code>str()</code> 函数时，<code>__str__</code> 方法被调用。</li><li>这个方法应该返回一个友好的、可读性强的字符串，用于展示对象的内容。</li></ul><p><strong><code>__getitem__(self, key)</code></strong>：</p><ul><li>用于定义对象的索引访问（例如 <code>obj[key]</code>）。<br /><strong><code>__setitem__(self, key, value)</code></strong>：</li><li>用于定义对象的索引赋值（例如 <code>obj[key] = value</code>）。<br /><strong><code>__delitem__(self, key)</code></strong>：</li><li>用于定义删除索引元素（例如 <code>del obj[key]</code>）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.data = data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data[index]</span><br><span class="line"></span><br><span class="line">my_list = MyList([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">1</span>])  <span class="comment"># 输出: 2</span></span><br></pre></td></tr></table></figure><p><strong><code>__call__(self, ...)</code></strong>：</p><ul><li>使对象成为可调用的（例如 <code>obj()</code>）。当对象像函数一样被调用时，Python 会调用 <code>obj.__call__()</code> 方法。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Adder</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> self.value + x</span><br><span class="line"></span><br><span class="line">add_five = Adder(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(add_five(<span class="number">3</span>))  <span class="comment"># 输出: 8</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>__enter__(self)</code></strong>：<ul><li>用于定义进入 <code>with</code> 语句时的行为。</li></ul></li><li><strong><code>__exit__(self, exc_type, exc_val, exc_tb)</code></strong>：<ul><li>用于定义退出 <code>with</code> 语句时的行为，处理异常等。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyContextManager</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Entering the context&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Exiting the context&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> exc_type:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Exception: <span class="subst">&#123;exc_val&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> MyContextManager():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Inside the context&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="类的参数下划线前缀"><a class="markdownIt-Anchor" href="#类的参数下划线前缀"></a> 类的参数下划线前缀</h3><h4 id="单下划线-_-前缀"><a class="markdownIt-Anchor" href="#单下划线-_-前缀"></a> 单下划线 <code>_</code> 前缀</h4><p>单下划线是 Python 的一种约定，用来标识一个变量或方法是“内部使用的”，即它不应该被外部直接访问。这种标识并不影响属性或方法的访问权限，但它是对其他开发者的一种提醒，告诉他们这些属性或方法是属于类的实现细节，应该尽量避免直接使用。</p><h4 id="双下划线-__-前缀"><a class="markdownIt-Anchor" href="#双下划线-__-前缀"></a> 双下划线 <code>__</code> 前缀</h4><p>双下划线前缀通常用于表示变量或方法是类的“私有”成员。它使得这些属性或方法不会被外部直接访问，而是通过名称修饰（name mangling）进行修改，使其在外部不可直接访问。这种命名约定旨在避免类的子类或外部代码意外覆盖或访问这些“私有”成员。</p><p><strong>用途：</strong></p><ul><li>强制私有化（name mangling）——Python 在名称前加上 <code>_ClassName</code>，使得外部不容易访问这些变量或方法。</li><li>通过这种方式，Python 希望防止类的外部代码直接访问和修改这些变量，但仍然允许子类通过继承来访问和修改这些变量。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__private_value = <span class="number">100</span>  <span class="comment"># 私有属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__private_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This is a private method.&quot;</span>)</span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line"><span class="built_in">print</span>(obj.__private_value)  <span class="comment"># 报错: AttributeError</span></span><br><span class="line">obj.__private_method()  <span class="comment"># 报错: AttributeError</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍一下Python类的装饰器和魔法方法，以及参数的下划线前缀&lt;/p&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
  <entry>
    <title>局域网访问服务器Docker下psql数据库的若干问题</title>
    <link href="https://atffang.github.io/2025/03/29/%E5%B1%80%E5%9F%9F%E7%BD%91%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8Docker%E4%B8%8Bpsql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/"/>
    <id>https://atffang.github.io/2025/03/29/%E5%B1%80%E5%9F%9F%E7%BD%91%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8Docker%E4%B8%8Bpsql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/</id>
    <published>2025-03-29T15:45:34.000Z</published>
    <updated>2025-03-30T01:41:37.613Z</updated>
    
    <content type="html"><![CDATA[<p>瞎捣鼓</p><span id="more"></span><p>最近有在实验室服务器的docker上部署服务的需求，将数据注入psql数据库并在docker环境中访问一切正常，然而在局域网下其他设备访问数据时，出现了一些问题，遂简单记录。</p><p>首先，由于postgresql数据库的默认端口为5432，然而docker仅仅预留了几个映射端口与外部通信，因此，需要修改psql的运行端口，这里我选择的映射端口为25002:2002。在 Docker 中，端口映射的格式通常是 host_port:container_port，即 宿主机端口:容器内端口。因此，首先需要修改psql的运行端口为2002。</p><p>找到<code>/etc/postgresql/14/main/postgresql.conf</code>配置文件，将<code>port = 5432</code>修改为制定端口，我这里为2002。</p><p>并添加：<code>listen_addresses = '*'</code>开启远程访问。</p><p>随后修改<code>/etc/postgresql/14/main/pg_hba.conf</code>来设置放行ip。设置规则为在实验室局域网下的ip全部放行，那么添加规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host    all             all             192.168.41.0/24          md5</span><br></pre></td></tr></table></figure><p>最后，重启服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/postgresql restart</span><br></pre></td></tr></table></figure><p>那么通过局域网下其他设备访问服务器的25002端口即可访问数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql -h 192.168.41.56 -p 25002 -U postgres -d shanghaipoidb</span><br></pre></td></tr></table></figure><p>尝试在命令行中远程连接，并未发生什么问题，但在pgadmin中连接却提示错误为一个172.x.x.x的ip被拒绝访问，如果出现这种情况，意味着 Docker 容器内的 PostgreSQL 服务绑定的是容器的内部网络 IP（例如 <code>172.x.x.x</code>），而不是宿主机的 IP 地址（例如 <code>192.x.x.x</code>）。当你使用 pgAdmin 连接时，pgAdmin 可能尝试直接连接容器的内部 IP 地址，而不是宿主机的地址，因此连接被拒绝。只需将改ip使用上面相同的方式加入放行ip即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;瞎捣鼓&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Entropy and Cross Entropy</title>
    <link href="https://atffang.github.io/2025/03/15/Entropy%20and%20Cross%20Entropy/"/>
    <id>https://atffang.github.io/2025/03/15/Entropy%20and%20Cross%20Entropy/</id>
    <published>2025-03-15T07:50:46.000Z</published>
    <updated>2025-03-15T07:54:54.142Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍一下熵与交叉熵</p><span id="more"></span><img src="https://atffang.github.io/2025/03/15/Entropy and Cross Entropy/Entropy and Cross Entropy.png"/>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单介绍一下熵与交叉熵&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>3D Guassian Splatting</title>
    <link href="https://atffang.github.io/2025/03/12/3D%20Guassian%20Splatting/"/>
    <id>https://atffang.github.io/2025/03/12/3D%20Guassian%20Splatting/</id>
    <published>2025-03-12T15:12:43.000Z</published>
    <updated>2025-03-14T14:20:08.440Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/graphdeco-inria/gaussian-splatting">https://github.com/graphdeco-inria/gaussian-splatting</a> 复现</p><span id="more"></span><h3 id="环境构建"><a class="markdownIt-Anchor" href="#环境构建"></a> 环境构建</h3><p>首先clone仓库<a href="https://github.com/graphdeco-inria/gaussian-splatting">https://github.com/graphdeco-inria/gaussian-splatting</a></p><p>理论上应该按照源码提供的environment.yml文件创建环境，即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env create --file environment.<span class="property">yml</span></span><br></pre></td></tr></table></figure><p>然而，实验室服务器CUDA版本为12.2，environment.yml中指定的python和pytorch版本过低，因此，选择自己配置环境python3.10, cuda12.1对应的pytorch（适用于12.2）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">conda create -n gaussian_splatting python=<span class="number">3.10</span></span><br><span class="line">conda activate gaussian_splatting</span><br><span class="line">pip3 install torch torchvision torchaudio --index-url <span class="attr">https</span>:<span class="comment">//download.pytorch.org/whl/cu121</span></span><br><span class="line"></span><br><span class="line">pip install submodules\diff-gaussian-rasterization</span><br><span class="line">pip install submodules\simple-knn</span><br><span class="line">pip install plyfile</span><br><span class="line">pip install tqdm</span><br><span class="line">pip install opencv-python</span><br><span class="line">pip install joblib</span><br></pre></td></tr></table></figure><h3 id="数据前期处理程序"><a class="markdownIt-Anchor" href="#数据前期处理程序"></a> 数据前期处理程序</h3><p>都是在Windows端下载。</p><p>下载ffmep <a href="http://www.gyan.dev/ffmpeg/builds/">www.gyan.dev/ffmpeg/builds/</a></p><p>将文件夹重命名为ffmep，将bin文件路径加入系统变量</p><p>下载COLMAP</p><p><a href="https://github.com/colmap/colmap/releases">https://github.com/colmap/colmap/releases</a></p><p>将文件夹重命名为COLMAP，将bin文件路径加入系统变量</p><p>下载ImageMagick</p><h3 id="训练流程"><a class="markdownIt-Anchor" href="#训练流程"></a> 训练流程</h3><ul><li>Step1：录制视频，使用ffmep进行抽帧</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.<span class="property">mp4</span> -vf <span class="string">&quot;setpts=0.2*PTS&quot;</span> input/input_%4d.<span class="property">jpg</span></span><br></pre></td></tr></table></figure><p>-i input.mp4：指定输入视频文件为 input.mp4。<br />-vf “setpts=0.2 PTS”：这是一个视频过滤器选项，其中 setpts 指令用来设置帧的时间戳（Presentation TimeStamps）。这里的表达式 0.2PTS 表示将当前帧的时间戳乘以0.2，这意味着抽取出来的帧之间的间隔被拉长了5倍，所以生成的图像序列将以视频原始速度的五分之一进行播放。<br />input/input_%4d.jpg：这是输出文件格式及路径，其中 %4d 是一个格式化占位符，它会被自增的整数所替换，确保每个输出文件名是唯一的。例如，输出的第一帧将会被保存为 input/input_0001.jpg，第二帧为 input/input_0002.jpg，依此类推。同时，输出目录被指定为 input/ 目录下。</p><ul><li>Step2：使用3D Guassian Splatting仓库中包含的convert.py完成图像数据转换。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python convert.<span class="property">py</span> -s &lt;location&gt; [--resize]</span><br></pre></td></tr></table></figure><p>location：代表需要转化的图像位置，图像必须被放在一个input文件夹下，location则为其父文件夹。<br />[–resize]：表示是否变化图像尺寸，可选</p><ul><li>Step3：将转换完成的图像，包括images和sparse两个文件夹，放在一个父文件夹下作为输入数据，进行训练。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train.py -s &lt;location&gt;</span><br></pre></td></tr></table></figure><p>location：代表数据路径</p><h3 id="结果预览"><a class="markdownIt-Anchor" href="#结果预览"></a> 结果预览</h3><p>拉取代码：<a href="https://github.com/kishimisu/Gaussian-Splatting-WebGL.git%EF%BC%8C%E5%9C%A8live">https://github.com/kishimisu/Gaussian-Splatting-WebGL.git，在live</a> server中打开网页，上传ply数据：<br /><img src="https://atffang.github.io/2025/03/12/3D Guassian Splatting/try.png"/></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/graphdeco-inria/gaussian-splatting&quot;&gt;https://github.com/graphdeco-inria/gaussian-splatting&lt;/a&gt; 复现&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>GNNWR</title>
    <link href="https://atffang.github.io/2025/03/06/GNNWR/"/>
    <id>https://atffang.github.io/2025/03/06/GNNWR/</id>
    <published>2025-03-06T06:47:14.000Z</published>
    <updated>2025-03-06T11:57:51.840Z</updated>
    
    <content type="html"><![CDATA[<p>Geographically neural network weighted regression for the accurate estimation of spatial non-stationarity</p><span id="more"></span><img src="https://atffang.github.io/2025/03/06/GNNWR/GNNWR.png">]]></content>
    
    
    <summary type="html">&lt;p&gt;Geographically neural network weighted regression for the accurate estimation of spatial non-stationarity&lt;/p&gt;</summary>
    
    
    
    <category term="空间分析与GIS算法" scheme="https://atffang.github.io/categories/%E7%A9%BA%E9%97%B4%E5%88%86%E6%9E%90%E4%B8%8EGIS%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>threading or multiprocessing?</title>
    <link href="https://atffang.github.io/2025/02/26/threading%20or%20multiprocessing/"/>
    <id>https://atffang.github.io/2025/02/26/threading%20or%20multiprocessing/</id>
    <published>2025-02-26T02:06:23.000Z</published>
    <updated>2025-02-26T03:18:10.861Z</updated>
    
    <content type="html"><![CDATA[<p>Python  两种并发机制</p><span id="more"></span><h4 id="threading"><a class="markdownIt-Anchor" href="#threading"></a> Threading</h4><p><strong>threading（线程编程）</strong> 是一种通过在程序中创建多个执行单元（线程），来实现并发执行的技术。线程共享同一个进程的内存空间，并且可以并行处理任务，因此能够更好地利用多核CPU资源。</p><p><strong>线程</strong>是进程中的一个轻量级执行单元，一个进程可以包含多个线程。这些线程共享相同的内存和资源（如文件句柄），但每个线程有自己的栈和指令指针。由于共享内存，线程间通信非常快速，但也更容易出现竞争条件、死锁等同步问题。</p><p><strong>threading经典应用场景</strong></p><ul><li><strong>I/O操作</strong>：在等待I/O操作完成（如文件读写、网络请求）时，其他线程可以继续执行任务，提高程序响应速度。</li><li><strong>并发任务</strong>：例如图形界面的响应式编程、并行数据处理。</li></ul><p><strong>An Example</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_data</span>(<span class="params">url</span>):</span><br><span class="line">response = request.get(url)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;response.status_code&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">urls = [url1, url2……]</span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">t = threading.Thread(target=fetch_data, args=(url,))</span><br><span class="line">threads.append(t)</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">t.join()</span><br></pre></td></tr></table></figure><p>多进程虽然能够处理并行任务，但每个进程的上下文切换会有额外的开销，这会影响程序的性能。因此，此类简单的请求工作更加适合使用多线程。</p><p><strong>optimize</strong>：<br />concurrent 是 Python 标准库中的一个模块，专门用于支持 <strong>并发编程</strong>。它提供了高层次的接口来管理多个任务的并发执行，主要包括线程和进程池的管理。<br />如果存在大量需要访问的url，可以使用concurrent.futures进行线程池创建。通过线程池，可以控制同时运行的线程数，避免一次性创建过多的线程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 任务函数：访问URL</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_data</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Finished download from: <span class="subst">&#123;url&#125;</span>, Status Code: <span class="subst">&#123;response.status_code&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> requests.RequestException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error downloading <span class="subst">&#123;url&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># URL列表（假设有1000个）</span></span><br><span class="line">urls = [<span class="string">&quot;http://example.com&quot;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用ThreadPoolExecutor</span></span><br><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">20</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    <span class="comment"># 提交所有任务</span></span><br><span class="line">    futures = [executor.submit(fetch_data, url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等待任务完成</span></span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> concurrent.futures.as_completed(futures):</span><br><span class="line">        future.result()  <span class="comment"># 可以获取返回结果，若不关心结果，可以省略这行</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;All downloads complete.&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="multiprocessing"><a class="markdownIt-Anchor" href="#multiprocessing"></a> Multiprocessing</h4><p><strong>multiprocessing（多进程编程）</strong> 是通过在程序中创建多个独立的进程，每个进程都有自己的内存空间、资源和执行单元，以实现并行处理。多进程能够避免线程竞争带来的问题，因为各个进程之间是独立的。</p><p><strong>进程</strong>是操作系统中资源分配的基本单位。每个进程都有自己的地址空间、文件句柄、栈、堆等资源。不同于线程，进程之间不共享内存，这意味着它们更加安全，但也需要更复杂的通信方式（如管道、消息队列）来进行数据交换。</p><p><strong>multiprocessing的典型应用场景：</strong></p><ul><li><strong>高可靠性任务</strong>：当某些任务必须完全隔离，不能因为其他任务的崩溃而被干扰时（如服务器进程、数据库进程等）。</li><li><strong>CPU密集型任务</strong>：需要大量的计算资源时（如图像处理、科学计算），使用多进程可以充分利用多核CPU的性能。</li></ul><p>关于multiprocessing的基础应用，在之前的文章《python并行运算》中做过大致介绍。<br /><strong>An Example</strong><br />并行矩阵运算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义矩阵计算任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">matrix_square</span>(<span class="params">matrix</span>):</span><br><span class="line">    <span class="keyword">return</span> np.dot(matrix, matrix)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 创建一个随机矩阵</span></span><br><span class="line">    matrices = [np.random.rand(<span class="number">1000</span>, <span class="number">1000</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用进程池进行并行计算</span></span><br><span class="line">    <span class="keyword">with</span> mp.Pool(processes=<span class="number">4</span>) <span class="keyword">as</span> pool:</span><br><span class="line">        results = pool.<span class="built_in">map</span>(matrix_square, matrices)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Matrix calculations completed.&quot;</span>)</span><br></pre></td></tr></table></figure><p>并行蒙特卡洛模拟：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义蒙特卡罗模拟任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">monte_carlo_pi</span>(<span class="params">num_samples</span>):</span><br><span class="line">    inside_circle = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_samples):</span><br><span class="line">        x, y = random.random(), random.random()</span><br><span class="line">        <span class="keyword">if</span> x**<span class="number">2</span> + y**<span class="number">2</span> &lt;= <span class="number">1</span>:</span><br><span class="line">            inside_circle += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> inside_circle / num_samples * <span class="number">4</span>  <span class="comment"># 估算π值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 每个进程处理100万次采样</span></span><br><span class="line">    num_samples = <span class="number">1000000</span></span><br><span class="line">    num_processes = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用进程池并行运行蒙特卡罗模拟</span></span><br><span class="line">    <span class="keyword">with</span> mp.Pool(processes=num_processes) <span class="keyword">as</span> pool:</span><br><span class="line">        pi_estimates = pool.<span class="built_in">map</span>(monte_carlo_pi, [num_samples] * num_processes)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算平均值</span></span><br><span class="line">    pi_average = <span class="built_in">sum</span>(pi_estimates) / num_processes</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Estimated Pi: <span class="subst">&#123;pi_average&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>optimize</strong>：<br />concurrent.futures的ProcessPoolExecutor ，类似于multiprocessing.Pool</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义蒙特卡罗模拟任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">monte_carlo_pi</span>(<span class="params">num_samples</span>):</span><br><span class="line">    inside_circle = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_samples):</span><br><span class="line">        x, y = random.random(), random.random()</span><br><span class="line">        <span class="keyword">if</span> x**<span class="number">2</span> + y**<span class="number">2</span> &lt;= <span class="number">1</span>:</span><br><span class="line">            inside_circle += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> inside_circle / num_samples * <span class="number">4</span>  <span class="comment"># 估算π值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    num_samples = <span class="number">1000000</span>  <span class="comment"># 每个进程采样的数量</span></span><br><span class="line">    num_processes = <span class="number">4</span>      <span class="comment"># 进程数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用 ProcessPoolExecutor 并行执行任务</span></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ProcessPoolExecutor(max_workers=num_processes) <span class="keyword">as</span> executor:</span><br><span class="line">        futures = [executor.submit(monte_carlo_pi, num_samples) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_processes)]</span><br><span class="line">        pi_estimates = [f.result() <span class="keyword">for</span> f <span class="keyword">in</span> concurrent.futures.as_completed(futures)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算平均估算值</span></span><br><span class="line">    pi_average = <span class="built_in">sum</span>(pi_estimates) / num_processes</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Estimated Pi: <span class="subst">&#123;pi_average&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="concurrentfeatures优势"><a class="markdownIt-Anchor" href="#concurrentfeatures优势"></a> concurrent.features优势</h4><ol><li><p><strong>统一接口</strong>：无论是使用 ThreadPoolExecutor 还是 ProcessPoolExecutor，它们的 API 是统一的，可以很方便地根据任务类型选择是使用线程还是进程。</p></li><li><p><strong>简化代码</strong>：相比 multiprocessing.Pool，concurrent.futures 提供了更高层的接口，如 submit() 和 as_completed()，减少了复杂度。</p></li><li><p><strong>Future 对象</strong>：submit() 方法返回 Future 对象，允许在任务完成后方便地获取结果、检查任务状态或处理异常。</p></li><li><p><strong>自动资源管理</strong>：concurrent.futures 支持上下文管理（with 语句），能够自动管理进程或线程池的生命周期，避免资源泄漏。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;Python  两种并发机制&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript异步机制浅析</title>
    <link href="https://atffang.github.io/2025/02/22/JavaScript%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/"/>
    <id>https://atffang.github.io/2025/02/22/JavaScript%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/</id>
    <published>2025-02-22T02:02:54.000Z</published>
    <updated>2025-02-22T02:02:54.948Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>asyncio浅析</title>
    <link href="https://atffang.github.io/2025/02/21/asyncio%E6%B5%85%E6%9E%90/"/>
    <id>https://atffang.github.io/2025/02/21/asyncio%E6%B5%85%E6%9E%90/</id>
    <published>2025-02-21T02:10:09.000Z</published>
    <updated>2025-02-25T05:42:15.452Z</updated>
    
    <content type="html"><![CDATA[<p>Python  asyncio机制</p><span id="more"></span><h4 id="event-loop"><a class="markdownIt-Anchor" href="#event-loop"></a> Event Loop</h4><p>Python 的事件循环（Event Loop）是异步编程中的核心概念，通常与 <code>asyncio</code> 库（Python3.5引入）一起使用。事件循环负责管理和调度异步任务，确保这些任务在适当的时机运行，而不会阻塞主线程。事件循环是基于“协程”的模型，它允许 Python 程序在进行 I/O 操作或等待某些事件时不会阻塞其他操作，从而提高程序的效率。<br /><strong>event loop</strong>的基本流程：</p><ul><li><strong>定义协程（coroutines）</strong>: 协程是 Python 中的异步函数（Asynchronous Functions），通常用 <code>async def</code> 定义，执行时不会立即执行，而是返回一个 “awaitable” 对象。</li><li><strong>创建事件循环</strong>: <code>asyncio.get_event_loop()</code> 创建一个事件循环，它负责管理和调度所有异步任务。</li><li><strong>运行事件循环</strong>: 使用 <code>loop.run_until_complete()</code> 来启动事件循环，直到指定的任务完成。</li><li><strong>任务调度</strong>: 事件循环会根据任务的状态（是否可以执行）决定哪个任务应该被调度执行。</li></ul><h4 id="asyncio-的基本使用规范"><a class="markdownIt-Anchor" href="#asyncio-的基本使用规范"></a> asyncio 的基本使用规范</h4><p>异步函数是使用 <code>async def</code> 语法定义的，它们返回一个协程对象，而不是直接执行函数体。当你调用这个函数时，实际上返回的是一个尚未完成的协程对象，需要通过事件循环来执行。<br />定义一个异步函数如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">my_coroutine</span>():</span><br><span class="line"><span class="keyword">await</span> asynico.sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><strong><code>await</code></strong> 用于挂起协程的执行，等待一个异步操作完成后再继续执行。</p><p><code>asyncio</code> 提供了事件循环来调度异步任务。事件循环负责执行异步任务，并管理任务的调度。</p><ul><li><strong><code>asyncio.run()</code></strong>：用于运行一个顶层的异步函数。它创建一个事件循环并运行直到协程执行完成，最后关闭事件循环。通常用于程序的入口。</li><li><strong><code>asyncio.run(main())</code></strong>：该方法会运行 <code>main()</code> 协程，并在执行完毕后关闭事件循环。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 asyncio.run() 启动事件循环</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">await</span> my_coroutine()</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><ul><li><strong><code>asyncio.gather()</code></strong>：用于并发执行多个协程，等到所有协程都完成后，才继续执行后面的代码。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">another_coroutine</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始执行另一个协程&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;另一个协程执行结束&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(my_coroutine(), another_coroutine())  <span class="comment"># 并发执行</span></span><br></pre></td></tr></table></figure><p>除了 <code>asyncio.run()</code>，还可以手动管理事件循环和任务，使用 <code>loop.create_task()</code> 和 <code>loop.run_until_complete()</code> 来调度任务。</p><ul><li><strong><code>loop.create_task()</code></strong>：用于创建一个协程任务，返回一个任务对象。</li><li><strong><code>loop.run_until_complete()</code></strong>：用于启动事件循环并直到某个任务完成。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">task1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务 1 开始&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务 1 完成&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">task2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务 2 开始&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务 2 完成&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动创建事件循环并执行任务</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">tasks = [loop.create_task(task1()), loop.create_task(task2())]</span><br><span class="line">loop.run_until_complete(asyncio.gather(*tasks))</span><br></pre></td></tr></table></figure><ul><li>在协程中使用 <code>try...except</code> 来捕获异常。</li><li>异常会在协程执行过程中抛出并传播，直到被捕获为止。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">my_coroutine</span>():</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;发生错误&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> my_coroutine()</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;捕获异常: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><ul><li>事件循环会在程序执行完毕后自动关闭，但如果需要提前停止，可以调用 <code>loop.stop()</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始任务&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;结束任务&quot;</span>)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(main())</span><br><span class="line">loop.stop()  <span class="comment"># 关闭事件循环</span></span><br></pre></td></tr></table></figure><h4 id="简单的上手"><a class="markdownIt-Anchor" href="#简单的上手"></a> 简单的上手</h4><p>以下代码请在python3.7及以上运行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#这是一个coroutine</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="comment">#await将asyncio.sleep(delay)这个coroutine转化为task</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="built_in">print</span>(what)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;start at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment">#await将say_after()这个coroutine转化为task，并告知Event Loop</span></span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">2</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finish at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start at 15:46:50</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">finish at 15:46:53</span><br></pre></td></tr></table></figure><p>花费三秒。整个事件过程为：<br />asyncio.run将main()包装为了一个task，然后加入Event Loop。Event Loop中此时只有一个task即main，随即运行main()，控制权交付于main。<br />随后，main将控制权交给say_after，运行say_after(1, “hello”)这个coroutine function得到一个coroutine object（代码并不会在这里阻塞），而await将coroutine object转化为task，放到Event Loop中，并告知需要等待这个sleep，控制权交给sleep。<br />1s后，sleep这个task完成，Event Loop将控制权交还给main，main运行下一个task，重复上述步骤。</p><p>但是这样并没有意义，运行的事件并没有缩短。因此，我们改变策略为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="built_in">print</span>(what)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">task1 = asyncio.create_task(say_after(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>))</span><br><span class="line">task2 = asyncio.create_task(say_after(<span class="number">2</span>, <span class="string">&quot;world&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;start at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finish at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start at 16:23:01</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">finish at 16:23:03</span><br></pre></td></tr></table></figure><p>这次，我们预先包装了两个task，在其放到Event Loop后，Event Loop并不会将控制权交由task，从而实现串行。</p><p>如何返回task的值？<br />最简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">await</span> task1</span><br></pre></td></tr></table></figure><p>使用gather:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">await</span> asyncio.gather(task1, taske)</span><br></pre></td></tr></table></figure><p>gather还有一个好处，可以不需要包装为task再输入，可以直接读取coroutine：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">say_after(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>), </span><br><span class="line">say_after(<span class="number">2</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Python  asyncio机制&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>2025年终总结</title>
    <link href="https://atffang.github.io/2024/12/13/2025%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://atffang.github.io/2024/12/13/2025%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</id>
    <published>2024-12-13T08:00:49.000Z</published>
    <updated>2025-01-12T05:56:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>2025年终总结</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">即使您达不到幸福的境地，您也应该永远记住，您走的路是正确的，千万不要从这条路上离开。</span><br><span class="line">（陀《卡拉马佐夫兄弟》）</span><br></pre></td></tr></table></figure><p>坐在周六早上的咖啡店里，呼啸的冷风使遮阳伞不停浮动。杂七杂八的事情使我突然意识到这一年真的要结束了，即使这一过渡的时刻仅仅具有象征意义，我也想挣扎着写下年终的总结，由此钉下一颗锲子。很抱歉我无法详细的捕捉过去一年发生的所有事情，组成流水账式的记录，也无法坦率的将自己一切想法开诚布公，似乎最能够接受的方法是记录下这一年里发生的一些事。<br><br />四月，度过了自己第二十二个生日。虽然很恬不知耻，但我真的一直以为自己还没有二十岁。印象深刻的是买了个巴斯克蛋糕，却没比巴掌大多少，五个人分着吃了，显的有点局促。<br><br />毕业前，和yu去日本玩了一周。没有跟团，只是自己瞎走，我英语一般，日本人则更差。不过加上些比比划划大概能交流，大体上没有出什么纰漏。在东京落地，坐火车到伊东，往北到镰仓，再继续向北回东京，一路上一直是令人微笑的风光和中学生男男女女，不得不感叹非常值得一去。<br><br />6月19日，在闷热的体育馆听完毕业典礼，又在学衡路上吃了药膳鸡，匆匆忙忙花完红跑车（一家很不错的面包店）储值卡里的钱。回到宿舍将海量的私人物品一半打包，一半丢掉，陆续得知同学离开或即将离开的消息。毕业是2024年最重要的时刻，似乎在重要的时刻总是在做次要的事情。但因为这些次要的时刻，我会永远怀念南京。<br><br />暑假刚开始，买了把吉他。断断续续练了几个月，虽然称不上勤恳但也算坚持下来了，总算能嗯嗯啊啊边弹边唱一点，虽然不好听。<br><br />9月5日我来到上海，对新学校的一切都感到陌生。学校位于闵行区的最南端，再往南就是长江…没有人会对这个选址满意，更何况四周都是叮叮哐哐漫天扬尘的工地。令人宽慰的是我工作的大楼是较新且明亮的，而厕所也值得单独拿出来赞扬。过去的四个月间我并没有做出什么成果，也几乎没有看文章学习，忙碌于一些断断续续的开发工作，代码能力的确提升了一些。唯二骄傲的是给朋友的论文提供了一些帮助，以及用一个通宵换来了数学建模二等奖，至少不用发愁毕业要求了。<br><br />国庆回家，去常熟的养老院看望了卧病在床的爷爷。实际上他已身体僵硬，几乎不能动弹，帮他翻身的时候感觉就像搬弄风干的肉块。我们告别时，眼泪滑落在他因疾病而蜷缩的脸上，衰老的具象表达使我意识到在一个家庭中，成长和衰老是并行的。圣诞节，爷爷的母亲去世了，2024年的最后一个晚上，久病的爷爷突然恶化，进了icu。<br><br />十月中旬，在回南京作报告的前一个礼拜，收到了期刊的拒稿。其实我对结果并没有太多意外，只是希望晚点收到消息，好让我抱有幻想。我在这篇文章上倾注了许多时间和精力，也从中受益匪浅，但其中存在问题之巨使我始终无法说服自己这是一篇正确的文章，拖延回避到现在。<br /><br><br />十一月底，去苏州听了张悬的演唱会。这一年听了好几场live，这是印象最深的一场。也买了不少唱片，自然是花了不少钱，有机会整理一下。<br><br />就写到这吧，总之2024年算是结束了。应该怎么形容？可以说在碌碌无为中度过了人生重要的节点，可以说是平凡中存在伟大的光芒。我不喜欢这些宏大的词汇，但没有具体的例子可以指向我思维中的挣扎和变化。长期以来我一直是一个缺乏驱动力的人，在生活上事业上还是情感上都缺乏驱动力。内驱力的缺乏和偶发的热情交替控制自己，我几乎陷入了永不休止的圆周性思考，回答然后又反驳关于未来的问题。不过这样也好，矛盾人的才是具体的人，只是希望在2025年，一条明晰的道路能够浮现。<br /><br><br />再见！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2025年终总结&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>基于三维网格码LAS点云网格化存储与可视化方案介绍</title>
    <link href="https://atffang.github.io/2024/12/12/%E5%9F%BA%E4%BA%8E%E4%B8%89%E7%BB%B4%E7%BD%91%E6%A0%BC%E7%A0%81LAS%E7%82%B9%E4%BA%91%E7%BD%91%E6%A0%BC%E5%8C%96%E5%AD%98%E5%82%A8%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%A1%88%E4%BB%8B%E7%BB%8D/"/>
    <id>https://atffang.github.io/2024/12/12/%E5%9F%BA%E4%BA%8E%E4%B8%89%E7%BB%B4%E7%BD%91%E6%A0%BC%E7%A0%81LAS%E7%82%B9%E4%BA%91%E7%BD%91%E6%A0%BC%E5%8C%96%E5%AD%98%E5%82%A8%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%A1%88%E4%BB%8B%E7%BB%8D/</id>
    <published>2024-12-12T07:54:35.000Z</published>
    <updated>2024-12-12T08:16:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>三维网格码计算思路分享02。</p><span id="more"></span><p>基于上一篇博文中网格码正反算的方法和代码，写了一些基础控件以完成基于LAS三维点云的网格化计算以及数据预览，具体内容请看下图。</p><img src="https://atffang.github.io/2024/12/12/基于三维网格码LAS点云网格化存储与可视化方案介绍/WorkFlow.png"/>]]></content>
    
    
    <summary type="html">&lt;p&gt;三维网格码计算思路分享02。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>地球空间网格编码正反算实现</title>
    <link href="https://atffang.github.io/2024/12/11/%E5%9C%B0%E7%90%83%E7%A9%BA%E9%97%B4%E7%BD%91%E6%A0%BC%E7%BC%96%E7%A0%81%E6%AD%A3%E5%8F%8D%E7%AE%97%E5%AE%9E%E7%8E%B0/"/>
    <id>https://atffang.github.io/2024/12/11/%E5%9C%B0%E7%90%83%E7%A9%BA%E9%97%B4%E7%BD%91%E6%A0%BC%E7%BC%96%E7%A0%81%E6%AD%A3%E5%8F%8D%E7%AE%97%E5%AE%9E%E7%8E%B0/</id>
    <published>2024-12-11T11:41:43.000Z</published>
    <updated>2024-12-12T08:12:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>三维网格码计算思路分享。</p><span id="more"></span><p>似乎这两年低空经济成为了潮流方向，多了一些政策倾斜。前阵子刚有公司来交流相关事宜，16日华师大又要新成立低空经济研究中心，这两天组里为了这些事情鞍前马后，竟然有些仿佛过年的热闹。我负责的工作是探索其中一小个部分，也是一个非常小众的应用方向：地球空间网格码，该工作目前的理论基础为国标<strong>GBT 40087-2021 地球空间网格编码规则</strong>。<br />地球空间网格基于 GeoSOT(Geographical coordinate global Subdivision based on One-dimensioninteger and Two ton&quot;power)地球剖分模型,将地球空间统一剖分成不同尺度的网格单元,并按统一编码规则进行标识和表达,构建了网格化的地球空间数据组织参考框架。该框架支持地球表面空间和地球立体空间与地理空间信息的聚合,可有效解决物联网、大数据、云计算中海量空间信息在标识和表达上的唯一性、可读性、尺度性、关联性的瓶颈,实现了多源,多尺度数据网格化高效组织、处理和应用,突破了地理空间信息跨行业应用的技术壁垒,推动地球系统科学的发展。<br />具体来说，网格剖分分为经纬度的水平面剖分和高程的垂直剖分。具体过程相对复杂，参见上述国家标准，本文仅分享一些实现步骤。</p><h4 id="1-经纬度网格剖分"><a class="markdownIt-Anchor" href="#1-经纬度网格剖分"></a> 1. 经纬度网格剖分</h4><p>根据国标，经纬度剖分的步骤如下所示：</p><ol><li>将该点经、纬度坐标表示成GB/T16831规定的形式,即A’B’C.D&quot;;</li><li>将该点的坐标按度、分、秒、秒小数部分分别转换为二进制数。即将度|A|由十进制数转换成8 bit 定长二进制数(A)2, 将分B由一进制数转换成6bit定长二进制数(B)2, 将秒C由十进制数转换成6bit定长二进制数©2, 将秒以下数D由一进制数转换成11bit定长二进制数(D)2;</li><li>分别将经、纬度坐标度、分、秒及秒以下二进制数(A)2、(B)2、©2、(D)2直接拼接成31 bit定长二进制数(E)2, 即(E)2=(A)2(B)2©2(D)2, 分别得到两个 31 bit定长数经度(EL)2, 和纬度(EB)2;</li><li>将纬度(EB)2,前置、经度(EL)2后置, 采用莫顿交叉的方式生成62bit的混合代码(F)2, 例如若(EB)2为100111 ,(EL)2为011010, 则(EB)2在前, (EL)2在后的莫顿交叉运算结果为(F)2为 100101101110;</li><li>将二进制混合代码(F)2转成四进制编码(F)4;</li><li>根据待求网格的级别m, 将(F)4中后32-m位四进制的码元去掉得到(F’)4;</li><li>根据经度和纬度,前加上G0、G1、G2或G3即可得到网格代码。</li></ol><p>代码实现步骤如下：<br />定义一个类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WGS84coordinate</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, latitude, longitude, elevation</span>):</span><br><span class="line">        self.latitude = latitude</span><br><span class="line">        self.longitude = longitude</span><br><span class="line">        self.elevation = elevation</span><br></pre></td></tr></table></figure><p>实现步骤1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 将该点经、纬度坐标表示成GB/T16831规定的形式,即A&#x27;B&#x27;C.D&quot;;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decimal2dms</span>(<span class="params">self, decimal</span>):</span><br><span class="line">        degrees = <span class="built_in">int</span>(decimal)</span><br><span class="line">        minutes = <span class="built_in">int</span>((<span class="built_in">abs</span>(decimal) - <span class="built_in">abs</span>(degrees)) * <span class="number">60</span>)</span><br><span class="line">        seconds = (<span class="built_in">abs</span>(decimal) - <span class="built_in">abs</span>(degrees)) * <span class="number">60</span></span><br><span class="line">        seconds = (seconds - minutes) * <span class="number">60</span></span><br><span class="line">        seconds_fractional, seconds_integer = math.modf(seconds)</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">int</span>(degrees), <span class="built_in">int</span>(minutes), <span class="built_in">int</span>(seconds_integer), seconds_fractional]</span><br></pre></td></tr></table></figure><p>实现步骤2,3：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 将该点的坐标按度、分、秒、秒小数部分分别转换为二进制数, 拼为31 bit定长数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dms2bit</span>(<span class="params">self, dms</span>):</span><br><span class="line">        <span class="comment"># dms = [degrees, seconds_fractional, seconds_integer]</span></span><br><span class="line">        degrees, minutes, seconds_integer, seconds_fractional = dms</span><br><span class="line">        <span class="comment"># print(f&quot;度：&#123;degrees&#125;, 分：&#123;minutes&#125;, 秒整数：&#123;seconds_integer&#125;，秒小数：&#123;seconds_fractional&#125;&quot;)</span></span><br><span class="line">        degrees_bin, minutes_bin, seconds_integer_bin = <span class="string">f&quot;<span class="subst">&#123;degrees:08b&#125;</span>&quot;</span>, <span class="string">f&quot;<span class="subst">&#123;minutes:06b&#125;</span>&quot;</span>, <span class="string">f&quot;<span class="subst">&#123;seconds_integer:06b&#125;</span>&quot;</span></span><br><span class="line">        seconds_fractional_scaled = <span class="built_in">int</span>(seconds_fractional * <span class="number">2048</span>)</span><br><span class="line">        seconds_fractional_bin = <span class="string">f&quot;<span class="subst">&#123;seconds_fractional_scaled:011b&#125;</span>&quot;</span></span><br><span class="line">        <span class="comment"># print(f&quot;度：&#123;degrees_bin&#125;, 分：&#123;minutes_bin&#125;, 秒整数：&#123;seconds_integer_bin&#125;，秒小数：&#123;seconds_fractional_bin&#125;&quot;)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([degrees_bin, minutes_bin, seconds_integer_bin, seconds_fractional_bin])</span><br></pre></td></tr></table></figure><p>实现步骤4,5：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3. 将经纬度的编码莫顿交叉,转为四进制编码</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mortoncross</span>(<span class="params">self</span>):</span><br><span class="line">        latbit = self.dms2bit(self.decimal2dms(self.latitude))</span><br><span class="line">        lonbit = self.dms2bit(self.decimal2dms(self.longitude))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(latbit) == <span class="number">31</span> <span class="keyword">and</span> <span class="built_in">len</span>(lonbit) == <span class="number">31</span>, <span class="string">&quot;Both binary strings must be 31 bits long.&quot;</span></span><br><span class="line">        interleaved_bits = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>):</span><br><span class="line">            interleaved_bits.append(latbit[i])</span><br><span class="line">            interleaved_bits.append(lonbit[i])</span><br><span class="line">        bit2 = <span class="string">&#x27;&#x27;</span>.join(interleaved_bits)</span><br><span class="line">        bit4 = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">str</span>(<span class="built_in">int</span>(bit2[i:i+<span class="number">2</span>], <span class="number">2</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(bit2), <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bit4</span><br></pre></td></tr></table></figure><p>实现步骤6,7：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. 根据待求网格的级别m,将(F)中后32-m位四进制的码元去掉得到(F);</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gridcode</span>(<span class="params">self, m</span>):</span><br><span class="line">        bit4 = self.mortoncross()</span><br><span class="line">        gridcode = bit4[:m-<span class="number">32</span>]</span><br><span class="line"></span><br><span class="line">        gridcode = <span class="string">&quot;G0&quot;</span> + gridcode</span><br><span class="line">        <span class="comment"># 高度码实现下面讲。</span></span><br><span class="line">        elevationcode = self.elevationcode(m)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [gridcode, elevationcode]</span><br></pre></td></tr></table></figure><h4 id="2-高程网格剖分"><a class="markdownIt-Anchor" href="#2-高程网格剖分"></a> 2. 高程网格剖分</h4><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>n</mi><mo>=</mo><mfrac><msub><mi>θ</mi><mn>0</mn></msub><mi>θ</mi></mfrac><msub><mo><mi>log</mi><mo>⁡</mo></mo><mrow><mn>1</mn><mo>+</mo><msub><mi>θ</mi><mn>0</mn></msub></mrow></msub><mrow><mo fence="true">(</mo><mfrac><mrow><mi>H</mi><mo>+</mo><msub><mi>r</mi><mn>0</mn></msub></mrow><msub><mi>r</mi><mn>0</mn></msub></mfrac><mo fence="true">)</mo></mrow></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(5)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">n = \frac{\theta_0}{\theta} \log_{1 + \theta_0} \left( \frac{H + r_0}{r_0} \right) \tag{5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.24196799999999996em;"><span style="top:-2.45586em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.02778em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34424em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span><span class="tag"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">5</span></span><span class="mord">)</span></span></span></span></span></span></p><p>其中：</p><ul><li>( n ) —— 从地面向上（或向下）数第n层立体网格，n为整数，地面以上n大于等于0，地面以下 n &lt; 0；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\theta_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>—— 初始划分范围定义的基础网格（1°网格）对应的经（纬）跨度差，单位为弧度（rad）<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>0</mn></msub><mo>=</mo><mfrac><mi>π</mi><mn>180</mn></mfrac></mrow><annotation encoding="application/x-tex">\theta_0 = \frac{\pi}{180}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">8</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> —— 该网格对应的经（纬）跨度差，单位为弧度（rad）；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">r_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> —— 地球长半轴，单位为米（m），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mn>0</mn></msub><mo>=</mo><mn>6</mn><mtext> </mtext><mn>378</mn><mtext> </mtext><mn>137</mn></mrow><annotation encoding="application/x-tex">r_0 = 6\,378\,137</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">7</span><span class="mord">8</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mord">7</span></span></span></span>；<br />去掉层数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 高位的 0 形成的编码即为高度域编码。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算高度的网格码</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">elevationcode</span>(<span class="params">self, m</span>):</span><br><span class="line">        theta_0 = math.pi / <span class="number">180</span></span><br><span class="line">        theta = GridSpanlist[m-<span class="number">1</span>] * math.pi / <span class="number">180</span></span><br><span class="line">        H = self.elevation</span><br><span class="line">        r_0 = <span class="number">6378137</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 计算公式</span></span><br><span class="line">        n = (theta_0 / theta) * math.log((H + r_0) / r_0, (<span class="number">1</span> + theta_0))</span><br><span class="line">        n = math.floor(n)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            n = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">str</span>(<span class="built_in">bin</span>(n)[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(n) &lt; m:</span><br><span class="line">            n = <span class="string">&#x27;0&#x27;</span> * (m - <span class="built_in">len</span>(n)) + n</span><br><span class="line">        n = <span class="string">&quot;H&quot;</span> + n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure><h4 id="3-网格码反算"><a class="markdownIt-Anchor" href="#3-网格码反算"></a> 3. 网格码反算</h4><p>这一部分的具体求解国标并没有提及，因此只能尝试自行求解，代码准确性为止，仅供参考：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GridCode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, grid_code, elevation_code, m</span>):</span><br><span class="line">        self.grid_code = grid_code</span><br><span class="line">        self.elevation_code = elevation_code</span><br><span class="line">        self.m = m</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;格网编码：<span class="subst">&#123;self.grid_code, self.elevation_code&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">degridcode_bit2dms</span>(<span class="params">self, binary_str</span>):</span><br><span class="line">        degrees_bin = binary_str[<span class="number">0</span>:<span class="number">8</span>]    <span class="comment"># 前8位是度</span></span><br><span class="line">        minutes_bin = binary_str[<span class="number">8</span>:<span class="number">14</span>]   <span class="comment"># 接下来的6位是分</span></span><br><span class="line">        seconds_integer_bin = binary_str[<span class="number">14</span>:<span class="number">20</span>]  <span class="comment"># 接下来的6位是秒的整数部分</span></span><br><span class="line">        seconds_fractional_bin = binary_str[<span class="number">20</span>:<span class="number">31</span>]  <span class="comment"># 最后的11位是秒的小数部分</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将每个二进制子串转换回整数</span></span><br><span class="line">        degrees = <span class="built_in">int</span>(degrees_bin, <span class="number">2</span>)</span><br><span class="line">        minutes = <span class="built_in">int</span>(minutes_bin, <span class="number">2</span>)</span><br><span class="line">        seconds_integer = <span class="built_in">int</span>(seconds_integer_bin, <span class="number">2</span>)</span><br><span class="line">        seconds_fractional_scaled = <span class="built_in">int</span>(seconds_fractional_bin, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将秒的小数部分恢复为原来的小数值</span></span><br><span class="line">        seconds_fractional = seconds_fractional_scaled / <span class="number">2048</span></span><br><span class="line">        total_seconds = seconds_integer + seconds_fractional</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将秒数转换为分的部分（秒/60）</span></span><br><span class="line">        total_minutes = minutes + total_seconds / <span class="number">60</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将分数转换为度的部分（分/60）</span></span><br><span class="line">        decimal = <span class="built_in">abs</span>(degrees) + total_minutes / <span class="number">60</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> decimal</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 编码反算</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">degridcode</span>(<span class="params">self</span>):</span><br><span class="line">        gridcode = self.grid_code</span><br><span class="line">        gridcode = gridcode[<span class="number">2</span>:]</span><br><span class="line">        gridcode = gridcode.ljust(<span class="number">31</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        bit2 = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">bin</span>(<span class="built_in">int</span>(c, <span class="number">4</span>))[<span class="number">2</span>:].zfill(<span class="number">2</span>) <span class="keyword">for</span> c <span class="keyword">in</span> gridcode)</span><br><span class="line"></span><br><span class="line">        latbit = []</span><br><span class="line">        lonbit = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">32</span>):</span><br><span class="line">            latbit.append(bit2[i * <span class="number">2</span> - <span class="number">2</span>])</span><br><span class="line">            lonbit.append(bit2[i * <span class="number">2</span> - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        latcode = <span class="string">&#x27;&#x27;</span>.join(latbit)</span><br><span class="line">        loncode = <span class="string">&#x27;&#x27;</span>.join(lonbit)</span><br><span class="line"></span><br><span class="line">        lat = self.degridcode_bit2dms(latcode)</span><br><span class="line">        lon = self.degridcode_bit2dms(loncode)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> lat, lon</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 高度码反算</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deelevationcode</span>(<span class="params">self</span>):</span><br><span class="line">        n_binary, m = self.elevation_code, self.m</span><br><span class="line"></span><br><span class="line">        theta_0 = math.pi / <span class="number">180</span></span><br><span class="line">        theta = GridSpanlist[m-<span class="number">1</span>] * math.pi / <span class="number">180</span></span><br><span class="line">        r_0 = <span class="number">6378137</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 高度码反算</span></span><br><span class="line">        n_binary = n_binary[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将二进制的 n 转换回整数</span></span><br><span class="line">        n = <span class="built_in">int</span>(n_binary, <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 根据公式反向解码，恢复 H</span></span><br><span class="line">        H = r_0 * (math.exp((n * theta) / theta_0 * math.log(<span class="number">1</span> + theta_0)) - <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> H</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 整体反算：</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params">self</span>):</span><br><span class="line">        lat, lon = self.degridcode()</span><br><span class="line">        H = self.deelevationcode()</span><br><span class="line">        <span class="keyword">return</span> lat, lon, H</span><br></pre></td></tr></table></figure><p>这样做的目的是为了得到网格码的代表性坐标，但是这个坐标到底具体代表了网格码六面体的哪个位置，不得而知。本文仅代表个人的一些探索，代码并不一定正确。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;三维网格码计算思路分享。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>DTDC2024</title>
    <link href="https://atffang.github.io/2024/11/28/DTDC2024/"/>
    <id>https://atffang.github.io/2024/11/28/DTDC2024/</id>
    <published>2024-11-28T14:42:00.000Z</published>
    <updated>2024-11-28T14:52:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>华东师范大学李响老师课题组参加DTDC2024会议。</p><span id="more"></span><p>感谢老师！<br /><img src="https://atffang.github.io/2024/11/28/DTDC2024/DTDC2024_1.jpg"/></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;华东师范大学李响老师课题组参加DTDC2024会议。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>2024中国研究生数学建模竞赛</title>
    <link href="https://atffang.github.io/2024/11/25/2024%E4%B8%AD%E5%9B%BD%E7%A0%94%E7%A9%B6%E7%94%9F%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AB%9E%E8%B5%9B/"/>
    <id>https://atffang.github.io/2024/11/25/2024%E4%B8%AD%E5%9B%BD%E7%A0%94%E7%A9%B6%E7%94%9F%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AB%9E%E8%B5%9B/</id>
    <published>2024-11-25T04:44:51.000Z</published>
    <updated>2024-11-25T05:36:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>D题大数据驱动的地理综合问题国二。</p><span id="more"></span><p>文档全文请在PC端查看。<br /><strong>D题大数据驱动的地理综合问题</strong>，题干如下：</p><ol><li><p>在众多描述地理环境的变量中，一些简单的指标背后蕴藏了深厚的内涵，对人类的生存发展具有重大深远的影响，如大气中二氧化碳的浓度、全球年平均气温等。降水量是一个连续变化的变量，而土地利用/土地覆被类型则是一个存在突变和离散分布的变量。同时，它们都具有时空分布不均匀的特征。请从附件数据中选取相关数据集，为这两个变量分别构建一套描述性统计方法，用1<sub>3个较为简洁的统计指标或统计图表，对这两个变量在1990</sub>2020年间中国范围内的时空演化特征进行描述和总结。</p></li><li><p>近年来，以暴雨为代表的极端天气事件对人类的生产生活造成了越来越难以忽视的影响。请结合附件中所给的数据，建立数学模型，说明地形-气候相互作用在极端天气形成过程中的作用。</p></li><li><p>降雨、地形和土地利用对于暴雨等极端天气灾害的形成都具有不可忽视的影响。这其中，降雨的时空变异性和不可控性都最强；土地利用作为自然条件和人类活动的综合结果，虽然也随时空演化，但具有一定可控性；地形是最为稳定、不易改变的因素。请考虑第2问所反映的从“暴雨”到“灾害”中上述三方面因素的角色及其交互作用，确定暴雨成灾的临界条件；并结合第1问中降雨量和土地利用/土地覆被变化的历史时空演化特征，对2025~2035年间中国境内应对暴雨灾害能力最为脆弱的地区进行预测。请以地图的形式呈现你们的预测结果。</p></li><li><p>在中国级别的尺度上，描述自然地理特征的地形可以概括为“三级阶梯”，而降水中具有标志性意义的“800mm等降水量线”则与区分我国南北方的“秦岭—淮河”一线大体重合；描述人文地理特征的人口分布及其社会经济活动总量等指标，则被由连接黑龙江黑河与云南腾冲的“胡焕庸线”清晰地划分成东密西疏的两部分。那么，对于自然地理和人文地理交汇点的土地利用/土地覆被情况，结合其在前三问中描述、估计和预测任务中的“特性”，利用地理大数据，建立相应的数学模型，对数据进行简化和综合，描述中国土地利用变化的特征与结构。从准确性和有用性两个方面解释验证你们的总结。</p></li></ol><p>下面为解题文档，请在PC端查看：</p><div class="pdfobject-container" data-target="https://atffang.github.io/2024/11/25/2024中国研究生数学建模竞赛/D24102690011.pdf" data-height="500px"></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;D题大数据驱动的地理综合问题国二。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>IWGMS2024</title>
    <link href="https://atffang.github.io/2024/11/25/IWGMS2024/"/>
    <id>https://atffang.github.io/2024/11/25/IWGMS2024/</id>
    <published>2024-11-25T03:00:56.000Z</published>
    <updated>2024-11-25T04:42:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>mark一下自己的第一次汇报<sup>-</sup></p><span id="more"></span><p>感谢张海平老师给我这次机会，在3rd InternationalWorkshop on Geographic Modeling and Simulation做了人生第一次汇报，虽然没什么人听，但也怪紧张的。本次会议主题为Modeling and Simulation for a Sustainable World，主办单位是南师大。<br />秋天的南京真的好美，和闵行的肃杀相比，我越来越怀念南师大随园绿色的草坪与金色的树。<br />张海平老师负责的分会场Title为Process-oriented Geographical Analysis and Simulation，组里的汇报包括：<br />Haiping Zhang; Socio-Geographic Process Model: Theory, Methods, andApplications<br />Tianyao Fang; Spatiotemporal process simulation model for cultural transmission and acculturation<br />Nuozhou Shen; Multiscale Process Simulation for Infectious Disease Transmission<br />Yushu Xu; Intercity human dynamics during holiday weeks throughout theCovid-19 pandemic: A perspective of hybrid physical-virtual space<br />Xingxing Zhou; Spatiotemporally contiguous clustering of origin-destination flowsweighted by interaction strength to reveal interregional association pattems<br />Jinzhao Guo; Measuring spatial association in geographical processes with spatial time-series data<br /><img src="https://atffang.github.io/2024/11/25/IWGMS2024/IWGM2024_1.jpg" width="300"/><br />还见到了好久没见的朋友们。</p><img src="https://atffang.github.io/2024/11/25/IWGMS2024/IWGM2024_2.jpg" width="200"/><img src="https://atffang.github.io/2024/11/25/IWGMS2024/IWGM2024_3.jpg" width="300"/>]]></content>
    
    
    <summary type="html">&lt;p&gt;mark一下自己的第一次汇报&lt;sup&gt;-&lt;/sup&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>百度指数爬取02 年均值爬取</title>
    <link href="https://atffang.github.io/2024/10/29/%E7%99%BE%E5%BA%A6%E6%8C%87%E6%95%B0%E7%88%AC%E5%8F%9602-%E5%B9%B4%E5%9D%87%E5%80%BC%E7%88%AC%E5%8F%96/"/>
    <id>https://atffang.github.io/2024/10/29/%E7%99%BE%E5%BA%A6%E6%8C%87%E6%95%B0%E7%88%AC%E5%8F%9602-%E5%B9%B4%E5%9D%87%E5%80%BC%E7%88%AC%E5%8F%96/</id>
    <published>2024-10-29T12:26:15.000Z</published>
    <updated>2024-10-29T12:47:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>程序设计需求：爬取百度指数目标城市的年均值。</p><span id="more"></span><p>  该程序使用抓包方法获取百度指数对应搜索目标的年均值数据。通过观察百度指数网页的api调用情况，百度指数像后端请求的api构成应当为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://index.baidu.com/api/SearchApi/index?area=&#123;area&#125;&amp;word=&#123;words&#125;&amp;startDate=&#123;startDate&#125;&amp;endDate=&#123;endDate&#125;</span><br></pre></td></tr></table></figure><p>其中，area为搜索发起地，words为搜索关键字，至多包含5个，startDate和endDate分别为起始时间与结束时间。<br />这些变量的构建方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">words = [[&#123;<span class="string">&quot;name&quot;</span>: key, <span class="string">&quot;wordType&quot;</span>: <span class="number">1</span>&#125;] <span class="keyword">for</span> key <span class="keyword">in</span> keys]</span><br><span class="line"></span><br><span class="line">words = <span class="built_in">str</span>(words).replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;&#x27;&quot;</span>, <span class="string">&quot;\&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">startDate = <span class="string">f&quot;<span class="subst">&#123;year&#125;</span>-01-01&quot;</span></span><br><span class="line"></span><br><span class="line">endDate = <span class="string">f&quot;<span class="subst">&#123;year&#125;</span>-12-31&quot;</span></span><br></pre></td></tr></table></figure><p>其中，keys是搜索的各对象。</p><p>通过request构建请求头，并使用get方法请求数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;Connection&quot;</span>: <span class="string">&quot;keep-alive&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;application/json, text/plain, */*&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;Sec-Fetch-Site&quot;</span>: <span class="string">&quot;same-origin&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;Sec-Fetch-Mode&quot;</span>: <span class="string">&quot;cors&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;Sec-Fetch-Dest&quot;</span>: <span class="string">&quot;empty&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;Cipher-Text&quot;</span>: <span class="string">&quot;1698156005330_1698238860769_ZPrC2QTaXriysBT+5sgXcnbTX3/lW65av4zgu9uR1usPy82bArEg4m9deebXm7/O5g6QWhRxEd9/r/hqHad2WnVFVVWybHPFg3YZUUCKMTIYFeSUIn23C6HdTT1SI8mxsG5mhO4X9nnD6NGI8hF8L5/G+a5cxq+b21PADOpt/XB5eu/pWxNdwfa12krVNuYI1E8uHQ7TFIYjCzLX9MoJzPU6prjkgJtbi3v0X7WGKDJw9hwnd5Op4muW0vWKMuo7pbxUNfEW8wPRmSQjIgW0z5p7GjNpsg98rc3FtHpuhG5JFU0kZ6tHgU8+j6ekZW7+JljdyHUMwEoBOh131bGl+oIHR8vw8Ijtg8UXr0xZqcZbMEagEBzWiiKkEAfibCui59hltAgW5LG8IOtBDqp8RJkbK+IL5GcFkNaXaZfNMpI=&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;Referer&quot;</span>: <span class="string">&quot;https://index.baidu.com/v2/main/index.html&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;Accept-Language&quot;</span>: <span class="string">&quot;zh-CN,zh;q=0.9&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;Cookie&#x27;</span>: cookie&#125;</span><br><span class="line"></span><br><span class="line">    res = requests.get(url, headers=headers)</span><br><span class="line"></span><br><span class="line">    res_json = res.json()</span><br></pre></td></tr></table></figure><p>返回的年均值与请求关键词如下两个列表所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">retuen_keys_num = <span class="built_in">len</span>(res_json[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;generalRatio&#x27;</span>])</span><br><span class="line"></span><br><span class="line">avg_list = [res_json[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;generalRatio&#x27;</span>][i][<span class="string">&#x27;all&#x27;</span>][<span class="string">&#x27;avg&#x27;</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(retuen_keys_num)]</span><br><span class="line"></span><br><span class="line">destination_list = [res_json[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;generalRatio&#x27;</span>][i][<span class="string">&#x27;word&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;name&#x27;</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(retuen_keys_num)]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;程序设计需求：爬取百度指数目标城市的年均值。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>flask提供python脚本api查询数据库</title>
    <link href="https://atffang.github.io/2023/12/28/flask%E6%8F%90%E4%BE%9Bpython%E8%84%9A%E6%9C%ACapi%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://atffang.github.io/2023/12/28/flask%E6%8F%90%E4%BE%9Bpython%E8%84%9A%E6%9C%ACapi%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2023-12-28T02:55:33.000Z</published>
    <updated>2023-12-28T07:18:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>利用python的Flask库将脚本打包成api，实现通过url实现前端sql查询，访问数据库</p><span id="more"></span><p>起因是《GIS综合实验》这门课要求一个大作业，其中一项为WebGIS开发。对于接受了过多地学原理性课程教学而疏于计算机水平训练的学生来说，即使简单的Web开发也是一件比较头疼的事情，况且为了必须使用一个国产平台，在众多服务与文档中饶了很久的圈子。原本以为，将postgis数据库部署到平台上后，通过REST请求或者是WFS协议能够方便地实现增删改查，至少GET数据不是一件难事，但实现与设想相去甚远。和工作人员交流才知道，该平台上传的postgis数据库一般作为一个数据源为发布文件型的工作空间服务，直接查询该数据库是非常规的操作。这让我非常郁闷，原本实现的逻辑中包括读取数据库中几十万个点数据，通过deck.gl为mapbox开发的高效率点图层渲染到底图上，以及使用postgis特有的一些空间查询语句等等，如果不能直接访问数据库，那么这些设计好的逻辑、代码都要修改甚至报废。无奈之下，只能自己上手连接后端数据库，下面是实现的过程。<br />不知道答辩的时候能不能耍小聪明，堂而皇之的告诉评委这是用该国产平台实现的。<br />Flask 是一个轻量级的 Python Web 框架，用于构建 Web 应用程序，使用 Flask 可以通过定义路由来映射 URL 到相应的处理函数。这使得开发者能够轻松地构建 Web 应用的不同页面和功能（GPT语）首先在后端代码定义一个类Database，因为我的需求中暂时不需要对数据库的增删改，因此仅在该类中定义基础的打开关闭与查询功能。<a href="http://xn--api-th2el20d.py">创建api.py</a>，引入依赖库并进行基础定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> psql.postsqlConnect <span class="keyword">import</span> Database</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> flask_cors <span class="keyword">import</span> CORS</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">CORS(app, supports_credentials=<span class="literal">True</span>)</span><br><span class="line">app.config[<span class="string">&#x27;JSON_AS_ASCII&#x27;</span>] = <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>其中Database是我预先写好的数据库查询类，<code>CORS(app, supports_credentials=True)</code>是为了保障跨端口调用时不出现浏览器安全协议问题，而<code>app.config['JSON_AS_ASCII'] = False</code>用于约束查询返回的json不以二进制的形式出现。<br />接下来我们定义一个sql查询，在url中加入m_id, area_id, rating三个约束字段，以查询数据库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/api/sqlSearch&#x27;</span>, methods = [<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sqlSearch</span>():</span><br><span class="line">    m_id = request.args.get(<span class="string">&#x27;m_id&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    area_id = request.args.get(<span class="string">&#x27;area_id&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    rating = request.args.get(<span class="string">&#x27;rating&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    DB = Database(name=<span class="string">&quot;restaurant&quot;</span>, username=<span class="string">&quot;postgres&quot;</span>, password=<span class="string">&quot;20020405&quot;</span>, host=<span class="string">&quot;10.20.72.101&quot;</span>, port=<span class="string">&quot;5432&quot;</span>)</span><br><span class="line">    DB.connect()</span><br><span class="line"></span><br><span class="line">    baseSql = <span class="string">&quot;SELECT id, ST_X(geom) AS lon, ST_Y(geom) AS lat FROM public.shanghai_restaurants&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> m_id != <span class="string">&quot;&quot;</span> <span class="keyword">or</span> area_id != <span class="string">&quot;&quot;</span> <span class="keyword">or</span> rating != <span class="string">&quot;&quot;</span>:</span><br><span class="line">        m_idSql, area_idSql, ratingSql = <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> m_id != <span class="string">&quot;&quot;</span>:</span><br><span class="line">            m_idSql = <span class="string">&quot;m_id = &quot;</span> + <span class="built_in">str</span>(m_id)</span><br><span class="line">        <span class="keyword">if</span> area_id != <span class="string">&quot;&quot;</span>:</span><br><span class="line">            area_idSql = <span class="string">&quot;area_id = &quot;</span> + <span class="built_in">str</span>(area_id)</span><br><span class="line">        <span class="keyword">if</span> rating != <span class="string">&quot;&quot;</span>:</span><br><span class="line">            <span class="keyword">match</span> = re.<span class="keyword">match</span>(<span class="string">r&quot;\((\d+),(\d+)\)&quot;</span>, rating)</span><br><span class="line">            a, b = <span class="built_in">map</span>(<span class="built_in">str</span>, <span class="keyword">match</span>.groups())</span><br><span class="line">            ratingSql = <span class="string">f&quot;rating BETWEEN <span class="subst">&#123;a&#125;</span> AND <span class="subst">&#123;b&#125;</span>&quot;</span></span><br><span class="line">            </span><br><span class="line">        whereSql = <span class="string">&quot; WHERE &quot;</span>+<span class="string">&#x27; AND &#x27;</span>.join(s <span class="keyword">for</span> s <span class="keyword">in</span> [m_idSql, area_idSql, ratingSql] <span class="keyword">if</span> s)</span><br><span class="line">        finalSql = baseSql + whereSql</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        finalSql = baseSql</span><br><span class="line">        </span><br><span class="line">    json_data = DB.select(finalSql)</span><br><span class="line">    DB.close()</span><br><span class="line">    <span class="keyword">return</span> json_data</span><br></pre></td></tr></table></figure><p>由于我的需求仅限于查找，因此在定义时设置的是 methods = [‘GET’]，如果需要增删改，那么请使用POST请求。对于这个功能，我们定义的基础的url是端口+/api/sqlSearch，其中api是我这个python脚本的文件名，sqlSearch是我接下来要定义的函数名。<br />在sqlSearch函数中，首先通过request.args.get方法获取url中的参数，随后连接数据库，将这些参数解析为sql语句并提交查找，返回json文件。<br />运行该程序，会返回给你一个端口，例如我的终端提示为：<code>Running on http://127.0.0.1:5000</code>。在这个url后面再加上<code>/api/sqlSearch</code>，浏览器就会返回数据库所有记录的json。在<code>Running on http://127.0.0.1:5000/api/sqlSearch</code>后用<code>?</code>（英文）拼接查询语句，可以实现sql查询，其固定句式为<code>?参数一=x&amp;参数二=y</code>，当然，不写某个参数（数据库里的字段）的查询条件也可以，这完全取决于上面的查询函数中是如何定义的，<code>parameter = request.args.get('参数一','')</code>获取的就是上述url中的x，一般来说，可以设计为当x非空时，加入sql查询中的WHERE语句。<br />运行程序开启服务后，在web中输入url：<code>http://127.0.0.1:5000/api/sqlSearch?m_id=116&amp;area_id=3&amp;rating=(3,3)</code>,返回的页面如下所示：<br /><img align="center" width=100% src="https://s2.loli.net/2023/12/28/zaARsTgGNEPtIOc.png" style="margin-right: 20px;margin-top: 10px;margin-buttom:20px;"><br />在JavaScript中，只需解析用户输入的参数为url，就可渐变快速地查询访问数据库，使用deck.gl渲染在底图上：<br /><img width=50% src="https://s2.loli.net/2023/12/28/nefamgV3FP5xdqL.png" style="margin-right: 20px;margin-top: 10px;margin-buttom:20px;"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;利用python的Flask库将脚本打包成api，实现通过url实现前端sql查询，访问数据库&lt;/p&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
  <entry>
    <title>python并行运算</title>
    <link href="https://atffang.github.io/2023/11/12/python%E5%B9%B6%E8%A1%8C%E8%BF%90%E7%AE%97/"/>
    <id>https://atffang.github.io/2023/11/12/python%E5%B9%B6%E8%A1%8C%E8%BF%90%E7%AE%97/</id>
    <published>2023-11-12T05:33:09.000Z</published>
    <updated>2023-11-12T06:38:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用multiprocessing函数在python中实现并行运算。</p><span id="more"></span><p>python中自带的 <a href="https://docs.python.org/zh-cn/3/library/multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code>multiprocessing</code></a> 包同时提供了本地和远程并发操作，允许程序员充分利用设备上的多个处理器。本文主要介绍之中的Pool对象，它提供了一种快捷的方法，赋予函数并行化处理一系列输入值的能力，可以将输入数据分配给不同进程处理（数据并行）。在官方文档中的例子是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> Pool(<span class="number">5</span>) <span class="keyword">as</span> p:</span><br><span class="line">        <span class="built_in">print</span>(p.<span class="built_in">map</span>(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br></pre></td></tr></table></figure><p>本文将简单演示并行运算在处理数据中带来的性能提升。我将使用Pool函数实现并行遍历一个包含一百万条数据的csv文件并进行一些简单的运算，以对比我的设备在不同的进程数量下处理数据的速度。<br />代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool  </span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_csv_chunk</span>(<span class="params">file_chunk</span>):  </span><br><span class="line">    df0 = pd.read_csv(file_chunk)  </span><br><span class="line">    <span class="keyword">return</span> df0  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 简单读取运算一下数据  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">df0</span>):  </span><br><span class="line">    result_sum = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> index, row <span class="keyword">in</span> df0.iterrows():  </span><br><span class="line">        result_sum += row[<span class="number">5</span>] * row[<span class="number">0</span>]  </span><br><span class="line">    <span class="keyword">return</span> result_sum  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 并行运算  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deal_csv_parallel</span>(<span class="params">df0, times</span>):  </span><br><span class="line">    result_sum = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">if</span> times == <span class="number">0</span>:  </span><br><span class="line">        <span class="keyword">for</span> index, row <span class="keyword">in</span> df0.iterrows():  </span><br><span class="line">            result_sum += row[<span class="number">5</span>] * row[<span class="number">0</span>]  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> result_sum  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> times != <span class="number">0</span>:  </span><br><span class="line">        chunk_size = <span class="built_in">len</span>(df0) // times  </span><br><span class="line">        chunks = [df[i:i + chunk_size] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(df), chunk_size)]  </span><br><span class="line">        <span class="keyword">with</span> Pool(times) <span class="keyword">as</span> p:  </span><br><span class="line">            results = p.<span class="built_in">map</span>(f, chunks)  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(results)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">      </span><br><span class="line">    <span class="comment"># 文件路径  </span></span><br><span class="line">    file_path = <span class="string">&#x27;output.csv&#x27;</span>  </span><br><span class="line">  </span><br><span class="line">    df = read_csv_chunk(file_path)  </span><br><span class="line">  </span><br><span class="line">    Pool_size = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>)]  </span><br><span class="line">    run_time = []  </span><br><span class="line">    run_time_multiple = []  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> Pool_size:  </span><br><span class="line">        start_time = time.time()  </span><br><span class="line">  </span><br><span class="line">        deal_csv_parallel(df, i)  </span><br><span class="line">  </span><br><span class="line">        end_time = time.time()  </span><br><span class="line">  </span><br><span class="line">        t = end_time - start_time  </span><br><span class="line">  </span><br><span class="line">        run_time.append(t)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> run_time:  </span><br><span class="line">        run_time_multiple.append(<span class="string">f&quot;<span class="subst">&#123;run_time[<span class="number">0</span>]/item*<span class="number">100</span>&#125;</span>%&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">    data = &#123;<span class="string">&#x27;并行数&#x27;</span>: Pool_size, <span class="string">&#x27;运行时间&#x27;</span>: run_time, <span class="string">&#x27;效率比&#x27;</span>: run_time_multiple&#125;   </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">print</span>(df_out)</span><br></pre></td></tr></table></figure><p>其中，<code>chunks = [df[i:i + chunk_size] for i in range(0, len(df), chunk_size)]</code>负责将表格拆分成和进程数相等的几个部分，随后通用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> Pool(times) <span class="keyword">as</span> p:  </span><br><span class="line">    results = p.<span class="built_in">map</span>(f, chunks) </span><br></pre></td></tr></table></figure><p>进行并行运算。代码运行的结果为：</p><table><thead><tr><th style="text-align:center">进程数</th><th style="text-align:center">运行时间</th><th style="text-align:center">效率比</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">30.298478</td><td style="text-align:center">100.0%</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">30.566270</td><td style="text-align:center">99.12389630201749%</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">15.768265</td><td style="text-align:center">192.14846418175512%</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">10.124307</td><td style="text-align:center">299.26471386481404%</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">7.879102</td><td style="text-align:center">384.5422643570513%</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">7.495068</td><td style="text-align:center">404.24552340989857%</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">6.015692</td><td style="text-align:center">503.65742377427705%</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">5.712452</td><td style="text-align:center">530.3935987002207%</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">5.440717</td><td style="text-align:center">556.8838978332274%</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">5.770803</td><td style="text-align:center">525.030563530312%</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">5.318123</td><td style="text-align:center">569.7212889333297%</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">5.124458</td><td style="text-align:center">591.2523645483335%</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">5.040725</td><td style="text-align:center">601.0737603013101%</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">5.147555</td><td style="text-align:center">588.5993925729343%</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">4.993004</td><td style="text-align:center">606.8185840078334%</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">5.116237</td><td style="text-align:center">592.2023776071396%</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">5.017882</td><td style="text-align:center">603.8101404027773%</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">5.150956</td><td style="text-align:center">588.2107286306572%</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">5.068639</td><td style="text-align:center">597.7636351261095%</td></tr><tr><td style="text-align:center">19</td><td style="text-align:center">4.979399</td><td style="text-align:center">608.4766411595016%</td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">5.103571</td><td style="text-align:center">593.6720989778112%</td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">5.076162</td><td style="text-align:center">596.8777272425182%</td></tr><tr><td style="text-align:center">22</td><td style="text-align:center">5.401071</td><td style="text-align:center">560.9716614488367%</td></tr><tr><td style="text-align:center">23</td><td style="text-align:center">5.360952</td><td style="text-align:center">565.1697690343107%</td></tr><tr><td style="text-align:center">24</td><td style="text-align:center">5.318242</td><td style="text-align:center">569.7085696153763%</td></tr><tr><td style="text-align:center">25</td><td style="text-align:center">5.748274</td><td style="text-align:center">527.088308186721%</td></tr></tbody></table><div style="width: 90%;margin: 0 auto">    <canvas id="chart4944" style="height: 300px"></canvas></div><script src="https://cdn.jsdelivr.net/npm/chart.js@2.9.3/dist/Chart.min.js"></script><script type="text/javascript">    var ctx = document.getElementById('chart4944').getContext('2d');    var options =       {      type: 'line',      data: {      labels: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25'],      datasets: [{          label: '运行速度',          borderColor: 'rgb(255, 99, 132)',          data: [30.298478, 30.566270, 15.768265, 10.124307, 7.879102, 7.495068, 6.015692, 5.712452, 5.440717, 5.770803, 5.318123, 5.124458, 5.040725, 5.147555, 4.993004, 5.116237, 5.017882, 5.150956, 5.068639, 4.979399, 5.103571, 5.076162, 5.401071, 5.360952, 5.318242, 5.748274]          }]      },      options: {          responsive: true,          title: {          display: true,          text: '进程数与运行速度'          }      }  }  ;    new Chart(ctx, options);</script><p>可以看到，在进程数大于对于4后程序运行速度下降开始收敛，并维持在一定水平。速度最低点较非并行运算节约了5/6的时间，可见并行预算对这种背景下的数据处理带来的收益之大。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用multiprocessing函数在python中实现并行运算。&lt;/p&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
  <entry>
    <title>树莓派服务器搭建01：一个内网访问的云服务器</title>
    <link href="https://atffang.github.io/2023/11/11/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA01%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%86%85%E7%BD%91%E8%AE%BF%E9%97%AE%E7%9A%84%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://atffang.github.io/2023/11/11/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA01%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%86%85%E7%BD%91%E8%AE%BF%E9%97%AE%E7%9A%84%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2023-11-11T02:04:14.000Z</published>
    <updated>2023-11-12T03:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>瞎捣鼓:)</p><span id="more"></span><p>上个月一时兴起，购入了一块树莓派4B。</p><p><img src=https://s2.loli.net/2023/11/12/4XA5YE8GZDuNbOg.png  width=60%/> 到手后烧录了带GUI的Raspberry Pi系统，换源、安装了一些依赖并外接了键鼠小屏幕后，就因为面试的事搁置了。直到现在才想到将它好好利用起来。搁置的这段时间只零零散散部署过一些爬虫，但是由于部署程序时，我只通过filezilla完成主机与树莓派服务器之间的数据传输，再把数据传给实验室其他人，过程略显繁琐。因此，这次我打算直接将树莓派服务器作为实验室内网下的云存储平台使用。<br />在修改前，首先要解决一个问题：在同一局域网下，我的主机无法ping通树莓派服务器，但是在同一手机热点下确可以。解决方法是在主机(Windows)中修改防火墙高级允许入站、出站规则中的<strong>文件和打印机共享</strong></p><p><img src=https://s2.loli.net/2023/11/12/DU1ShQJ6c7vky89.png  width=60% align="center"/>这个问题煞是令我费解。因为在手机热点下电脑可以ping通服务器，但在WiFi下却需要修改防火墙设置，不知道背后的逻辑是什么。<br />确认机器间的连接通畅后，就可以开始设置树莓派了。为了安全起见，我首先在root下新建了一个账号，将共享的文件置于该账号下。首先更新一下源：<br /><code>sudo apt-get update</code><br />安装samba程序。Samba(Server Message Block)是一个开源的软件套件，用于实现基于SMB/CIFS协议的文件和打印服务，使得不同操作系统的计算机能够在局域网上共享文件和打印机。<br /><code>sudo apt-get install samba samba-common-bin</code><br />随后修改配置文件：<br /><code>sudo vi /etc/samba/smb.conf</code><br />在share definitions一章将read only = yes改为=no，使得其他用户得以修改共享的文件。保存编辑并重启samba服务：<br /><code>sudo /etc/init.d/smbd restart</code><br />添加默认用户：<br /><code>sudo smbpasswd -a 刚刚新建的用户名</code><br />在文件资源管理器中打开地址：<code>\\树莓派ip地址\用户名</code>，按要求输入账号密码（就是刚才创建与添加的），即可访问：<br /><img src=https://s2.loli.net/2023/11/12/hwjHTnEaMG2UQcm.png  width=60%/></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;瞎捣鼓:)&lt;/p&gt;</summary>
    
    
    
    <category term="或许用得到的tips" scheme="https://atffang.github.io/categories/%E6%88%96%E8%AE%B8%E7%94%A8%E5%BE%97%E5%88%B0%E7%9A%84tips/"/>
    
    
  </entry>
  
  <entry>
    <title>百度指数爬取</title>
    <link href="https://atffang.github.io/2023/09/11/%E7%99%BE%E5%BA%A6%E6%8C%87%E6%95%B0%E7%88%AC%E5%8F%96%E2%80%94%E2%80%94%E4%B8%8D%E5%90%8C%E5%9F%8E%E5%B8%82%E5%AF%B9%E4%BA%8E%E5%90%84%E7%B1%BB%E5%85%B3%E9%94%AE%E8%AF%8D%E6%90%9C%E7%B4%A0%E9%87%8F%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/"/>
    <id>https://atffang.github.io/2023/09/11/%E7%99%BE%E5%BA%A6%E6%8C%87%E6%95%B0%E7%88%AC%E5%8F%96%E2%80%94%E2%80%94%E4%B8%8D%E5%90%8C%E5%9F%8E%E5%B8%82%E5%AF%B9%E4%BA%8E%E5%90%84%E7%B1%BB%E5%85%B3%E9%94%AE%E8%AF%8D%E6%90%9C%E7%B4%A0%E9%87%8F%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/</id>
    <published>2023-09-11T14:02:38.000Z</published>
    <updated>2023-09-11T14:40:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>程序设计需求：横向对比中国各城市对于各关键词百度搜索强度。</p><span id="more"></span><p>  本程序基于网友longxiaofei设计的百度指数访问python包，链接如下：<a href="https://github.com/longxiaofei/spider-BaiduIndex%E3%80%82">https://github.com/longxiaofei/spider-BaiduIndex。</a></p><p>爬虫需要获取百度指数网站cookie，在百度指数官网打开开发者模式即可取得。<br />  爬虫核心函数代码如下，程序链接会在文末贴出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取百度指数的函数  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_baidu_index</span>(<span class="params">keywords_list: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]], citycode, cookiesQueue</span>):  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># cookie  </span></span><br><span class="line">    cookies = cookiesQueue.queue[<span class="number">0</span>]  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 当前请求的五个关键词  </span></span><br><span class="line">    requested_keywords = []  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 一组（五个）关键词为元素的队列  </span></span><br><span class="line">    q_keywords = queue.Queue(-<span class="number">1</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 将keywordlist分组后置入队列q_keywords  </span></span><br><span class="line">    <span class="keyword">for</span> splited_keywords_list <span class="keyword">in</span> split_keywords(keywords_list):  </span><br><span class="line">        q_keywords.put(splited_keywords_list)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 当次请求的城市名称  </span></span><br><span class="line">    cityname = <span class="built_in">str</span>(CITY_MAP[<span class="built_in">str</span>(citycode)])  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始请求&quot;</span>+<span class="built_in">str</span>(CITY_MAP[<span class="built_in">str</span>(citycode)])+<span class="string">&quot;的百度指数&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 遍历q_keywords，每一组q_keywords请求一次  </span></span><br><span class="line">    <span class="comment"># 获得的数据输入data  </span></span><br><span class="line">    datas = []  </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> q_keywords.empty():  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 取出一组  </span></span><br><span class="line">        cur_keywords_list = q_keywords.get()  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 增加容错率：若错误，则换cookie重试  </span></span><br><span class="line">        <span class="comment"># 当前尝试次数  </span></span><br><span class="line">        attempts = <span class="number">0</span>  </span><br><span class="line">        <span class="comment"># 最大尝试次数  </span></span><br><span class="line">        max_attempts = <span class="number">3</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">while</span> attempts &lt; max_attempts:  </span><br><span class="line">            <span class="keyword">try</span>:  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;开始请求: <span class="subst">&#123;cur_keywords_list&#125;</span>&quot;</span>)  </span><br><span class="line">                <span class="comment"># 这一组获得的data  </span></span><br><span class="line">                current_data = []  </span><br><span class="line">                <span class="keyword">for</span> index <span class="keyword">in</span> get_search_index(  </span><br><span class="line">                        keywords_list=cur_keywords_list,  </span><br><span class="line">                        start_date=STARTTIME,  </span><br><span class="line">                        end_date=ENDTIME,  </span><br><span class="line">                        cookies=cookies,  </span><br><span class="line">                        area=citycode  </span><br><span class="line">                ):  </span><br><span class="line">                    index[<span class="string">&quot;keyword&quot;</span>] = <span class="string">&quot;,&quot;</span>.join(index[<span class="string">&quot;keyword&quot;</span>])  </span><br><span class="line">                    <span class="comment"># 将输出的index数据转化为list  </span></span><br><span class="line">                    index_list = [citycode, cityname, index[<span class="string">&#x27;keyword&#x27;</span>], index[<span class="string">&#x27;type&#x27;</span>], index[<span class="string">&#x27;date&#x27;</span>], index[<span class="string">&#x27;index&#x27;</span>]]  </span><br><span class="line">                    current_data.append(index_list)  </span><br><span class="line">                requested_keywords.extend(cur_keywords_list)  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;请求完成: <span class="subst">&#123;cur_keywords_list&#125;</span>&quot;</span>)  </span><br><span class="line">                datas.extend(current_data)  </span><br><span class="line">                time.sleep(<span class="number">0.2</span>)  </span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:  </span><br><span class="line">                traceback.print_exc()  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;请求出错, requested_keywords: <span class="subst">&#123;requested_keywords&#125;</span>，错误为<span class="subst">&#123;e&#125;</span>&quot;</span>)  </span><br><span class="line">                time.sleep(<span class="number">5</span>)  </span><br><span class="line">                cookies = cookiesQueue.get()  </span><br><span class="line">                attempts += <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> datas</span><br></pre></td></tr></table></figure><p>  本程序包含三个文件夹与一个主程序（.py），其中参考数据文件夹给出了百度指数对于中国355个城市给出的代码以及相应的城市名称，输出数据文件夹存储爬取的数据，而输入数据的文件夹包含存储百度cookies文本文件Allcookies，每行存放一个cookie，注意行末不要出现换行符。由于百度指数对于每个cookie访问的次数存在限制（几天后会刷新），因此对于关键词较多的爬取要求，建议多准备几个cookie。Ocity数据中存放城市代码与城市名称，Keyword中存放关键词（第一列存放排序数字）。总之，按示例数据填充即可。<br />代码链接如下：<br /><a href="https://github.com/ATFfang/ATFfang.github.io/tree/main/2023/09/11/%E7%99%BE%E5%BA%A6%E6%8C%87%E6%95%B0%E7%88%AC%E5%8F%96%E2%80%94%E2%80%94%E4%B8%8D%E5%90%8C%E5%9F%8E%E5%B8%82%E5%AF%B9%E4%BA%8E%E5%90%84%E7%B1%BB%E5%85%B3%E9%94%AE%E8%AF%8D%E6%90%9C%E7%B4%A0%E9%87%8F%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/%E7%99%BE%E5%BA%A6%E7%88%AC%E8%99%ABV2">链接</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;程序设计需求：横向对比中国各城市对于各关键词百度搜索强度。&lt;/p&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
  <entry>
    <title>python数据结构基础</title>
    <link href="https://atffang.github.io/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/"/>
    <id>https://atffang.github.io/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/</id>
    <published>2023-09-05T12:49:50.000Z</published>
    <updated>2023-09-13T07:04:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>2023-04-03日上传，2023-04-05日第三次更新。<br />报了个蓝桥杯的python赛道，却没怎么复习……稍微整理了一些数据结构（python实现）的知识点，赛前看一下。</p><span id="more"></span><p><strong>可以先看看第六章python基础</strong>（我记性太差了）</p><p>以下有的代码是书上抄的，有的代码是我自己写的，有的代码是gpt生成的，均为经过编译器编译，准确性未知，主要看个思路！</p><p>以及：如果网页版看的不爽，您可以点击下载<a href="https://raw.githubusercontent.com/ATFfang/publicWarehouse/main/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80.md">markdown</a>（只是里面没有动图）。请注意：务必下载时，选择文件类型为全部文件，<a href="http://xn--siqsrg0kktvclai81k.md">文件后缀改为.md</a>（<a href="http://xn--Chrome-np7im42b3rqsmy8rarf797sbvfm9cz38ab87d.md">Chrome下载时显示的后缀确实是.md</a>，但这是因为他把后面的.txt折叠了……麻烦删掉）</p><h3 id="1-基础数据结构"><a class="markdownIt-Anchor" href="#1-基础数据结构"></a> 1. 基础数据结构</h3><h4 id="11-栈"><a class="markdownIt-Anchor" href="#11-栈"></a> 1.1 栈</h4><p>python栈实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__self</span>(<span class="params">self</span>):</span><br><span class="line">self.items=[]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.items==[]</span><br><span class="line"><span class="comment">#入栈</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self,item</span>):</span><br><span class="line">self.items.append(item)</span><br><span class="line"><span class="comment">#`pop()` 函数用于删除列表中指定索引位置（默认为最后一个元素）的元素</span></span><br><span class="line"><span class="comment">#出栈</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.items.pop();</span><br><span class="line"><span class="comment">#取值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.items[<span class="built_in">len</span>(items)-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(self.items)</span><br></pre></td></tr></table></figure><p>用途：匹配括号，将十进制转化为二进制，前序、中序、后序表达式以及其之间的转换。</p><h4 id="12-a队列"><a class="markdownIt-Anchor" href="#12-a队列"></a> 1.2 a.队列</h4><p>python队列的实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">self.items=[]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.items==[]</span><br><span class="line"><span class="comment">#入队</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enqueue</span>(<span class="params">self,item</span>):</span><br><span class="line"><span class="keyword">return</span> self.items.insert(<span class="number">0</span>,item)</span><br><span class="line"><span class="comment">#出队</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dequeue</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.items.pop();</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(self.items)</span><br></pre></td></tr></table></figure><p>队列的例子：模拟传土豆，模拟打印任务</p><h4 id="12-b双端队列"><a class="markdownIt-Anchor" href="#12-b双端队列"></a> 1.2 b.双端队列</h4><p>双端队列是与队列类似的有序集合。与队列不同的是，双端队列在哪一端添加元素都没有任何限制，移除也是同理。<br />双端队列的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Deque</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">self.items=[]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.items==[]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addFront</span>(<span class="params">self,item</span>):</span><br><span class="line">self.items.append(item)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addRear</span>(<span class="params">self,item</span>):</span><br><span class="line">self.items.insert(<span class="number">0</span>,item)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">removeFront</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.items.pop()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">removeRear</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.items.pop(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(self.items)</span><br></pre></td></tr></table></figure><p>双端队列的应用：回文检测器<br />回文检测器：将字符串逐字符加入双端队列，依次进行前后端出队，当前端出队元素和后端出队元素相等时再继续。</p><h4 id="13-列表"><a class="markdownIt-Anchor" href="#13-列表"></a> 1.3 列表</h4><h5 id="131无序列表链表"><a class="markdownIt-Anchor" href="#131无序列表链表"></a> 1.3.1无序列表：链表</h5><p>node节点是构建链表的基本数据结构。每一个节点至少保有：数据变量；指向下一个节点的应用。下面是一个node类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,initdata</span>):</span><br><span class="line">self.data=initdata</span><br><span class="line">self.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getData</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.data</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getNext</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.<span class="built_in">next</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setData</span>(<span class="params">self,newdata</span>):</span><br><span class="line">self.data=newdata</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setNext</span>(<span class="params">self,newnext</span>):</span><br><span class="line">self.<span class="built_in">next</span>=newnext</span><br></pre></td></tr></table></figure><p>通过节点，可以构建无序列表类UnorderedList类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnorderedList</span>:</span><br><span class="line"><span class="comment">#在初始化时，只需要一个head节点：</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">self.head=<span class="literal">None</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.head==<span class="literal">None</span></span><br><span class="line"><span class="comment">#在head前添加一个节点，并将这个节点设置为head，此时head不再为None，即链表不再为空</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self,item</span>):</span><br><span class="line">temp=Node(item)</span><br><span class="line">temp.setNext(self.head)</span><br><span class="line">self.head=temp</span><br><span class="line"><span class="comment">#通过遍历获取链表长度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">length</span>(<span class="params">self</span>):</span><br><span class="line">current=self.head</span><br><span class="line">cont=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(current!=<span class="literal">None</span>):</span><br><span class="line">cont+=<span class="number">1</span></span><br><span class="line">current=current.getNext()</span><br><span class="line"><span class="keyword">return</span> cont</span><br><span class="line"><span class="comment">#遍历寻找元素是否在链表内</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self,item</span>):</span><br><span class="line">current=self.head</span><br><span class="line">found=false</span><br><span class="line"><span class="keyword">while</span>(current!=<span class="literal">None</span> <span class="keyword">and</span> found==false):</span><br><span class="line"><span class="keyword">if</span>(current.data==item):</span><br><span class="line">found=true</span><br><span class="line"><span class="keyword">return</span> found</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">current=current.getNext()</span><br><span class="line"><span class="keyword">return</span> found</span><br><span class="line"><span class="comment">#通过遍历删除值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self,item</span>):</span><br><span class="line">current=self.head</span><br><span class="line">previous=<span class="literal">None</span></span><br><span class="line">found=<span class="literal">False</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> found:</span><br><span class="line"><span class="keyword">if</span> current.getData()==item:</span><br><span class="line">found=<span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">previous=current</span><br><span class="line">current=current.getNext()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> previous==<span class="literal">None</span>:</span><br><span class="line">self.head=current.getNext()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">previous.setNext(current.getNext())</span><br></pre></td></tr></table></figure><h5 id="132-有序列表"><a class="markdownIt-Anchor" href="#132-有序列表"></a> 1.3.2 有序列表</h5><p>有序列表中，元素的相对位置取决于他们的基本特征<br />有序列表的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OrderedList</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">self.head=<span class="literal">None</span></span><br><span class="line"><span class="comment">#遍历，找到比插入值大的节点，插入到该节点的前面</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self,item</span>):</span><br><span class="line">current=self.head</span><br><span class="line">precious=<span class="literal">None</span></span><br><span class="line">stop=<span class="literal">False</span></span><br><span class="line"><span class="keyword">while</span> current!=<span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> stop:</span><br><span class="line"><span class="keyword">if</span> current.getData()&gt;item:</span><br><span class="line">stop=<span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">previous=current</span><br><span class="line">current=current.getNext()</span><br><span class="line">temp=Node(item)</span><br><span class="line"><span class="keyword">if</span>(previous=<span class="literal">None</span>):</span><br><span class="line">self.head=temp</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">temp.setNext(current)</span><br><span class="line">precious.setNext(temp)</span><br><span class="line"><span class="comment">#遍历，直到满足：1.找到了；2.遍历到的值已经大于要找的值，退出；</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self,item</span>):</span><br><span class="line">current=self.head</span><br><span class="line">found=<span class="literal">False</span></span><br><span class="line">stop=<span class="literal">False</span></span><br><span class="line"><span class="keyword">while</span> current!=<span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> found <span class="keyword">and</span> <span class="keyword">not</span> stop:</span><br><span class="line"><span class="keyword">if</span> current.getData()==item:</span><br><span class="line">found=<span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">if</span> current.getData()&gt;item:</span><br><span class="line">stop=<span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">current=current.getNext()</span><br><span class="line"><span class="keyword">return</span> found</span><br></pre></td></tr></table></figure><h3 id="2-递归"><a class="markdownIt-Anchor" href="#2-递归"></a> 2. 递归</h3><h4 id="21-迷宫搜索"><a class="markdownIt-Anchor" href="#21-迷宫搜索"></a> 2.1 迷宫搜索</h4><p>示例：迷宫搜索函数：<br />下列的实例代码中，接受三个参数：迷宫对象、起始行、起始列<br />PART_OF_PATH:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">searchForm</span>(<span class="params">maze,startRow,startColumn</span>):</span><br><span class="line">maze.updatePosition(startRow,startColumn)</span><br><span class="line"><span class="comment">#检查基本情况</span></span><br><span class="line"><span class="comment">#1.遇到墙</span></span><br><span class="line"><span class="keyword">if</span> (maze[startRow][startColumn]==OBSTACLE):</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="comment">#2.遇到已经走过的格子</span></span><br><span class="line"><span class="keyword">if</span> (maze[startRow][startColumn]==TRIED):</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="comment">#3.找到出口</span></span><br><span class="line"><span class="keyword">if</span> maze.isExit([startRow][startColumn]):</span><br><span class="line">maze.updatePosition(startRow,startColumn,PART_OF_PATH)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">maze.updatePosition(startRow,startColumn,TRIED)</span><br><span class="line"></span><br><span class="line"><span class="comment">#否则，依次尝试四个方向走动，对于or，只要有一个正确，后面的就不会执行</span></span><br><span class="line">found=searchFrom(maze,startRow-<span class="number">1</span>,startColumn)\</span><br><span class="line"><span class="keyword">or</span> searchFrom(maze,startRow+<span class="number">1</span>,startColumn)\</span><br><span class="line"><span class="keyword">or</span> searchFrom(maze,startRow,startColumn-<span class="number">1</span>)\</span><br><span class="line"><span class="keyword">or</span> searchFrom(maze,startRow,startColumn+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> found:</span><br><span class="line">maze.uodatePosition(startRow,startColumn,PART_OF_PATH)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">maze.uodatePosition(startRow,startColumn,DEAD_END)</span><br><span class="line"><span class="keyword">return</span> found</span><br></pre></td></tr></table></figure><h4 id="22-汉诺塔"><a class="markdownIt-Anchor" href="#22-汉诺塔"></a> 2.2 汉诺塔</h4><p>其他示例：汉诺塔<br />汉诺塔是一种经典的递归问题，它的原理比较简单：有三根杆子，在其中一根杆子上按照大小顺序放置了若干个圆盘，现在需要把这些圆盘从一根杆子移动到另一根杆子上，移动过程中要保证较大的圆盘必须放在较小的圆盘下面，且每次只能移动一个圆盘。在汉诺塔问题中，我们通常称这三根杆子为 A、B、C 杆。</p><p>解决汉诺塔问题的常用方法是递归算法，具体的步骤如下：</p><ol><li>递归出口：当只有一个圆盘时，直接把它从 A 杆移到 C 杆上，即 return 1。</li><li>将 n-1 个圆盘从 A 杆移动到 B 杆上，使用 C 杆作为辅助杆。</li><li>将第 n 个圆盘从 A 杆移动到 C 杆上。</li><li>将 n-1 个圆盘从 B 杆移动到 C 杆上，使用 A 杆作为辅助杆。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hanoi</span>(<span class="params">n, A, B, C</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Move disk 1 from &#123;&#125; to &#123;&#125;&quot;</span>.<span class="built_in">format</span>(A, C))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        step1 = hanoi(n - <span class="number">1</span>, A, C, B)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Move disk &#123;&#125; from &#123;&#125; to &#123;&#125;&quot;</span>.<span class="built_in">format</span>(n, A, C))</span><br><span class="line">        step2 = hanoi(n - <span class="number">1</span>, B, A, C)</span><br><span class="line">        <span class="keyword">return</span> step1 + <span class="number">1</span> + step2</span><br></pre></td></tr></table></figure><h4 id="23-动态规划"><a class="markdownIt-Anchor" href="#23-动态规划"></a> 2.3 动态规划</h4><p>示例：动态规划找零问题：</p><ul><li>问题提出：硬币只有1美分，5美分，10美分和25美分，如何在消耗硬币最少的情况下，找零出37美分？</li><li>问题剖析：<br />1.递归方法，即：<br />若是每次找出x元的硬币，则剩余找零为（找零-x）元，每次利用函数numCoins寻找四种numCoins（找零-x）中的最小值，构建一颗子节点为4的递归树。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numCoins=<span class="built_in">min</span>(<span class="number">1</span>+numCoins(找零-<span class="number">1</span>),<span class="number">1</span>+numCoins(找零-<span class="number">5</span>),<span class="number">1</span>+numCoins(找零-<span class="number">10</span>),<span class="number">1</span>+numCoins(找零-<span class="number">25</span>))</span><br></pre></td></tr></table></figure><ol start="2"><li>动态规划方法，即：<br />每个金额的找零方式都由该金额-i的找零方式所决定，其中，i为硬币面值。<br />譬如，当我们需要知道15分怎么找时，可以求以下方式的最小值：</li></ol><ul><li>一枚一分的硬币+14分所需的最少的硬币（1+6）</li><li>一枚5分的硬币+10分所需的最少的硬币（1+1）</li><li>一枚10分的硬币+5分所需最少的硬币（1+1）</li></ul><p>因此，我们从0开始，指导要解的找零值，求出这之间所有值的最小硬币构成。<br />下面为动态规划的实现，其中，coinValueList为硬币的面值列表，change表示找零金额，minCoins表示从0到change的所有最优解，coinsUsed存储用于找零的硬币。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dpMakeChange</span>(<span class="params">coinValueList,change,minCoins,coinsUsed</span>):</span><br><span class="line"><span class="comment">#从0遍历到change（python左闭右开！）</span></span><br><span class="line"><span class="keyword">for</span> cents <span class="keyword">in</span> <span class="built_in">range</span>(change+<span class="number">1</span>):</span><br><span class="line"><span class="comment">#所用的硬币数</span></span><br><span class="line">coinCount=cents</span><br><span class="line"><span class="comment">#记录使用的硬币的面额</span></span><br><span class="line">newCoin=<span class="number">1</span></span><br><span class="line"><span class="comment">#遍历所有小于找零值的硬币</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> [c <span class="keyword">for</span> c <span class="keyword">in</span> coinValueList of c&lt;cents]:</span><br><span class="line"><span class="comment">#如果cents-面额j的最小硬币数+1小于之前求得的硬币数，则替换</span></span><br><span class="line"><span class="keyword">if</span> minCoins[cents-j]+<span class="number">1</span>&lt;coinCount:</span><br><span class="line">CoinCount=minCoins[cents-j]+<span class="number">1</span></span><br><span class="line">newCoin=j</span><br><span class="line"><span class="comment">#记载入最优解列表中</span></span><br><span class="line">minCoins[cents]=contCount</span><br><span class="line"><span class="comment">#记载入使用过的硬币列表中</span></span><br><span class="line">coinUsed[cents]=newCoin</span><br><span class="line"><span class="keyword">return</span> minCoins[change]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printCoins</span>(<span class="params">coinsUsed,change</span>):</span><br><span class="line">coin=change</span><br><span class="line"><span class="keyword">while</span> coin&gt;<span class="number">0</span>:</span><br><span class="line">thisCoin=coinsUsed[coin]</span><br><span class="line"><span class="built_in">print</span>(thisCoin)</span><br><span class="line">coin=coin-thisCoin</span><br></pre></td></tr></table></figure><p>下面详细介绍一下动态规划：<br /><strong>动态规划</strong>（Dynamic Programming，简称DP）是一种将复杂问题分解成更小的子问题来解决的优化技术，常用于解决最优化问题。它在求解具有重叠子问题和最优子结构的问题中特别有效。</p><p>动态规划的基本思想是将原问题分解成若干个子问题，先求解子问题的最优解，然后通过子问题的最优解得到原问题的最优解。具体来说，动态规划的思路包括以下几个步骤：<br />（1）划分：按照问题的特征，把问题分为若干阶段。注意：划分后的阶段一定是有序的或者可排序的<br />（2）确定状态和状态变量：将问题发展到各个阶段时所处的各种不同的客观情况表现出来。状态的选择要满足无后续性<br />（3）确定决策并写出状态转移方程：状态转移就是根据上一阶段的决策和状态来导出本阶段的状态。根据相邻两个阶段状态之间的联系来确定决策方法和状态转移方程<br />（4）边界条件：状态转移方程是一个递推式，因此需要找到递推终止的条件</p><p>整个求解过程可以用一张最优决策表来描述，最优决策表是一张二维表（行：决策阶段，列：问题的状态）表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</p><p>例如：f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)}</p><p>下面是一些问题实例，有助于理解动态规划：</p><h5 id="231-背包问题"><a class="markdownIt-Anchor" href="#231-背包问题"></a> 2.3.1 背包问题</h5><p>对于初学者来说，理解背包问题并不容易，可以先看这个<a href="https://www.bilibili.com/video/BV1g7411B7SP/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=717d4feb094126b2033be27866e18150">视频</a>，里面有十分详细的讲解。<br />背包问题是一类经典的优化问题，通常指在给定容量的背包中，如何选择最有价值的物品，使得背包中物品的总价值最大。<br />具体来说，背包问题有两种形式：0/1背包和完全背包。<br />0/1背包问题中，物品不可分割，每个物品只有一个，选择放入或不放入，不能将物品分成若干部分装入背包。<br />完全背包问题中，每个物品可以选择放入多次，即物品是可分割的。</p><p>对于这两种问题，一般可以用动态规划的思想进行求解。设背包容量为V，有n个物品，第i个物品的体积为v[i]，价值为w[i]。定义f(i,j)表示在前i个物品中选择不超过j容量的物品的最大价值，则有：</p><ol><li>对于0/1背包问题：<br />f(i,j) = max{f(i-1,j), f(i-1,j-v[i])+w[i]}, j &gt;= v[i]<br />f(i,j) = f(i-1,j), j &lt; v[i]<br />即：当第i件物品可以加入背包时，可以选择加入或者不加入。如果加入，则总价值为：f(i-1,j)，若不加入，则总价值为：第i件物品的价值+当前容量（总容量-第i件物品的重量）能够存放的最大价值f(i,j) = max{f(i-1,j), f(i-1,j-v[i])+w[i]}, j &gt;= v[i]</li></ol><p>python实现的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">knapsack</span>(<span class="params">capacity, weights, values, n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    0/1背包问题的解法</span></span><br><span class="line"><span class="string">    :param capacity: 背包的容量</span></span><br><span class="line"><span class="string">    :param weights: 每个物品的重量列表</span></span><br><span class="line"><span class="string">    :param values: 每个物品的价值列表</span></span><br><span class="line"><span class="string">    :param n: 物品数量</span></span><br><span class="line"><span class="string">    :return: 最大价值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 初始化二维数组f，用于存储状态转移方程的结果</span></span><br><span class="line">    f = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(capacity + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, capacity + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 如果当前物品的体积小于等于背包容量，则可以选择装入或者不装入</span></span><br><span class="line">            <span class="keyword">if</span> weights[i-<span class="number">1</span>] &lt;= j:</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i-<span class="number">1</span>][j], f[i-<span class="number">1</span>][j-weights[i-<span class="number">1</span>]]+values[i-<span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 否则只能不装入</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                f[i][j] = f[i-<span class="number">1</span>][j]</span><br><span class="line">    <span class="keyword">return</span> f[n][capacity]</span><br></pre></td></tr></table></figure><h5 id="232-台阶问题"><a class="markdownIt-Anchor" href="#232-台阶问题"></a> 2.3.2 台阶问题</h5><p>有n级台阶，一个人每次上一级或者两级，问有多少种走完n级台阶的方法。</p><p>分析：动态规划的实现的关键在于能不能准确合理的用动态规划表来抽象出 实际问题。在这个问题上，我们让f(n)表示走上n级台阶的方法数。</p><p>那么当n为1时，f(n) = 1,n为2时，f(n) =2,就是说当台阶只有一级的时候，方法数是一种，台阶有两级的时候，方法数为2。那么当我们要走上n级台阶，必然是从n-1级台阶迈一步或者是从n-2级台阶迈两步，所以到达n级台阶的方法数必然是到达n-1级台阶的方法数加上到达n-2级台阶的方法数之和。即f(n) = f(n-1)+f(n-2)，我们用dp[n]来表示动态规划表，dp[i],i&gt;0,i&lt;=n,表示到达i级台阶的方法数。</p><p>下面是一个python实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param n: an integer</span></span><br><span class="line"><span class="string">    @return: an ineger f(n)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">up</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="comment"># if n == 0:</span></span><br><span class="line">        <span class="comment">#     return 0</span></span><br><span class="line">        L = []</span><br><span class="line">        L.append(<span class="number">1</span>)</span><br><span class="line">        L.append(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">            L.append(L[i - <span class="number">1</span>] + L[i - <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> L[n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="3-搜索与排序"><a class="markdownIt-Anchor" href="#3-搜索与排序"></a> 3. 搜索与排序</h3><h4 id="31-搜索"><a class="markdownIt-Anchor" href="#31-搜索"></a> 3.1 搜索</h4><p>Python提供了in，通过它可以方便的检查元素是否在列表中：<br /><code>15 in [1,2,3,4,15]</code></p><h5 id="311-顺序搜索"><a class="markdownIt-Anchor" href="#311-顺序搜索"></a> 3.1.1 顺序搜索</h5><p>这个就不讲了，大猩猩都会</p><h5 id="312-二分搜索"><a class="markdownIt-Anchor" href="#312-二分搜索"></a> 3.1.2 二分搜索</h5><p>目标值比中间元素小，则在左半部分继续查找；否则，在右半部分继续查找。重复以上过程，直到找到目标值或者确定目标值不存在为止。<br />二分搜索算法的时间复杂度为 O(log n)，其中 n 表示数组中元素的个数，因此它比线性搜索算法的时间复杂度 O(n) 更快，特别是对于大规模的数据集。<br />显然，二分搜索可以使用递归实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_helper</span>(<span class="params">arr, target, left, right</span>): </span><br><span class="line"><span class="keyword">if</span> left &gt; right: </span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span> </span><br><span class="line">mid = (left + right) // <span class="number">2</span> </span><br><span class="line"><span class="keyword">if</span> arr[mid] == target: </span><br><span class="line"><span class="keyword">return</span> mid </span><br><span class="line"><span class="keyword">elif</span> arr[mid] &lt; target: </span><br><span class="line"><span class="keyword">return</span> binary_search_helper(arr, target, mid + <span class="number">1</span>, right) </span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line"><span class="keyword">return</span> binary_search_helper(arr, target, left, mid - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h5 id="313-散列"><a class="markdownIt-Anchor" href="#313-散列"></a> 3.1.3 散列</h5><p>（这里我不想写了，下面都是gpt写的）<br />散列（Hashing）是一种用于快速查找的数据结构，它能够在 O(1) 的时间复杂度内完成查找操作。散列使用散列函数将键映射到存储位置，每个存储位置称为散列表中的一个桶。当需要查找一个键时，可以使用散列函数计算出该键对应的桶的位置，并在该桶中查找是否存在对应的值。</p><p>散列函数是散列表的关键，它将键映射到桶的位置。一个好的散列函数应该具有以下特点：</p><ol><li>散列函数应该能够将不同的键映射到不同的桶，避免不同键的哈希冲突。</li><li>散列函数应该尽可能地将键均匀地分布在桶中，避免出现某些桶过载的情况。</li><li>散列函数的计算速度应该足够快，否则会影响散列表的性能。</li></ol><p>散列函数可以使用不同的算法来实现，包括简单的取余法、乘法散列法、多项式散列法、MD5 散列等。</p><p>在实际应用中，散列可以用于解决大量数据的查找问题，例如在数据库中查找记录、在哈希表中查找键值对等。但是，散列也有一些缺点，例如：</p><ol><li>散列函数可能出现哈希冲突，即不同的键映射到了同一个桶中，需要使用冲突解决策略来解决。</li><li>散列表的性能取决于散列函数的质量和散列表的装载因子，当装载因子过高时，会影响散列表的性能。</li><li>散列表的大小通常是固定的，不能动态扩展，如果散列表的大小不够，需要重新创建一个更大的散列表来解决。</li></ol><p>下面是一个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, size</span>):</span><br><span class="line">        self.size = size</span><br><span class="line">        self.table = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash_func</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(key) % self.size</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        index = self.hash_func(key)</span><br><span class="line">        self.table[index].append((key, value))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, key</span>):</span><br><span class="line">        index = self.hash_func(key)</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> self.table[index]:</span><br><span class="line">            <span class="keyword">if</span> k == key:</span><br><span class="line">                <span class="keyword">return</span> v</span><br><span class="line">        <span class="keyword">raise</span> KeyError(key)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, key</span>):</span><br><span class="line">        index = self.hash_func(key)</span><br><span class="line">        <span class="keyword">for</span> i, (k, v) <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.table[index]):</span><br><span class="line">            <span class="keyword">if</span> k == key:</span><br><span class="line">                <span class="keyword">del</span> self.table[index][i]</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">raise</span> KeyError(key)</span><br></pre></td></tr></table></figure><p>以上是一个简单的散列表实现，使用 Python 列表作为散列表的存储结构，使用哈希函数将键映射到散列表中的索引位置。当插入一个键值对时，使用哈希函数计算键的索引位置，并将键值对添加到该位置对应的列表中。当查找或删除一个键值对时，同样使用哈希函数计算键的索引位置，并在该位置对应的列表中查找或删除键值对。</p><p>这里的哈希函数使用内置函数 hash，它可以将任意 Python 对象转换为整数，并且保证相同的对象具有相同的哈希值。但是，在实际应用中，可以根据具体的应用场景选择不同的哈希函数。</p><h4 id="32-排序"><a class="markdownIt-Anchor" href="#32-排序"></a> 3.2 排序</h4><p>python提供了内置的排序函数：<br /><code>list.sort(*, key=None, reverse=False)</code>：该函数用于对列表进行原地排序，它接受 key 函数和 reverse 参数，如果 reverse 参数为 True，则按照降序排序。</p><h5 id="321-冒泡排序"><a class="markdownIt-Anchor" href="#321-冒泡排序"></a> 3.2.1 冒泡排序</h5><p>冒泡排序（Bubble Sort）是一种简单的排序算法，它重复地走访过要排序的数列，依次比较相邻的两个元素，如果它们的顺序错误就交换它们的位置，直到没有需要交换的元素为止。<br />这没啥要讲的了</p><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%86%92%E6%B3%A1.gif" class="" title="sucessful"><h5 id="322-选择排序"><a class="markdownIt-Anchor" href="#322-选择排序"></a> 3.2.2 选择排序</h5><p>选择排序（Selection Sort）是一种简单的排序算法，它的基本思想是找到最小元素并将其放置在数组的起始位置，然后继续找到剩余元素中的最小元素并放置在已排序序列的末尾，以此类推，直到所有元素都排好序为止。</p><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E9%80%89%E6%8B%A9.gif" class="" title="sucessful"><p>具体实现过程如下：</p><ol><li>遍历整个数组，找到其中最小的元素，并记录其位置。</li><li>将最小元素与数组的第一个元素进行交换。</li><li>排除已排序的第一个元素，对剩余元素执行步骤 1 和 2，直到所有元素都被排序。</li></ol><p>下面是一个代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">selection_sort</span>(<span class="params">lst</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(lst)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        min_idx = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> lst[j] &lt; lst[min_idx]:</span><br><span class="line">                min_idx = j</span><br><span class="line">        lst[i], lst[min_idx] = lst[min_idx], lst[i]</span><br><span class="line">    <span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure><h5 id="323-插入排序"><a class="markdownIt-Anchor" href="#323-插入排序"></a> 3.2.3 插入排序</h5><p>一个一个插入到已排序序列中的合适位置，最终完成排序。具体实现过程如下：</p><ol><li>遍历整个数组，将数组中的第一个元素视为已排序序列。</li><li>遍历未排序序列中的元素，将它插入到已排序序列中的合适位置，使得插入后的序列仍然有序。</li><li>重复步骤 2 直到所有元素都被插入到已排序序列中。</li></ol><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E6%8F%92%E5%85%A5.gif" class="" title="sucessful"><p>下面是一个代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">lst</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(lst)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        key = lst[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> lst[j] &gt; key:</span><br><span class="line">            lst[j + <span class="number">1</span>] = lst[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        lst[j + <span class="number">1</span>] = key</span><br><span class="line">    <span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure><h5 id="324-希尔排序"><a class="markdownIt-Anchor" href="#324-希尔排序"></a> 3.2.4 希尔排序</h5><p>希尔排序（Shell Sort）是一种改进的插入排序算法，它是通过将整个序列分成若干个子序列来实现排序，每个子序列分别进行插入排序，最终完成整个序列的排序。</p><p>希尔排序的基本思想是将待排序序列按照一定的步长进行分组，对每组使用插入排序算法进行排序。然后将步长逐渐缩小，重复进行分组和排序，直到步长为 1。此时，序列已经被分成了若干个有序子序列，最后进行一次插入排序即可完成整个序列的排序。</p><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%B8%8C%E5%B0%94.gif" class="" title="sucessful"><p>下面是实现的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">shell_sort</span>(<span class="params">lst</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(lst)</span><br><span class="line">    gap = n // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap, n):</span><br><span class="line">            key = lst[i]</span><br><span class="line">            j = i - gap</span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> lst[j] &gt; key:</span><br><span class="line">                lst[j + gap] = lst[j]</span><br><span class="line">                j -= gap</span><br><span class="line">            lst[j + gap] = key</span><br><span class="line">        gap //= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure><p>其中，参数 lst 是一个待排序的列表，函数返回一个新的已排序的列表。函数首先将整个序列分成若干个子序列，对每个子序列使用插入排序算法进行排序。然后将步长 gap 逐渐缩小，重复进行分组和排序，直到步长为 1。在每个子序列中，将当前元素存储为关键字 key，并将它与已排序序列中的元素进行比较，找到合适的位置并插入，直到所有元素都被插入到已排序序列中为止。</p><h5 id="325-归并排序"><a class="markdownIt-Anchor" href="#325-归并排序"></a> 3.2.5 归并排序</h5><p>归并排序（Merge Sort）是一种稳定的排序算法，它采用分治思想将待排序序列分成若干个子序列，每个子序列都是有序的，然后再将这些有序的子序列合并成一个有序序列。</p><p>归并排序的基本思想是将待排序序列不断地对半分割，直到每个子序列只有一个元素，然后将相邻的子序列进行合并，形成新的有序子序列，直到最终只剩下一个有序序列为止。合并操作时，需要额外的一个数组来存储已经排序好的元素，最后再将排序好的元素复制回原数组。</p><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%BD%92%E5%B9%B6.gif" class="" title="sucessful"><p>以下是使用 Python 实现的归并排序代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">lst</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(lst) &gt; <span class="number">1</span>:</span><br><span class="line">        mid = <span class="built_in">len</span>(lst) // <span class="number">2</span></span><br><span class="line">        left_half = lst[:mid]</span><br><span class="line">        right_half = lst[mid:]</span><br><span class="line"></span><br><span class="line">        merge_sort(left_half)</span><br><span class="line">        merge_sort(right_half)</span><br><span class="line"></span><br><span class="line">        i = j = k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left_half) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right_half):</span><br><span class="line">            <span class="keyword">if</span> left_half[i] &lt; right_half[j]:</span><br><span class="line">                lst[k] = left_half[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lst[k] = right_half[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left_half):</span><br><span class="line">            lst[k] = left_half[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(right_half):</span><br><span class="line">            lst[k] = right_half[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure><p>其中，参数 lst 是一个待排序的列表，函数返回一个新的已排序的列表。函数首先将待排序序列不断地对半分割，直到每个子序列只有一个元素，然后将相邻的子序列进行合并，形成新的有序子序列，直到最终只剩下一个有序序列为止。在合并操作中，需要额外的一个数组来存储已经排序好的元素，最后再将排序好的元素复制回原数组。</p><h5 id="326-快速排序"><a class="markdownIt-Anchor" href="#326-快速排序"></a> 3.2.6 快速排序</h5><p>快速排序（Quick Sort）是一种常见的排序算法，它采用分治思想将待排序序列分成两个子序列，一部分小于基准元素，一部分大于基准元素。然后对这两个子序列分别进行递归排序，最终得到一个有序序列。</p><p>快速排序的基本思想是选定一个基准元素，然后通过一趟排序将待排序序列分成两部分，使得左边的子序列都小于基准元素，右边的子序列都大于基准元素，然后分别对左右两部分递归地进行快速排序，最终得到一个有序序列。</p><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%BF%AB%E9%80%9F.gif" class="" title="sucessful"><p>以下是使用 Python 实现的快速排序代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">lst, left, right</span>):</span><br><span class="line">    <span class="keyword">if</span> left &lt; right:</span><br><span class="line">        pivot_index = partition(lst, left, right)</span><br><span class="line">        quick_sort(lst, left, pivot_index - <span class="number">1</span>)</span><br><span class="line">        quick_sort(lst, pivot_index + <span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">lst, left, right</span>):</span><br><span class="line">    pivot = lst[left]</span><br><span class="line">    i, j = left + <span class="number">1</span>, right</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">while</span> i &lt;= j <span class="keyword">and</span> lst[i] &lt; pivot:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j <span class="keyword">and</span> lst[j] &gt;= pivot:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &lt;= j:</span><br><span class="line">            lst[i], lst[j] = lst[j], lst[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    lst[left], lst[j] = lst[j], lst[left]</span><br><span class="line">    <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure><p>其中，参数 lst 是一个待排序的列表，参数 left 和 right 是列表的左右边界，函数使用递归的方式实现快速排序。在递归的过程中，首先选定一个基准元素，然后通过 partition 函数将待排序序列分成两部分。partition 函数使用双指针的方式将待排序序列分成两部分，左边部分的元素都小于基准元素，右边部分的元素都大于等于基准元素。最后，将基准元素放在分界点上，返回分界点的位置。然后分别对左右两部分递归地进行快速排序，最终得到一个有序序列。</p><h3 id="4-树"><a class="markdownIt-Anchor" href="#4-树"></a> 4. 树</h3><p>不多介绍，直接看实现与算法</p><h4 id="41-树的实现"><a class="markdownIt-Anchor" href="#41-树的实现"></a> 4.1 树的实现</h4><h5 id="411-实现方法1列表之列表"><a class="markdownIt-Anchor" href="#411-实现方法1列表之列表"></a> 4.1.1 实现方法1：列表之列表</h5><p>例如，a为根节点，有子节点b，c，节点b又有子节点d（左），则使用列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a,[b,[d,[],[]],[]],[c,[],[]]]</span><br></pre></td></tr></table></figure><p>不说了，这方法真的会有人用吗</p><h5 id="412-实现方法2节点与引用"><a class="markdownIt-Anchor" href="#412-实现方法2节点与引用"></a> 4.1.2 实现方法2：节点与引用</h5><p>基础类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,rootObj</span>):</span><br><span class="line">self.key=rootObj</span><br><span class="line">self.leftChild=<span class="literal">None</span></span><br><span class="line">self.rightChild=<span class="literal">None</span></span><br></pre></td></tr></table></figure><p>插入左节点（如果已经存在左子节点，插入时要把原先的左子节点降一层，自己到那个位置）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">instertLeft</span>(<span class="params">self,newNode</span>):</span><br><span class="line"><span class="keyword">if</span>(self.leftChild==<span class="literal">None</span>):</span><br><span class="line">self.leftChild=BinaryTree(newNode)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">t=BinaryTree(newNode)</span><br><span class="line">t.leftChild=self.leftChild</span><br><span class="line">self.leftChild=t</span><br></pre></td></tr></table></figure><p>右子节点也一样。<br />访问函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getRightChild</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.rightChild</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getLeftChild</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.LeftChild</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setRootVal</span>(<span class="params">self,obj</span>):</span><br><span class="line">self.key=obj</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getRootVal</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.key</span><br></pre></td></tr></table></figure><h4 id="42-树的遍历"><a class="markdownIt-Anchor" href="#42-树的遍历"></a> 4.2 树的遍历</h4><p>树的遍历方式分为三种：前序遍历、中序遍历、后序遍历</p><h5 id="421-前序遍历"><a class="markdownIt-Anchor" href="#421-前序遍历"></a> 4.2.1 前序遍历</h5><p>先访问根节点，然后递归地前序遍历左子树，最后递归地前序遍历右子树</p><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%89%8D%E5%BA%8F.gif" class="" title="sucessful"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">tree</span>):</span><br><span class="line"><span class="keyword">if</span> tree:</span><br><span class="line"><span class="built_in">print</span>(tree.getRootVal())</span><br><span class="line">preorder(tree.getLeftChild())</span><br><span class="line">preorder(tree.getRightChild())</span><br></pre></td></tr></table></figure><h5 id="422-中序遍历"><a class="markdownIt-Anchor" href="#422-中序遍历"></a> 4.2.2 中序遍历</h5><p>先递归地中序遍历左子树，然后访问根节点，在中序遍历右子树</p><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E4%B8%AD%E5%BA%8F.gif" class="" title="sucessful"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">tree</span>):</span><br><span class="line"><span class="keyword">if</span> tree:</span><br><span class="line">inorder(tree.getLeftChild())</span><br><span class="line"><span class="built_in">print</span>(tree.getRootVal())</span><br><span class="line">inorder(tree.getRightChild())</span><br></pre></td></tr></table></figure><h5 id="423-后序遍历"><a class="markdownIt-Anchor" href="#423-后序遍历"></a> 4.2.3 后序遍历</h5><p>先递归地后序遍历右子树，然后递归地后序遍历左子树，最后访问根节点</p><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%90%8E%E5%BA%8F.gif" class="" title="sucessful"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">postorder</span>(<span class="params">tree</span>):</span><br><span class="line"><span class="keyword">if</span> tree:</span><br><span class="line">postorder(tree.getLeftChild())</span><br><span class="line">postorder(tree.getRightChild())</span><br><span class="line"><span class="built_in">print</span>(tree.getRootVal())</span><br></pre></td></tr></table></figure><h4 id="43-利用二叉堆实现优先级队列"><a class="markdownIt-Anchor" href="#43-利用二叉堆实现优先级队列"></a> 4.3 利用二叉堆实现优先级队列</h4><p>二叉堆（binary heap）是一种特殊的二叉树数据结构，它可以用数组来实现，并且常用于实现优先队列。</p><p>二叉堆分为最大堆和最小堆两种类型。最大堆满足任何一个父节点的键值大于等于它的任何一个子节点的键值；最小堆则满足任何一个父节点的键值小于等于它的任何一个子节点的键值。因此，最大堆的堆顶是堆中的最大元素，最小堆的堆顶是堆中的最小元素。</p><p>二叉堆的数组实现中，数组的第一个元素是根节点，数组的下标从1开始（而不是0）。对于第i个节点，它的左子节点在2i的位置，右子节点在2i+1的位置，父节点在i/2的位置（向下取整）。</p><p>二叉堆的主要操作包括插入一个元素、删除堆顶元素和查找堆顶元素。插入一个元素需要将元素插入到堆的最后一个位置，然后通过向上逐级比较交换，将新元素移动到合适的位置以维护堆的性质。删除堆顶元素需要将堆顶元素与堆中最后一个元素交换位置，然后删除最后一个元素，并通过向下逐级比较交换，将堆顶元素移动到合适的位置以维护堆的性质。查找堆顶元素只需要返回数组的第一个元素。</p><h5 id="431-二叉堆的实现"><a class="markdownIt-Anchor" href="#431-二叉堆的实现"></a> 4.3.1 二叉堆的实现</h5><p>在实现二叉堆时，我们通过创建一颗完全二叉树来维持树的平衡。在完全二叉树中，除了最底层，其他每一层的节点都是满的。在对底层，从左往右填充节点。</p><p>完全二叉树的特殊之处在于，可以用一个列表来表示它。<br />完全二叉树节点在列表中的排序为：从上而下，从左往右。<br />按此排布，对于在列表中位置p的节点来说，其左子节点的位置为2p，右子节点的位置为2p+1（请读者自行推算一遍）</p><p>二叉堆的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">self.heapList=[<span class="number">0</span>]</span><br><span class="line">self.currentSize=<span class="number">0</span></span><br></pre></td></tr></table></figure><p>对于一个要求子节点大于父节点的堆来说，插入的最简单、最高效的方法就是将元素追加到列表的末尾，然后和其父节点比较，若小于其父节点，就对换位置。此处代码不再给出，简单来说就是比较插入的第i个和父节点第i//2个对比。</p><p>二叉堆还有一个功能，删除最小元素（即根节点），但是删除后，需要对堆进行重建。重建方法为：</p><ol><li>取出列表中最后一个元素，将其放在根节点的位置</li><li>通过与子节点之间的交换，将新的根节点沿着树推到正确的位置</li></ol><h4 id="44-二叉搜索树"><a class="markdownIt-Anchor" href="#44-二叉搜索树"></a> 4.4 二叉搜索树</h4><p>二叉搜索树依赖于这样的性质：小于父节点的键都在左子树中，大于父节点的键则都在右子树中。</p><h5 id="441-插入"><a class="markdownIt-Anchor" href="#441-插入"></a> 4.4.1 插入</h5><p>根据性质，插入算法为：</p><ol><li>从根节点开始搜索二叉树，比较新键与当前节点的键，如果新键更小，搜索左子树，如果新键更大，搜索右子树</li><li>当没有可供搜索的左/右字节点时，说明找到了正确的位置。</li><li>创建一个TreeNode对象，并将其插入到前一步发现的位置上。</li></ol><p>下面是一个利用递归方法实现的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.root:</span><br><span class="line">            self.root = Node(val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._insert(val, self.root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_insert</span>(<span class="params">self, val, node</span>):</span><br><span class="line">        <span class="keyword">if</span> val &lt; node.val:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left:</span><br><span class="line">                node.left = Node(val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self._insert(val, node.left)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                node.right = Node(val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self._insert(val, node.right)</span><br></pre></td></tr></table></figure><h5 id="442-查找"><a class="markdownIt-Anchor" href="#442-查找"></a> 4.4.2 查找</h5><p>相似的，查找的方法为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, val</span>):</span><br><span class="line">    node = self.root</span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        <span class="keyword">if</span> node.val == val:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        <span class="keyword">elif</span> val &lt; node.val:</span><br><span class="line">            node = node.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = node.right</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h5 id="443-删除"><a class="markdownIt-Anchor" href="#443-删除"></a> 4.4.3 删除</h5><p>删除的情况就相对复杂。</p><ol><li>要删除的节点是叶子节点，也就是没有左右子节点的节点。在这种情况下，可以直接删除该节点，将其父节点的左子节点或右子节点指向 None。</li><li>要删除的节点只有一个子节点，可以将该节点的子节点替换为该节点。</li><li>要删除的节点有两个子节点。在这种情况下，可以将该节点的左子树的最大节点或右子树的最小节点替换该节点。（因为左子树的最大节点或右子树的最小节点正好可以填进去）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span>:</span><br><span class="line">    <span class="comment"># 省略插入方法和查找方法...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, val</span>):</span><br><span class="line">        node, parent = self.search_with_parent(val)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 未找到要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">or</span> <span class="keyword">not</span> node.right:  <span class="comment"># 第一种和第二种情况</span></span><br><span class="line">            child = node.left <span class="keyword">or</span> node.right</span><br><span class="line">            <span class="keyword">if</span> parent:</span><br><span class="line">                <span class="keyword">if</span> node == parent.left:</span><br><span class="line">                    parent.left = child</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    parent.right = child</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.root = child</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 第三种情况</span></span><br><span class="line">            succ = node.right</span><br><span class="line">            <span class="keyword">while</span> succ.left:</span><br><span class="line">                succ = succ.left</span><br><span class="line">            node.val = succ.val</span><br><span class="line">            <span class="keyword">if</span> succ == node.right:</span><br><span class="line">                node.right = succ.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = self.search_with_parent(succ.val)[<span class="number">1</span>]</span><br><span class="line">                p.left = succ.right</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="45-平衡二叉搜索树"><a class="markdownIt-Anchor" href="#45-平衡二叉搜索树"></a> 4.5 平衡二叉搜索树</h4><p>这个真太烦了，我不高兴看了T.T</p><h4 id="46-霍夫曼树"><a class="markdownIt-Anchor" href="#46-霍夫曼树"></a> 4.6 霍夫曼树</h4><p>霍夫曼树（Huffman Tree）是一种带权路径最短的树，通常用于数据压缩。它的构建过程基于贪心算法，根据数据频率构建一棵无损压缩的树。具体来说，给定一组数据和对应的权值，霍夫曼树的构建过程如下：</p><ol><li>对所有的数据按照权值从小到大排序，每个数据作为一个单独的节点。</li><li>每次从排序后的节点中选取权值最小的两个节点，将它们合并为一个新节点，新节点的权值为两个节点的权值之和，左子节点为权值较小的节点，右子节点为权值较大的节点。</li><li>将新节点插入到排序后的节点列表中，并删除原来的两个节点。</li><li>重复步骤2和3，直到只剩下一个节点为止，该节点即为霍夫曼树的根节点。</li></ol><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%93%88%E5%A4%AB%E6%9B%BC.gif" class="" title="sucessful style&#x3D;display: block; margin: 0 auto; max-width: 50%;"><p>下面是一个Python实现示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HuffmanNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value, weight</span>):</span><br><span class="line">        self.value = value</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_huffman_tree</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="comment"># 构建叶子节点列表</span></span><br><span class="line">    nodes = [HuffmanNode(val, weight) <span class="keyword">for</span> val, weight <span class="keyword">in</span> data]</span><br><span class="line">    <span class="comment"># 构建霍夫曼树</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(nodes) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># 按权值排序</span></span><br><span class="line">        nodes.sort(key=<span class="keyword">lambda</span> node: node.weight)</span><br><span class="line">        <span class="comment"># 取出权值最小的两个节点</span></span><br><span class="line">        left_node = nodes.pop(<span class="number">0</span>)</span><br><span class="line">        right_node = nodes.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 构建新节点</span></span><br><span class="line">        new_weight = left_node.weight + right_node.weight</span><br><span class="line">        new_node = HuffmanNode(<span class="literal">None</span>, new_weight)</span><br><span class="line">        new_node.left = left_node</span><br><span class="line">        new_node.right = right_node</span><br><span class="line">        <span class="comment"># 将新节点加入节点列表中</span></span><br><span class="line">        nodes.append(new_node)</span><br><span class="line">    <span class="comment"># 返回根节点</span></span><br><span class="line">    <span class="keyword">return</span> nodes[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>在这个实现中，我们先定义了一个<code>HuffmanNode</code>类，表示霍夫曼树中的节点。每个节点包含一个<code>value</code>属性表示节点的值（如果节点是叶子节点，则为原始数据），一个<code>weight</code>属性表示节点的权值，以及左子节点和右子节点。我们还定义了一个<code>build_huffman_tree(data)</code>函数，用于构建霍夫曼树。<code>data</code>参数是一个二元组列表，每个二元组包含一个数据和对应的权值。函数返回霍夫曼树的根节点。</p><p>在构建完霍夫曼树后，我们可以通过对树进行遍历来获得每个数据的编码。具体来说，我们可以对树进行先序遍历，在遍历过程中，记录每个叶子节点的编码（0表示向左走，1表示向右走）。最终得到的编码就是霍夫曼编码，可以用于数据压缩。</p><p>例如，如果一个数据出现的频率很高，代表着他权值很高，我们可以用一个比较短的编码来表示它，比如说用一个1位的编码表示它。而如果一个数据出现的频率很低，我们可以用一个比较长的编码来表示它，比如说用一个10位的编码表示它。这样，在对数据进行编码后，数据的存储空间就会减少。</p><h3 id="5-图"><a class="markdownIt-Anchor" href="#5-图"></a> 5. 图</h3><p>下面先回顾一下图中的术语以及定义：</p><ol><li>顶点（vertex）：也称为节点，表示图中的一个点，通常用一个唯一的标识符来标识。</li><li>边（edge）：表示两个顶点之间的连线，可以是有向或无向的，可以有权重或无权重。</li><li>权重（weight）：如果边带有数值，则称这个数值为边的权重。</li><li>路径（path）：表示从一个顶点到另一个顶点依次经过的边和顶点的序列，路径的长度为路径上所有边的权重之和。</li><li>环（cycle）：表示一个顶点经过一系列边回到自身的路径。</li><li>连通（connected）：如果图中的任意两个顶点都有一条路径相连，则称该图是连通的。</li><li>连通分量（connected component）：无向图中每个连通的部分称为一个连通分量。</li><li>强连通（strongly connected）：如果有向图中的任意两个顶点都有互相到达的路径，则称该图是强连通的。</li><li>强连通分量（strongly connected component）：有向图中每个强连通的部分称为一个强连通分量。</li><li>入度（in-degree）：有向图中指向一个顶点的边的数量。</li><li>出度（out-degree）：有向图中从一个顶点出发的边的数量。</li><li>邻接点（adjacent vertex）：与一个顶点直接相连的顶点称为它的邻接点。</li><li>邻接矩阵（adjacency matrix）：用矩阵来表示图中每个顶点之间的连通关系，其中矩阵中的行和列分别代表图中的顶点，矩阵中的元素表示两个顶点之间是否有连通关系。</li><li>邻接表（adjacency list）：用链表来表示图中每个顶点的邻接点列表，链表中的每个节点表示一个邻接点。</li></ol><h4 id="51-图的抽象数据类型以及其实现"><a class="markdownIt-Anchor" href="#51-图的抽象数据类型以及其实现"></a> 5.1 图的抽象数据类型以及其实现</h4><h5 id="511-邻接矩阵"><a class="markdownIt-Anchor" href="#511-邻接矩阵"></a> 5.1.1 邻接矩阵</h5><p>只是一个矩阵，不多赘述</p><h5 id="512-邻接表"><a class="markdownIt-Anchor" href="#512-邻接表"></a> 5.1.2 邻接表</h5><p>python中，字典的键值对可以有效地实现图的边。下面是一个示例，利用字典connectedTo来记录与节点Vertex相邻的点。</p><p>以下给出一个节点类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,key</span>):</span><br><span class="line">self.<span class="built_in">id</span>=key</span><br><span class="line">self.connectedTo=&#123;&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addNeighbor</span>(<span class="params">self,nbr,weight=<span class="number">0</span></span>):</span><br><span class="line">self.connectefTo(nbr)=weight</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">str</span>(self.<span class="built_in">id</span>)+<span class="string">&#x27; connectedTo: &#x27;</span>+<span class="built_in">str</span>([x.<span class="built_in">id</span> <span class="keyword">for</span> x <span class="keyword">in</span> self.connectedTo])</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getConnections</span>(<span class="params">self</span>):</span><br><span class="line"><span class="comment">#通过获取所有键，获取节点所有相接的顶点名</span></span><br><span class="line"><span class="keyword">return</span> self.connectedTo.keys()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getId</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.<span class="built_in">id</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getWeight</span>(<span class="params">self,nbr</span>):</span><br><span class="line"><span class="keyword">return</span> self.connectedTo[nbr]</span><br></pre></td></tr></table></figure><p>Graph类就不再赘述，只需要特别注意两个功能：添加顶点，添加边</p><h4 id="52-广度优先搜索bfs"><a class="markdownIt-Anchor" href="#52-广度优先搜索bfs"></a> 5.2 广度优先搜索（BFS）</h4><p>要求边的权值都为0！！！！！！</p><p>BFS，即广度优先搜索（Breadth-First Search），是一种图的遍历算法，用于在图中搜索特定的节点或路径。BFS从给定的起始节点开始遍历图，首先访问起始节点的所有邻居节点，然后按照遍历的深度依次访问下一层节点，直到遍历完整张图或找到目标节点为止。</p><p>BFS通常借助队列（Queue）数据结构来实现。首先将起始节点加入队列中，然后不断从队列中取出最早进入队列的节点，并将其邻居节点加入队列中（如果之前取过了，则不取），并计算节点到起始节点的距离（父节点到起始节点的距离+1）直到队列为空或找到目标节点为止。</p><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.gif" class="" title="sucessful style&#x3D;display: block; margin: 0 auto; max-width: 50%;"><p>下面是一个实现的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pythonds.graphs <span class="keyword">import</span> Graph, Vertex</span><br><span class="line"><span class="keyword">from</span> pythonds.basic <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">BFS</span>(<span class="params">g,start,end</span>):</span><br><span class="line"><span class="comment">#储存据起始节点距离</span></span><br><span class="line">distance=&#123;&#125;</span><br><span class="line">distance[start]=<span class="number">0</span></span><br><span class="line"><span class="comment">#储存是否有被访问过</span></span><br><span class="line">visited=[]</span><br><span class="line"><span class="comment">#队列</span></span><br><span class="line">queue=Queue()</span><br><span class="line">queue.enqueue(start)</span><br><span class="line"><span class="comment">#创建字典，用于记录每个节点的父节点，用于回溯路径</span></span><br><span class="line">parent = &#123;&#125; </span><br><span class="line"><span class="keyword">while</span>(!queue.size==<span class="number">0</span>):</span><br><span class="line"><span class="comment">#currentq：当前访问到的节点，名字起错了，不想改了</span></span><br><span class="line">currentq=queue.dequeue()</span><br><span class="line"><span class="keyword">if</span>(currentq==end):</span><br><span class="line"><span class="comment">#回溯打印</span></span><br><span class="line"><span class="keyword">while</span>(!currentq==start):</span><br><span class="line"><span class="built_in">print</span>(currentq.<span class="built_in">id</span>)</span><br><span class="line">currentq=parent[currentq]</span><br><span class="line"><span class="built_in">print</span>(start.<span class="built_in">id</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> currentq.connectedTo:</span><br><span class="line"><span class="keyword">if</span>(item <span class="keyword">not</span> <span class="keyword">in</span> visited):</span><br><span class="line">visited.appenf(item)</span><br><span class="line">queue.enqueue(item)</span><br><span class="line">distance[item]=distance[current]+<span class="number">1</span></span><br><span class="line">parent[item]=currentq</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="53-深度优先搜索"><a class="markdownIt-Anchor" href="#53-深度优先搜索"></a> 5.3 深度优先搜索</h4><p>深度优先搜索（Depth-First-Search, DFS）是一种用于遍历或搜索树或图的算法，其主要思想是从起点开始，不断往深度方向搜索，直到找到目标节点或者无法继续为止，然后返回上一层节点，继续搜索其他未被访问过的节点。</p><p>递归式的DFS可以通过递归调用实现。具体实现过程如下：</p><ol><li>创建一个visited数组，用于记录每个节点是否被访问过，初始值都为False。</li><li>定义DFS函数，输入参数为当前节点和图的邻接表表示。首先标记当前节点为已访问，并输出当前节点。然后遍历当前节点的邻居节点，对于每个未被访问过的邻居节点，递归调用DFS函数。</li><li>在主函数中遍历图中的每个节点，对于每个未被访问过的节点，调用DFS函数。</li></ol><p>以下是Python实现代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">currentVertex, visited</span>)<span class="comment">#当前访问的节点，已经访问过的节点列表</span></span><br><span class="line">visited[currentVertex]=<span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span>(currentVertex.<span class="built_in">id</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> currentVertex.connectedTo:</span><br><span class="line"><span class="keyword">if</span>(item <span class="keyword">not</span> <span class="keyword">in</span> visited):</span><br><span class="line">DFS(currentVertex,visited)</span><br></pre></td></tr></table></figure><h4 id="54-最短路径"><a class="markdownIt-Anchor" href="#54-最短路径"></a> 5.4 最短路径</h4><h5 id="541-dijkstra算法"><a class="markdownIt-Anchor" href="#541-dijkstra算法"></a> 5.4.1 Dijkstra算法</h5><p>Dijkstra算法是一种用于求解单源最短路径的贪心算法，它能够计算出从一个源点到图中其他所有点的最短路径。算法的基本思想是维护一个到源点的距离数组，每次选取一个距离最短的点进行松弛操作（通过更新边来减小从起点到顶点的距离），更新其他节点到源点的距离值。当所有节点都被更新后，最短路径就求解完成。</p><p>以下是使用Python实现Dijkstra算法的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个函数用于实现Dijkstra算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dijkstra</span>(<span class="params">graph, start</span>):</span><br><span class="line">    <span class="comment"># 初始化距离字典，所有节点的距离值默认为无限大</span></span><br><span class="line">    dist = &#123;node: <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125;</span><br><span class="line">    <span class="comment"># 将起点的距离值初始化为0</span></span><br><span class="line">    dist[start] = <span class="number">0</span></span><br><span class="line">    ……<span class="comment">#初始化距离字典</span></span><br><span class="line">    <span class="comment"># 初始化路径字典</span></span><br><span class="line">    path = &#123;start: []&#125;</span><br><span class="line">    <span class="comment"># 将起点放入已访问节点集合中</span></span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 从未访问节点中找到距离起点最近的节点</span></span><br><span class="line">        min_node = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> graph:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">if</span> min_node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    min_node = node</span><br><span class="line">                <span class="keyword">elif</span> dist[node] &lt; dist[min_node]:</span><br><span class="line">                    min_node = node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> min_node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将该节点标记为已访问</span></span><br><span class="line">        visited.add(min_node)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新所有与该节点相邻的节点的距离值</span></span><br><span class="line">        <span class="keyword">for</span> neighbor, weight <span class="keyword">in</span> graph[min_node].items():</span><br><span class="line">            <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                new_dist = dist[min_node] + weight</span><br><span class="line">                <span class="keyword">if</span> new_dist &lt; dist[neighbor]:</span><br><span class="line">                    dist[neighbor] = new_dist</span><br><span class="line">                    path[neighbor] = path[min_node] + [min_node]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist, path</span><br></pre></td></tr></table></figure><h5 id="542-prim算法"><a class="markdownIt-Anchor" href="#542-prim算法"></a> 5.4.2 Prim算法</h5><p>Prim算法是一种用于解决最小生成树问题的贪心算法。其基本思路是从一个起点开始，不断扩展生成树，每次加入距离已有部分最近的一个点，直到所有点都被加入为止。</p><p>具体步骤如下：</p><ol><li>初始化一个空的生成树，以一个节点作为起始节点；</li><li>找到与生成树相邻的边中，权值最小的那条边，将其连接的点加入生成树中；</li><li>重复第二步，直到所有节点都加入生成树中。</li></ol><p>该算法可以借助优先级队列来实现（Dijkstra算法也可以，但我没用），优先级队列可以弹出包含最小元素的字典。</p><p>下面是一个python实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pythonds.graphs <span class="keyword">import</span> PriorityQueue, Graph, Vertex</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Prim</span>(<span class="params">G, start</span>):</span><br><span class="line">pq=PriorityQueue()</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> G:</span><br><span class="line">v.setDistance(sys.maxsize)<span class="comment">#设置和起始点的距离</span></span><br><span class="line">v.setPred(<span class="literal">None</span>)<span class="comment">#设置前驱结点</span></span><br><span class="line">start.SetDistance(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#创建一个堆，存放河节点的相邻节点</span></span><br><span class="line">pq.buildHeap([(v.getDistance, v) <span class="keyword">for</span> v <span class="keyword">in</span> G])</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> pq.isEmpty():</span><br><span class="line"><span class="comment">#取出最小的起始点的相邻节点</span></span><br><span class="line">currentVert=pq.delMin()</span><br><span class="line"><span class="comment">#遍历该节点的所有相邻节点</span></span><br><span class="line"><span class="keyword">for</span> nextVert <span class="keyword">in</span> currentVert.getConnections():</span><br><span class="line"><span class="comment">#新的距离=节点currentVert和原点的距离+当前节点和currentVert的距离</span></span><br><span class="line">newCost=currentVert.getWeight(nextVert)+currentVert.getDistance()</span><br><span class="line"><span class="comment">#如果新生成的路径长度比原来的短</span></span><br><span class="line"><span class="keyword">if</span> v <span class="keyword">in</span> pq <span class="keyword">and</span> newCost&lt;nextVert.getDistance():</span><br><span class="line">nextVert.setPred(currentVert)</span><br><span class="line">nextVert.setDistance(newCost)</span><br><span class="line">pq.decreaseKey(nextVert,newCost)</span><br></pre></td></tr></table></figure><h3 id="6-python基础复习"><a class="markdownIt-Anchor" href="#6-python基础复习"></a> 6. python基础复习</h3><h4 id="61-python基础库"><a class="markdownIt-Anchor" href="#61-python基础库"></a> 6.1 python基础库</h4><ol><li>队列：queue，入队和出队的方法分别是put()和get()，empty(): 判断队列是否为空。qsize(): 返回队列中当前的元素个数。</li><li>栈：Python 中没有专门表示栈的基础库，但是可以使用内置的 list类来实现栈的功能，因为list 的 append() 和 pop()方法可以分别实现入栈和出栈操作。</li></ol><h4 id="62-基础函数"><a class="markdownIt-Anchor" href="#62-基础函数"></a> 6.2 基础函数</h4><h5 id="621-列表基础函数"><a class="markdownIt-Anchor" href="#621-列表基础函数"></a> 6.2.1 列表基础函数</h5><ol><li>append：在列表末尾添加一个元素，例如：<code>list.append(item)</code></li><li>extend：将一个列表中的所有元素添加到另一个列表末尾，例如：<code>list.extend(another_list)</code></li><li>insert：在列表的指定位置插入一个元素，例如：<code>list.insert(index, item)</code></li><li>remove：删除列表中指定的元素，例如：<code>list.remove(item)</code></li><li>pop：从列表中删除指定位置的元素，并返回该元素，例如：<code>list.pop(index)</code></li><li>index：返回列表中指定元素的索引位置，例如：<code>list.index(item)</code></li><li>count：返回列表中指定元素出现的次数，例如：<code>list.count(item)</code></li><li>sort：对列表中的元素进行排序，例如：<code>list.sort()</code></li><li>reverse：将列表中的元素反向排序，例如：<code>list.reverse()</code></li><li>clear：从列表中删除所有元素，例如：<code>list.clear()</code></li><li>构建二维数组：Sum=[[0 for i in range(n)]for j in range(m)]</li></ol><h5 id="622-字典基础函数"><a class="markdownIt-Anchor" href="#622-字典基础函数"></a> 6.2.2 字典基础函数</h5><ol><li>dict()：创建一个新字典</li><li>len(dict)：返回字典中键值对的数量</li><li>dict[key]：获取字典中指定键的值</li><li>dict[key] = value：设置字典中指定键的值</li><li>del dict[key]：从字典中删除指定键</li><li>key in dict：检查字典中是否包含指定键</li><li>dict.keys()：返回一个包含字典所有键的列表</li><li>dict.values()：返回一个包含字典所有值的列表</li><li>dict.items()：返回一个包含字典所有键值对的列表</li><li>dict.get(key, default)：获取字典中指定键的值，如果键不存在返回默认值</li><li>dict.setdefault(key, default)：获取字典中指定键的值，如果键不存在设置默认值并返回</li><li>dict.pop(key, default)：从字典中删除指定键，并返回其对应的值。如果键不存在返回默认值</li><li>dict.update(other_dict)：使用其他字典中的键值对来更新当前字典</li></ol><h5 id="623-map-filter函数"><a class="markdownIt-Anchor" href="#623-map-filter函数"></a> 6.2.3 map、filter函数</h5><p><code>map()</code> 是 Python 内置的一个高阶函数，它将一个函数作用于一个或多个可迭代对象的每个元素上，并返回一个可迭代对象（迭代器），其中包含应用函数后的结果。</p><p><code>map()</code> 函数的语法如下，下面是一个简单的例子，将一个列表中的每个元素乘以 2：：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">double</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">doubled_numbers = <span class="built_in">list</span>(<span class="built_in">map</span>(double, numbers))</span><br><span class="line"><span class="built_in">print</span>(doubled_numbers)  <span class="comment"># [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>double()</code> 函数接收一个参数并返回该参数的两倍。<code>map()</code> 函数将 <code>double()</code> 应用于 <code>numbers</code> 列表中的每个元素，并返回一个迭代器，其中包含应用函数后的结果。<code>list()</code> 函数将迭代器转换为一个列表，最终输出 <code>[2, 4, 6, 8, 10]</code>。</p><p><code>filter</code>函数：对一个可迭代对象中的元素进行过滤，返回满足条件的元素组成的新的可迭代对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_even</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">return</span> num % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">even_nums = <span class="built_in">filter</span>(is_even, nums)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(even_nums))  <span class="comment"># [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure><h5 id="624-字符串函数"><a class="markdownIt-Anchor" href="#624-字符串函数"></a> 6.2.4 字符串函数</h5><ol><li>len()：获取字符串的长度。</li><li>strip()：去掉字符串开头和结尾的空格。</li><li>split()：按照指定的分隔符将字符串分割成列表。</li><li>join()：将列表或元组中的字符串拼接成一个字符串，中间用指定的字符隔开。</li><li>replace()：将字符串中指定的子字符串替换为另一个字符串。</li><li>find()：查找指定的子字符串在字符串中的位置，返回第一个匹配到的位置。</li><li>lower()和upper()：分别将字符串转换成小写和大写。</li><li>startswith()和endswith()：判断字符串是否以指定的字符串开头或结尾。</li><li>isdigit()、isalpha()和isalnum()：判断字符串是否全部由数字、字母或数字字母组成。</li><li>format()：将指定的值格式化到字符串中。</li><li>list()：转化为一个列表</li></ol><p>示例：join的用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">words = [<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;awesome&#x27;</span>]</span><br><span class="line">sep = <span class="string">&#x27; &#x27;</span></span><br><span class="line">sentence = sep.join(words)</span><br><span class="line"><span class="built_in">print</span>(sentence) <span class="comment"># 输出：Python is awesome</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;2023-04-03日上传，2023-04-05日第三次更新。&lt;br /&gt;
报了个蓝桥杯的python赛道，却没怎么复习……稍微整理了一些数据结构（python实现）的知识点，赛前看一下。&lt;/p&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
</feed>
