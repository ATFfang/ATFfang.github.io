<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ATField&#39; s BLOG</title>
  
  <subtitle>ATField</subtitle>
  <link href="https://atffang.github.io/atom.xml" rel="self"/>
  
  <link href="https://atffang.github.io/"/>
  <updated>2023-11-12T06:38:48.598Z</updated>
  <id>https://atffang.github.io/</id>
  
  <author>
    <name>FangTianYao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python并行运算</title>
    <link href="https://atffang.github.io/2023/11/12/python%E5%B9%B6%E8%A1%8C%E8%BF%90%E7%AE%97/"/>
    <id>https://atffang.github.io/2023/11/12/python%E5%B9%B6%E8%A1%8C%E8%BF%90%E7%AE%97/</id>
    <published>2023-11-12T05:33:09.000Z</published>
    <updated>2023-11-12T06:38:48.598Z</updated>
    
    <content type="html"><![CDATA[<p>使用multiprocessing函数在python中实现并行运算。<br><span id="more"></span><br>python中自带的 <a href="https://docs.python.org/zh-cn/3/library/multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code>multiprocessing</code></a> 包同时提供了本地和远程并发操作，允许程序员充分利用设备上的多个处理器。本文主要介绍之中的Pool对象，它提供了一种快捷的方法，赋予函数并行化处理一系列输入值的能力，可以将输入数据分配给不同进程处理（数据并行）。在官方文档中的例子是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> Pool(<span class="number">5</span>) <span class="keyword">as</span> p:</span><br><span class="line">        <span class="built_in">print</span>(p.<span class="built_in">map</span>(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br></pre></td></tr></table></figure><br>本文将简单演示并行运算在处理数据中带来的性能提升。我将使用Pool函数实现并行遍历一个包含一百万条数据的csv文件并进行一些简单的运算，以对比我的设备在不同的进程数量下处理数据的速度。<br>代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool  </span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_csv_chunk</span>(<span class="params">file_chunk</span>):  </span><br><span class="line">    df0 = pd.read_csv(file_chunk)  </span><br><span class="line">    <span class="keyword">return</span> df0  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 简单读取运算一下数据  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">df0</span>):  </span><br><span class="line">    result_sum = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> index, row <span class="keyword">in</span> df0.iterrows():  </span><br><span class="line">        result_sum += row[<span class="number">5</span>] * row[<span class="number">0</span>]  </span><br><span class="line">    <span class="keyword">return</span> result_sum  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 并行运算  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deal_csv_parallel</span>(<span class="params">df0, times</span>):  </span><br><span class="line">    result_sum = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">if</span> times == <span class="number">0</span>:  </span><br><span class="line">        <span class="keyword">for</span> index, row <span class="keyword">in</span> df0.iterrows():  </span><br><span class="line">            result_sum += row[<span class="number">5</span>] * row[<span class="number">0</span>]  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> result_sum  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> times != <span class="number">0</span>:  </span><br><span class="line">        chunk_size = <span class="built_in">len</span>(df0) // times  </span><br><span class="line">        chunks = [df[i:i + chunk_size] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(df), chunk_size)]  </span><br><span class="line">        <span class="keyword">with</span> Pool(times) <span class="keyword">as</span> p:  </span><br><span class="line">            results = p.<span class="built_in">map</span>(f, chunks)  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(results)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">      </span><br><span class="line">    <span class="comment"># 文件路径  </span></span><br><span class="line">    file_path = <span class="string">&#x27;output.csv&#x27;</span>  </span><br><span class="line">  </span><br><span class="line">    df = read_csv_chunk(file_path)  </span><br><span class="line">  </span><br><span class="line">    Pool_size = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>)]  </span><br><span class="line">    run_time = []  </span><br><span class="line">    run_time_multiple = []  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> Pool_size:  </span><br><span class="line">        start_time = time.time()  </span><br><span class="line">  </span><br><span class="line">        deal_csv_parallel(df, i)  </span><br><span class="line">  </span><br><span class="line">        end_time = time.time()  </span><br><span class="line">  </span><br><span class="line">        t = end_time - start_time  </span><br><span class="line">  </span><br><span class="line">        run_time.append(t)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> run_time:  </span><br><span class="line">        run_time_multiple.append(<span class="string">f&quot;<span class="subst">&#123;run_time[<span class="number">0</span>]/item*<span class="number">100</span>&#125;</span>%&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">    data = &#123;<span class="string">&#x27;并行数&#x27;</span>: Pool_size, <span class="string">&#x27;运行时间&#x27;</span>: run_time, <span class="string">&#x27;效率比&#x27;</span>: run_time_multiple&#125;   </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">print</span>(df_out)</span><br></pre></td></tr></table></figure><br>其中，<code>chunks = [df[i:i + chunk_size] for i in range(0, len(df), chunk_size)]</code>负责将表格拆分成和进程数相等的几个部分，随后通用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> Pool(times) <span class="keyword">as</span> p:  </span><br><span class="line">    results = p.<span class="built_in">map</span>(f, chunks) </span><br></pre></td></tr></table></figure><br>进行并行运算。代码运行的结果为：</p><div class="table-container"><table><thead><tr><th style="text-align:center">进程数</th><th style="text-align:center">运行时间</th><th style="text-align:center">效率比</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">30.298478</td><td style="text-align:center">100.0%</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">30.566270</td><td style="text-align:center">99.12389630201749%</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">15.768265</td><td style="text-align:center">192.14846418175512%</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">10.124307</td><td style="text-align:center">299.26471386481404%</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">7.879102</td><td style="text-align:center">384.5422643570513%</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">7.495068</td><td style="text-align:center">404.24552340989857%</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">6.015692</td><td style="text-align:center">503.65742377427705%</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">5.712452</td><td style="text-align:center">530.3935987002207%</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">5.440717</td><td style="text-align:center">556.8838978332274%</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">5.770803</td><td style="text-align:center">525.030563530312%</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">5.318123</td><td style="text-align:center">569.7212889333297%</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">5.124458</td><td style="text-align:center">591.2523645483335%</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">5.040725</td><td style="text-align:center">601.0737603013101%</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">5.147555</td><td style="text-align:center">588.5993925729343%</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">4.993004</td><td style="text-align:center">606.8185840078334%</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">5.116237</td><td style="text-align:center">592.2023776071396%</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">5.017882</td><td style="text-align:center">603.8101404027773%</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">5.150956</td><td style="text-align:center">588.2107286306572%</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">5.068639</td><td style="text-align:center">597.7636351261095%</td></tr><tr><td style="text-align:center">19</td><td style="text-align:center">4.979399</td><td style="text-align:center">608.4766411595016%</td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">5.103571</td><td style="text-align:center">593.6720989778112%</td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">5.076162</td><td style="text-align:center">596.8777272425182%</td></tr><tr><td style="text-align:center">22</td><td style="text-align:center">5.401071</td><td style="text-align:center">560.9716614488367%</td></tr><tr><td style="text-align:center">23</td><td style="text-align:center">5.360952</td><td style="text-align:center">565.1697690343107%</td></tr><tr><td style="text-align:center">24</td><td style="text-align:center">5.318242</td><td style="text-align:center">569.7085696153763%</td></tr><tr><td style="text-align:center">25</td><td style="text-align:center">5.748274</td><td style="text-align:center">527.088308186721%</td></tr></tbody></table></div><div style="width: 90%;margin: 0 auto">    <canvas id="chart6199" style="height: 300px"></canvas></div><script src="https://cdn.jsdelivr.net/npm/chart.js@2.9.3/dist/Chart.min.js"></script><script type="text/javascript">    var ctx = document.getElementById('chart6199').getContext('2d');    var options =       {      type: 'line',      data: {      labels: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25'],      datasets: [{          label: '运行速度',          borderColor: 'rgb(255, 99, 132)',          data: [30.298478, 30.566270, 15.768265, 10.124307, 7.879102, 7.495068, 6.015692, 5.712452, 5.440717, 5.770803, 5.318123, 5.124458, 5.040725, 5.147555, 4.993004, 5.116237, 5.017882, 5.150956, 5.068639, 4.979399, 5.103571, 5.076162, 5.401071, 5.360952, 5.318242, 5.748274]          }]      },      options: {          responsive: true,          title: {          display: true,          text: '进程数与运行速度'          }      }  }  ;    new Chart(ctx, options);</script><p>可以看到，在进程数大于对于4后程序运行速度下降开始收敛，并维持在一定水平。速度最低点较非并行运算节约了5/6的时间，可见并行预算对这种背景下的数据处理带来的收益之大。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用multiprocessing函数在python中实现并行运算。&lt;br&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
  <entry>
    <title>树莓派服务器搭建01：一个内网访问的云服务器</title>
    <link href="https://atffang.github.io/2023/11/11/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA01%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%86%85%E7%BD%91%E8%AE%BF%E9%97%AE%E7%9A%84%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://atffang.github.io/2023/11/11/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA01%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%86%85%E7%BD%91%E8%AE%BF%E9%97%AE%E7%9A%84%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2023-11-11T02:04:14.000Z</published>
    <updated>2023-11-12T03:46:05.215Z</updated>
    
    <content type="html"><![CDATA[<p>瞎捣鼓:)<br><span id="more"></span></p><p>上个月一时兴起，购入了一块树莓派4B。</p><p><img src=https://s2.loli.net/2023/11/12/4XA5YE8GZDuNbOg.png  width=60%/> 到手后烧录了带GUI的Raspberry Pi系统，换源、安装了一些依赖并外接了键鼠小屏幕后，就因为面试的事搁置了。直到现在才想到将它好好利用起来。搁置的这段时间只零零散散部署过一些爬虫，但是由于部署程序时，我只通过filezilla完成主机与树莓派服务器之间的数据传输，再把数据传给实验室其他人，过程略显繁琐。因此，这次我打算直接将树莓派服务器作为实验室内网下的云存储平台使用。<br>在修改前，首先要解决一个问题：在同一局域网下，我的主机无法ping通树莓派服务器，但是在同一手机热点下确可以。解决方法是在主机(Windows)中修改防火墙高级允许入站、出站规则中的<strong>文件和打印机共享</strong></p><p><img src=https://s2.loli.net/2023/11/12/DU1ShQJ6c7vky89.png  width=60% align="center"/>这个问题煞是令我费解。因为在手机热点下电脑可以ping通服务器，但在WiFi下却需要修改防火墙设置，不知道背后的逻辑是什么。<br>确认机器间的连接通畅后，就可以开始设置树莓派了。为了安全起见，我首先在root下新建了一个账号，将共享的文件置于该账号下。首先更新一下源：<br><code>sudo apt-get update</code><br>安装samba程序。Samba(Server Message Block)是一个开源的软件套件，用于实现基于SMB/CIFS协议的文件和打印服务，使得不同操作系统的计算机能够在局域网上共享文件和打印机。<br><code>sudo apt-get install samba samba-common-bin</code><br>随后修改配置文件：<br><code>sudo vi /etc/samba/smb.conf</code><br>在share definitions一章将read only = yes改为=no，使得其他用户得以修改共享的文件。保存编辑并重启samba服务：<br><code>sudo /etc/init.d/smbd restart</code><br>添加默认用户：<br><code>sudo smbpasswd -a 刚刚新建的用户名</code><br>在文件资源管理器中打开地址：<code>\\树莓派ip地址\用户名</code>，按要求输入账号密码（就是刚才创建与添加的），即可访问：<br><img src=https://s2.loli.net/2023/11/12/hwjHTnEaMG2UQcm.png  width=60%/></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;瞎捣鼓:)&lt;br&gt;</summary>
    
    
    
    <category term="或许用得到的tips" scheme="https://atffang.github.io/categories/%E6%88%96%E8%AE%B8%E7%94%A8%E5%BE%97%E5%88%B0%E7%9A%84tips/"/>
    
    
  </entry>
  
  <entry>
    <title>百度指数爬取</title>
    <link href="https://atffang.github.io/2023/09/11/%E7%99%BE%E5%BA%A6%E6%8C%87%E6%95%B0%E7%88%AC%E5%8F%96%E2%80%94%E2%80%94%E4%B8%8D%E5%90%8C%E5%9F%8E%E5%B8%82%E5%AF%B9%E4%BA%8E%E5%90%84%E7%B1%BB%E5%85%B3%E9%94%AE%E8%AF%8D%E6%90%9C%E7%B4%A0%E9%87%8F%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/"/>
    <id>https://atffang.github.io/2023/09/11/%E7%99%BE%E5%BA%A6%E6%8C%87%E6%95%B0%E7%88%AC%E5%8F%96%E2%80%94%E2%80%94%E4%B8%8D%E5%90%8C%E5%9F%8E%E5%B8%82%E5%AF%B9%E4%BA%8E%E5%90%84%E7%B1%BB%E5%85%B3%E9%94%AE%E8%AF%8D%E6%90%9C%E7%B4%A0%E9%87%8F%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/</id>
    <published>2023-09-11T14:02:38.000Z</published>
    <updated>2023-09-11T14:40:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>程序设计需求：横向对比中国各城市对于各关键词百度搜索强度。<br><span id="more"></span><br>&emsp;&emsp;本程序基于网友longxiaofei设计的百度指数访问python包，链接如下：<a href="https://github.com/longxiaofei/spider-BaiduIndex。">https://github.com/longxiaofei/spider-BaiduIndex。</a></p><p>爬虫需要获取百度指数网站cookie，在百度指数官网打开开发者模式即可取得。<br>&emsp;&emsp;爬虫核心函数代码如下，程序链接会在文末贴出。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取百度指数的函数  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_baidu_index</span>(<span class="params">keywords_list: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]], citycode, cookiesQueue</span>):  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># cookie  </span></span><br><span class="line">    cookies = cookiesQueue.queue[<span class="number">0</span>]  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 当前请求的五个关键词  </span></span><br><span class="line">    requested_keywords = []  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 一组（五个）关键词为元素的队列  </span></span><br><span class="line">    q_keywords = queue.Queue(-<span class="number">1</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 将keywordlist分组后置入队列q_keywords  </span></span><br><span class="line">    <span class="keyword">for</span> splited_keywords_list <span class="keyword">in</span> split_keywords(keywords_list):  </span><br><span class="line">        q_keywords.put(splited_keywords_list)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 当次请求的城市名称  </span></span><br><span class="line">    cityname = <span class="built_in">str</span>(CITY_MAP[<span class="built_in">str</span>(citycode)])  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始请求&quot;</span>+<span class="built_in">str</span>(CITY_MAP[<span class="built_in">str</span>(citycode)])+<span class="string">&quot;的百度指数&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 遍历q_keywords，每一组q_keywords请求一次  </span></span><br><span class="line">    <span class="comment"># 获得的数据输入data  </span></span><br><span class="line">    datas = []  </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> q_keywords.empty():  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 取出一组  </span></span><br><span class="line">        cur_keywords_list = q_keywords.get()  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 增加容错率：若错误，则换cookie重试  </span></span><br><span class="line">        <span class="comment"># 当前尝试次数  </span></span><br><span class="line">        attempts = <span class="number">0</span>  </span><br><span class="line">        <span class="comment"># 最大尝试次数  </span></span><br><span class="line">        max_attempts = <span class="number">3</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">while</span> attempts &lt; max_attempts:  </span><br><span class="line">            <span class="keyword">try</span>:  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;开始请求: <span class="subst">&#123;cur_keywords_list&#125;</span>&quot;</span>)  </span><br><span class="line">                <span class="comment"># 这一组获得的data  </span></span><br><span class="line">                current_data = []  </span><br><span class="line">                <span class="keyword">for</span> index <span class="keyword">in</span> get_search_index(  </span><br><span class="line">                        keywords_list=cur_keywords_list,  </span><br><span class="line">                        start_date=STARTTIME,  </span><br><span class="line">                        end_date=ENDTIME,  </span><br><span class="line">                        cookies=cookies,  </span><br><span class="line">                        area=citycode  </span><br><span class="line">                ):  </span><br><span class="line">                    index[<span class="string">&quot;keyword&quot;</span>] = <span class="string">&quot;,&quot;</span>.join(index[<span class="string">&quot;keyword&quot;</span>])  </span><br><span class="line">                    <span class="comment"># 将输出的index数据转化为list  </span></span><br><span class="line">                    index_list = [citycode, cityname, index[<span class="string">&#x27;keyword&#x27;</span>], index[<span class="string">&#x27;type&#x27;</span>], index[<span class="string">&#x27;date&#x27;</span>], index[<span class="string">&#x27;index&#x27;</span>]]  </span><br><span class="line">                    current_data.append(index_list)  </span><br><span class="line">                requested_keywords.extend(cur_keywords_list)  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;请求完成: <span class="subst">&#123;cur_keywords_list&#125;</span>&quot;</span>)  </span><br><span class="line">                datas.extend(current_data)  </span><br><span class="line">                time.sleep(<span class="number">0.2</span>)  </span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:  </span><br><span class="line">                traceback.print_exc()  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;请求出错, requested_keywords: <span class="subst">&#123;requested_keywords&#125;</span>，错误为<span class="subst">&#123;e&#125;</span>&quot;</span>)  </span><br><span class="line">                time.sleep(<span class="number">5</span>)  </span><br><span class="line">                cookies = cookiesQueue.get()  </span><br><span class="line">                attempts += <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> datas</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;本程序包含三个文件夹与一个主程序（.py），其中参考数据文件夹给出了百度指数对于中国355个城市给出的代码以及相应的城市名称，输出数据文件夹存储爬取的数据，而输入数据的文件夹包含存储百度cookies文本文件Allcookies，每行存放一个cookie，注意行末不要出现换行符。由于百度指数对于每个cookie访问的次数存在限制（几天后会刷新），因此对于关键词较多的爬取要求，建议多准备几个cookie。Ocity数据中存放城市代码与城市名称，Keyword中存放关键词（第一列存放排序数字）。总之，按示例数据填充即可。<br>代码链接如下：<br><a href="https://github.com/ATFfang/ATFfang.github.io/tree/main/2023/09/11/%E7%99%BE%E5%BA%A6%E6%8C%87%E6%95%B0%E7%88%AC%E5%8F%96%E2%80%94%E2%80%94%E4%B8%8D%E5%90%8C%E5%9F%8E%E5%B8%82%E5%AF%B9%E4%BA%8E%E5%90%84%E7%B1%BB%E5%85%B3%E9%94%AE%E8%AF%8D%E6%90%9C%E7%B4%A0%E9%87%8F%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/%E7%99%BE%E5%BA%A6%E7%88%AC%E8%99%ABV2">链接</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;程序设计需求：横向对比中国各城市对于各关键词百度搜索强度。&lt;br&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
  <entry>
    <title>python数据结构基础</title>
    <link href="https://atffang.github.io/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/"/>
    <id>https://atffang.github.io/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/</id>
    <published>2023-09-05T12:49:50.000Z</published>
    <updated>2023-09-13T07:04:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>2023-04-03日上传，2023-04-05日第三次更新。<br>报了个蓝桥杯的python赛道，却没怎么复习……稍微整理了一些数据结构（python实现）的知识点，赛前看一下。<br><span id="more"></span></p><p><strong>可以先看看第六章python基础</strong>（我记性太差了）</p><p>以下有的代码是书上抄的，有的代码是我自己写的，有的代码是gpt生成的，均为经过编译器编译，准确性未知，主要看个思路！</p><p>以及：如果网页版看的不爽，您可以点击下载<a href="https://raw.githubusercontent.com/ATFfang/publicWarehouse/main/python数据结构基础.md">markdown</a>（只是里面没有动图）。请注意：务必下载时，选择文件类型为全部文件，文件后缀改为.md（Chrome下载时显示的后缀确实是.md，但这是因为他把后面的.txt折叠了……麻烦删掉）</p><h3 id="1-基础数据结构"><a href="#1-基础数据结构" class="headerlink" title="1. 基础数据结构"></a>1. 基础数据结构</h3><h4 id="1-1-栈"><a href="#1-1-栈" class="headerlink" title="1.1 栈"></a>1.1 栈</h4><p>python栈实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__self</span>(<span class="params">self</span>):</span><br><span class="line">self.items=[]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.items==[]</span><br><span class="line"><span class="comment">#入栈</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self,item</span>):</span><br><span class="line">self.items.append(item)</span><br><span class="line"><span class="comment">#`pop()` 函数用于删除列表中指定索引位置（默认为最后一个元素）的元素</span></span><br><span class="line"><span class="comment">#出栈</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.items.pop();</span><br><span class="line"><span class="comment">#取值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.items[<span class="built_in">len</span>(items)-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(self.items)</span><br></pre></td></tr></table></figure><br>用途：匹配括号，将十进制转化为二进制，前序、中序、后序表达式以及其之间的转换。</p><h4 id="1-2-a-队列"><a href="#1-2-a-队列" class="headerlink" title="1.2 a.队列"></a>1.2 a.队列</h4><p>python队列的实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">self.items=[]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.items==[]</span><br><span class="line"><span class="comment">#入队</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enqueue</span>(<span class="params">self,item</span>):</span><br><span class="line"><span class="keyword">return</span> self.items.insert(<span class="number">0</span>,item)</span><br><span class="line"><span class="comment">#出队</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dequeue</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.items.pop();</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(self.items)</span><br></pre></td></tr></table></figure><br>队列的例子：模拟传土豆，模拟打印任务</p><h4 id="1-2-b-双端队列"><a href="#1-2-b-双端队列" class="headerlink" title="1.2 b.双端队列"></a>1.2 b.双端队列</h4><p>双端队列是与队列类似的有序集合。与队列不同的是，双端队列在哪一端添加元素都没有任何限制，移除也是同理。<br>双端队列的实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Deque</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">self.items=[]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.items==[]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addFront</span>(<span class="params">self,item</span>):</span><br><span class="line">self.items.append(item)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addRear</span>(<span class="params">self,item</span>):</span><br><span class="line">self.items.insert(<span class="number">0</span>,item)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">removeFront</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.items.pop()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">removeRear</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.items.pop(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(self.items)</span><br></pre></td></tr></table></figure><br>双端队列的应用：回文检测器<br>回文检测器：将字符串逐字符加入双端队列，依次进行前后端出队，当前端出队元素和后端出队元素相等时再继续。</p><h4 id="1-3-列表"><a href="#1-3-列表" class="headerlink" title="1.3 列表"></a>1.3 列表</h4><h5 id="1-3-1无序列表：链表"><a href="#1-3-1无序列表：链表" class="headerlink" title="1.3.1无序列表：链表"></a>1.3.1无序列表：链表</h5><p>node节点是构建链表的基本数据结构。每一个节点至少保有：数据变量；指向下一个节点的应用。下面是一个node类：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,initdata</span>):</span><br><span class="line">self.data=initdata</span><br><span class="line">self.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getData</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.data</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getNext</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.<span class="built_in">next</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setData</span>(<span class="params">self,newdata</span>):</span><br><span class="line">self.data=newdata</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setNext</span>(<span class="params">self,newnext</span>):</span><br><span class="line">self.<span class="built_in">next</span>=newnext</span><br></pre></td></tr></table></figure></p><p>通过节点，可以构建无序列表类UnorderedList类<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnorderedList</span>:</span><br><span class="line"><span class="comment">#在初始化时，只需要一个head节点：</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">self.head=<span class="literal">None</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.head==<span class="literal">None</span></span><br><span class="line"><span class="comment">#在head前添加一个节点，并将这个节点设置为head，此时head不再为None，即链表不再为空</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self,item</span>):</span><br><span class="line">temp=Node(item)</span><br><span class="line">temp.setNext(self.head)</span><br><span class="line">self.head=temp</span><br><span class="line"><span class="comment">#通过遍历获取链表长度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">length</span>(<span class="params">self</span>):</span><br><span class="line">current=self.head</span><br><span class="line">cont=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(current!=<span class="literal">None</span>):</span><br><span class="line">cont+=<span class="number">1</span></span><br><span class="line">current=current.getNext()</span><br><span class="line"><span class="keyword">return</span> cont</span><br><span class="line"><span class="comment">#遍历寻找元素是否在链表内</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self,item</span>):</span><br><span class="line">current=self.head</span><br><span class="line">found=false</span><br><span class="line"><span class="keyword">while</span>(current!=<span class="literal">None</span> <span class="keyword">and</span> found==false):</span><br><span class="line"><span class="keyword">if</span>(current.data==item):</span><br><span class="line">found=true</span><br><span class="line"><span class="keyword">return</span> found</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">current=current.getNext()</span><br><span class="line"><span class="keyword">return</span> found</span><br><span class="line"><span class="comment">#通过遍历删除值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self,item</span>):</span><br><span class="line">current=self.head</span><br><span class="line">previous=<span class="literal">None</span></span><br><span class="line">found=<span class="literal">False</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> found:</span><br><span class="line"><span class="keyword">if</span> current.getData()==item:</span><br><span class="line">found=<span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">previous=current</span><br><span class="line">current=current.getNext()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> previous==<span class="literal">None</span>:</span><br><span class="line">self.head=current.getNext()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">previous.setNext(current.getNext())</span><br></pre></td></tr></table></figure></p><h5 id="1-3-2-有序列表"><a href="#1-3-2-有序列表" class="headerlink" title="1.3.2 有序列表"></a>1.3.2 有序列表</h5><p>有序列表中，元素的相对位置取决于他们的基本特征<br>有序列表的实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OrderedList</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">self.head=<span class="literal">None</span></span><br><span class="line"><span class="comment">#遍历，找到比插入值大的节点，插入到该节点的前面</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self,item</span>):</span><br><span class="line">current=self.head</span><br><span class="line">precious=<span class="literal">None</span></span><br><span class="line">stop=<span class="literal">False</span></span><br><span class="line"><span class="keyword">while</span> current!=<span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> stop:</span><br><span class="line"><span class="keyword">if</span> current.getData()&gt;item:</span><br><span class="line">stop=<span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">previous=current</span><br><span class="line">current=current.getNext()</span><br><span class="line">temp=Node(item)</span><br><span class="line"><span class="keyword">if</span>(previous=<span class="literal">None</span>):</span><br><span class="line">self.head=temp</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">temp.setNext(current)</span><br><span class="line">precious.setNext(temp)</span><br><span class="line"><span class="comment">#遍历，直到满足：1.找到了；2.遍历到的值已经大于要找的值，退出；</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self,item</span>):</span><br><span class="line">current=self.head</span><br><span class="line">found=<span class="literal">False</span></span><br><span class="line">stop=<span class="literal">False</span></span><br><span class="line"><span class="keyword">while</span> current!=<span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> found <span class="keyword">and</span> <span class="keyword">not</span> stop:</span><br><span class="line"><span class="keyword">if</span> current.getData()==item:</span><br><span class="line">found=<span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">if</span> current.getData()&gt;item:</span><br><span class="line">stop=<span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">current=current.getNext()</span><br><span class="line"><span class="keyword">return</span> found</span><br></pre></td></tr></table></figure></p><h3 id="2-递归"><a href="#2-递归" class="headerlink" title="2. 递归"></a>2. 递归</h3><h4 id="2-1-迷宫搜索"><a href="#2-1-迷宫搜索" class="headerlink" title="2.1 迷宫搜索"></a>2.1 迷宫搜索</h4><p>示例：迷宫搜索函数：<br>下列的实例代码中，接受三个参数：迷宫对象、起始行、起始列<br>PART_OF_PATH:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">searchForm</span>(<span class="params">maze,startRow,startColumn</span>):</span><br><span class="line">maze.updatePosition(startRow,startColumn)</span><br><span class="line"><span class="comment">#检查基本情况</span></span><br><span class="line"><span class="comment">#1.遇到墙</span></span><br><span class="line"><span class="keyword">if</span> (maze[startRow][startColumn]==OBSTACLE):</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="comment">#2.遇到已经走过的格子</span></span><br><span class="line"><span class="keyword">if</span> (maze[startRow][startColumn]==TRIED):</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="comment">#3.找到出口</span></span><br><span class="line"><span class="keyword">if</span> maze.isExit([startRow][startColumn]):</span><br><span class="line">maze.updatePosition(startRow,startColumn,PART_OF_PATH)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">maze.updatePosition(startRow,startColumn,TRIED)</span><br><span class="line"></span><br><span class="line"><span class="comment">#否则，依次尝试四个方向走动，对于or，只要有一个正确，后面的就不会执行</span></span><br><span class="line">found=searchFrom(maze,startRow-<span class="number">1</span>,startColumn)\</span><br><span class="line"><span class="keyword">or</span> searchFrom(maze,startRow+<span class="number">1</span>,startColumn)\</span><br><span class="line"><span class="keyword">or</span> searchFrom(maze,startRow,startColumn-<span class="number">1</span>)\</span><br><span class="line"><span class="keyword">or</span> searchFrom(maze,startRow,startColumn+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> found:</span><br><span class="line">maze.uodatePosition(startRow,startColumn,PART_OF_PATH)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">maze.uodatePosition(startRow,startColumn,DEAD_END)</span><br><span class="line"><span class="keyword">return</span> found</span><br></pre></td></tr></table></figure></p><h4 id="2-2-汉诺塔"><a href="#2-2-汉诺塔" class="headerlink" title="2.2 汉诺塔"></a>2.2 汉诺塔</h4><p>其他示例：汉诺塔<br>汉诺塔是一种经典的递归问题，它的原理比较简单：有三根杆子，在其中一根杆子上按照大小顺序放置了若干个圆盘，现在需要把这些圆盘从一根杆子移动到另一根杆子上，移动过程中要保证较大的圆盘必须放在较小的圆盘下面，且每次只能移动一个圆盘。在汉诺塔问题中，我们通常称这三根杆子为 A、B、C 杆。</p><p>解决汉诺塔问题的常用方法是递归算法，具体的步骤如下：</p><ol><li>递归出口：当只有一个圆盘时，直接把它从 A 杆移到 C 杆上，即 return 1。</li><li>将 n-1 个圆盘从 A 杆移动到 B 杆上，使用 C 杆作为辅助杆。</li><li>将第 n 个圆盘从 A 杆移动到 C 杆上。</li><li>将 n-1 个圆盘从 B 杆移动到 C 杆上，使用 A 杆作为辅助杆。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hanoi</span>(<span class="params">n, A, B, C</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Move disk 1 from &#123;&#125; to &#123;&#125;&quot;</span>.<span class="built_in">format</span>(A, C))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        step1 = hanoi(n - <span class="number">1</span>, A, C, B)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Move disk &#123;&#125; from &#123;&#125; to &#123;&#125;&quot;</span>.<span class="built_in">format</span>(n, A, C))</span><br><span class="line">        step2 = hanoi(n - <span class="number">1</span>, B, A, C)</span><br><span class="line">        <span class="keyword">return</span> step1 + <span class="number">1</span> + step2</span><br></pre></td></tr></table></figure><h4 id="2-3-动态规划"><a href="#2-3-动态规划" class="headerlink" title="2.3 动态规划"></a>2.3 动态规划</h4><p>示例：动态规划找零问题：</p><ul><li>问题提出：硬币只有1美分，5美分，10美分和25美分，如何在消耗硬币最少的情况下，找零出37美分？</li><li>问题剖析：<br>  1.递归方法，即：<br>  若是每次找出x元的硬币，则剩余找零为（找零-x）元，每次利用函数numCoins寻找四种numCoins（找零-x）中的最小值，构建一颗子节点为4的递归树。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numCoins=<span class="built_in">min</span>(<span class="number">1</span>+numCoins(找零-<span class="number">1</span>),<span class="number">1</span>+numCoins(找零-<span class="number">5</span>),<span class="number">1</span>+numCoins(找零-<span class="number">10</span>),<span class="number">1</span>+numCoins(找零-<span class="number">25</span>))</span><br></pre></td></tr></table></figure><ol><li>动态规划方法，即：<br>每个金额的找零方式都由该金额-i的找零方式所决定，其中，i为硬币面值。<br>譬如，当我们需要知道15分怎么找时，可以求以下方式的最小值：</li></ol><ul><li>一枚一分的硬币+14分所需的最少的硬币（1+6）</li><li>一枚5分的硬币+10分所需的最少的硬币（1+1）</li><li>一枚10分的硬币+5分所需最少的硬币（1+1）</li></ul><p>因此，我们从0开始，指导要解的找零值，求出这之间所有值的最小硬币构成。<br>下面为动态规划的实现，其中，coinValueList为硬币的面值列表，change表示找零金额，minCoins表示从0到change的所有最优解，coinsUsed存储用于找零的硬币。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dpMakeChange</span>(<span class="params">coinValueList,change,minCoins,coinsUsed</span>):</span><br><span class="line"><span class="comment">#从0遍历到change（python左闭右开！）</span></span><br><span class="line"><span class="keyword">for</span> cents <span class="keyword">in</span> <span class="built_in">range</span>(change+<span class="number">1</span>):</span><br><span class="line"><span class="comment">#所用的硬币数</span></span><br><span class="line">coinCount=cents</span><br><span class="line"><span class="comment">#记录使用的硬币的面额</span></span><br><span class="line">newCoin=<span class="number">1</span></span><br><span class="line"><span class="comment">#遍历所有小于找零值的硬币</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> [c <span class="keyword">for</span> c <span class="keyword">in</span> coinValueList of c&lt;cents]:</span><br><span class="line"><span class="comment">#如果cents-面额j的最小硬币数+1小于之前求得的硬币数，则替换</span></span><br><span class="line"><span class="keyword">if</span> minCoins[cents-j]+<span class="number">1</span>&lt;coinCount:</span><br><span class="line">CoinCount=minCoins[cents-j]+<span class="number">1</span></span><br><span class="line">newCoin=j</span><br><span class="line"><span class="comment">#记载入最优解列表中</span></span><br><span class="line">minCoins[cents]=contCount</span><br><span class="line"><span class="comment">#记载入使用过的硬币列表中</span></span><br><span class="line">coinUsed[cents]=newCoin</span><br><span class="line"><span class="keyword">return</span> minCoins[change]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printCoins</span>(<span class="params">coinsUsed,change</span>):</span><br><span class="line">coin=change</span><br><span class="line"><span class="keyword">while</span> coin&gt;<span class="number">0</span>:</span><br><span class="line">thisCoin=coinsUsed[coin]</span><br><span class="line"><span class="built_in">print</span>(thisCoin)</span><br><span class="line">coin=coin-thisCoin</span><br></pre></td></tr></table></figure></p><p>下面详细介绍一下动态规划：<br><strong>动态规划</strong>（Dynamic Programming，简称DP）是一种将复杂问题分解成更小的子问题来解决的优化技术，常用于解决最优化问题。它在求解具有重叠子问题和最优子结构的问题中特别有效。</p><p>动态规划的基本思想是将原问题分解成若干个子问题，先求解子问题的最优解，然后通过子问题的最优解得到原问题的最优解。具体来说，动态规划的思路包括以下几个步骤：<br>（1）划分：按照问题的特征，把问题分为若干阶段。注意：划分后的阶段一定是有序的或者可排序的<br>（2）确定状态和状态变量：将问题发展到各个阶段时所处的各种不同的客观情况表现出来。状态的选择要满足无后续性<br>（3）确定决策并写出状态转移方程：状态转移就是根据上一阶段的决策和状态来导出本阶段的状态。根据相邻两个阶段状态之间的联系来确定决策方法和状态转移方程<br>（4）边界条件：状态转移方程是一个递推式，因此需要找到递推终止的条件</p><p>整个求解过程可以用一张最优决策表来描述，最优决策表是一张二维表（行：决策阶段，列：问题的状态）表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</p><p>例如：f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)}</p><p>下面是一些问题实例，有助于理解动态规划：</p><h5 id="2-3-1-背包问题"><a href="#2-3-1-背包问题" class="headerlink" title="2.3.1 背包问题"></a>2.3.1 背包问题</h5><p>对于初学者来说，理解背包问题并不容易，可以先看这个<a href="https://www.bilibili.com/video/BV1g7411B7SP/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=717d4feb094126b2033be27866e18150">视频</a>，里面有十分详细的讲解。<br>背包问题是一类经典的优化问题，通常指在给定容量的背包中，如何选择最有价值的物品，使得背包中物品的总价值最大。<br>具体来说，背包问题有两种形式：0/1背包和完全背包。<br>0/1背包问题中，物品不可分割，每个物品只有一个，选择放入或不放入，不能将物品分成若干部分装入背包。<br>完全背包问题中，每个物品可以选择放入多次，即物品是可分割的。</p><p>对于这两种问题，一般可以用动态规划的思想进行求解。设背包容量为V，有n个物品，第i个物品的体积为v[i]，价值为w[i]。定义f(i,j)表示在前i个物品中选择不超过j容量的物品的最大价值，则有：</p><ol><li>对于0/1背包问题：<br>f(i,j) = max{f(i-1,j), f(i-1,j-v[i])+w[i]}, j &gt;= v[i]<br>f(i,j) = f(i-1,j), j &lt; v[i]<br>即：当第i件物品可以加入背包时，可以选择加入或者不加入。如果加入，则总价值为：f(i-1,j)，若不加入，则总价值为：第i件物品的价值+当前容量（总容量-第i件物品的重量）能够存放的最大价值f(i,j) = max{f(i-1,j), f(i-1,j-v[i])+w[i]}, j &gt;= v[i]</li></ol><p>python实现的代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">knapsack</span>(<span class="params">capacity, weights, values, n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    0/1背包问题的解法</span></span><br><span class="line"><span class="string">    :param capacity: 背包的容量</span></span><br><span class="line"><span class="string">    :param weights: 每个物品的重量列表</span></span><br><span class="line"><span class="string">    :param values: 每个物品的价值列表</span></span><br><span class="line"><span class="string">    :param n: 物品数量</span></span><br><span class="line"><span class="string">    :return: 最大价值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 初始化二维数组f，用于存储状态转移方程的结果</span></span><br><span class="line">    f = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(capacity + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, capacity + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 如果当前物品的体积小于等于背包容量，则可以选择装入或者不装入</span></span><br><span class="line">            <span class="keyword">if</span> weights[i-<span class="number">1</span>] &lt;= j:</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i-<span class="number">1</span>][j], f[i-<span class="number">1</span>][j-weights[i-<span class="number">1</span>]]+values[i-<span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 否则只能不装入</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                f[i][j] = f[i-<span class="number">1</span>][j]</span><br><span class="line">    <span class="keyword">return</span> f[n][capacity]</span><br></pre></td></tr></table></figure></p><h5 id="2-3-2-台阶问题"><a href="#2-3-2-台阶问题" class="headerlink" title="2.3.2 台阶问题"></a>2.3.2 台阶问题</h5><p>有n级台阶，一个人每次上一级或者两级，问有多少种走完n级台阶的方法。</p><p>分析：动态规划的实现的关键在于能不能准确合理的用动态规划表来抽象出 实际问题。在这个问题上，我们让f(n)表示走上n级台阶的方法数。</p><p>那么当n为1时，f(n) = 1,n为2时，f(n) =2,就是说当台阶只有一级的时候，方法数是一种，台阶有两级的时候，方法数为2。那么当我们要走上n级台阶，必然是从n-1级台阶迈一步或者是从n-2级台阶迈两步，所以到达n级台阶的方法数必然是到达n-1级台阶的方法数加上到达n-2级台阶的方法数之和。即f(n) = f(n-1)+f(n-2)，我们用dp[n]来表示动态规划表，dp[i],i&gt;0,i&lt;=n,表示到达i级台阶的方法数。</p><p>下面是一个python实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param n: an integer</span></span><br><span class="line"><span class="string">    @return: an ineger f(n)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">up</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="comment"># if n == 0:</span></span><br><span class="line">        <span class="comment">#     return 0</span></span><br><span class="line">        L = []</span><br><span class="line">        L.append(<span class="number">1</span>)</span><br><span class="line">        L.append(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">            L.append(L[i - <span class="number">1</span>] + L[i - <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> L[n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><h3 id="3-搜索与排序"><a href="#3-搜索与排序" class="headerlink" title="3. 搜索与排序"></a>3. 搜索与排序</h3><h4 id="3-1-搜索"><a href="#3-1-搜索" class="headerlink" title="3.1 搜索"></a>3.1 搜索</h4><p>Python提供了in，通过它可以方便的检查元素是否在列表中：<br><code>15 in [1,2,3,4,15]</code></p><h5 id="3-1-1-顺序搜索"><a href="#3-1-1-顺序搜索" class="headerlink" title="3.1.1 顺序搜索"></a>3.1.1 顺序搜索</h5><p>这个就不讲了，大猩猩都会</p><h5 id="3-1-2-二分搜索"><a href="#3-1-2-二分搜索" class="headerlink" title="3.1.2 二分搜索"></a>3.1.2 二分搜索</h5><p>目标值比中间元素小，则在左半部分继续查找；否则，在右半部分继续查找。重复以上过程，直到找到目标值或者确定目标值不存在为止。<br>二分搜索算法的时间复杂度为 O(log n)，其中 n 表示数组中元素的个数，因此它比线性搜索算法的时间复杂度 O(n) 更快，特别是对于大规模的数据集。<br>显然，二分搜索可以使用递归实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_helper</span>(<span class="params">arr, target, left, right</span>): </span><br><span class="line"><span class="keyword">if</span> left &gt; right: </span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span> </span><br><span class="line">mid = (left + right) // <span class="number">2</span> </span><br><span class="line"><span class="keyword">if</span> arr[mid] == target: </span><br><span class="line"><span class="keyword">return</span> mid </span><br><span class="line"><span class="keyword">elif</span> arr[mid] &lt; target: </span><br><span class="line"><span class="keyword">return</span> binary_search_helper(arr, target, mid + <span class="number">1</span>, right) </span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line"><span class="keyword">return</span> binary_search_helper(arr, target, left, mid - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><h5 id="3-1-3-散列"><a href="#3-1-3-散列" class="headerlink" title="3.1.3 散列"></a>3.1.3 散列</h5><p>（这里我不想写了，下面都是gpt写的）<br>散列（Hashing）是一种用于快速查找的数据结构，它能够在 O(1) 的时间复杂度内完成查找操作。散列使用散列函数将键映射到存储位置，每个存储位置称为散列表中的一个桶。当需要查找一个键时，可以使用散列函数计算出该键对应的桶的位置，并在该桶中查找是否存在对应的值。</p><p>散列函数是散列表的关键，它将键映射到桶的位置。一个好的散列函数应该具有以下特点：</p><ol><li>散列函数应该能够将不同的键映射到不同的桶，避免不同键的哈希冲突。</li><li>散列函数应该尽可能地将键均匀地分布在桶中，避免出现某些桶过载的情况。</li><li>散列函数的计算速度应该足够快，否则会影响散列表的性能。</li></ol><p>散列函数可以使用不同的算法来实现，包括简单的取余法、乘法散列法、多项式散列法、MD5 散列等。</p><p>在实际应用中，散列可以用于解决大量数据的查找问题，例如在数据库中查找记录、在哈希表中查找键值对等。但是，散列也有一些缺点，例如：</p><ol><li>散列函数可能出现哈希冲突，即不同的键映射到了同一个桶中，需要使用冲突解决策略来解决。</li><li>散列表的性能取决于散列函数的质量和散列表的装载因子，当装载因子过高时，会影响散列表的性能。</li><li>散列表的大小通常是固定的，不能动态扩展，如果散列表的大小不够，需要重新创建一个更大的散列表来解决。</li></ol><p>下面是一个示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, size</span>):</span><br><span class="line">        self.size = size</span><br><span class="line">        self.table = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash_func</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(key) % self.size</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        index = self.hash_func(key)</span><br><span class="line">        self.table[index].append((key, value))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, key</span>):</span><br><span class="line">        index = self.hash_func(key)</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> self.table[index]:</span><br><span class="line">            <span class="keyword">if</span> k == key:</span><br><span class="line">                <span class="keyword">return</span> v</span><br><span class="line">        <span class="keyword">raise</span> KeyError(key)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, key</span>):</span><br><span class="line">        index = self.hash_func(key)</span><br><span class="line">        <span class="keyword">for</span> i, (k, v) <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.table[index]):</span><br><span class="line">            <span class="keyword">if</span> k == key:</span><br><span class="line">                <span class="keyword">del</span> self.table[index][i]</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">raise</span> KeyError(key)</span><br></pre></td></tr></table></figure><br>以上是一个简单的散列表实现，使用 Python 列表作为散列表的存储结构，使用哈希函数将键映射到散列表中的索引位置。当插入一个键值对时，使用哈希函数计算键的索引位置，并将键值对添加到该位置对应的列表中。当查找或删除一个键值对时，同样使用哈希函数计算键的索引位置，并在该位置对应的列表中查找或删除键值对。</p><p>这里的哈希函数使用内置函数 hash，它可以将任意 Python 对象转换为整数，并且保证相同的对象具有相同的哈希值。但是，在实际应用中，可以根据具体的应用场景选择不同的哈希函数。</p><h4 id="3-2-排序"><a href="#3-2-排序" class="headerlink" title="3.2 排序"></a>3.2 排序</h4><p>python提供了内置的排序函数：<br><code>list.sort(*, key=None, reverse=False)</code>：该函数用于对列表进行原地排序，它接受 key 函数和 reverse 参数，如果 reverse 参数为 True，则按照降序排序。</p><h5 id="3-2-1-冒泡排序"><a href="#3-2-1-冒泡排序" class="headerlink" title="3.2.1 冒泡排序"></a>3.2.1 冒泡排序</h5><p>冒泡排序（Bubble Sort）是一种简单的排序算法，它重复地走访过要排序的数列，依次比较相邻的两个元素，如果它们的顺序错误就交换它们的位置，直到没有需要交换的元素为止。<br>这没啥要讲的了<br><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%86%92%E6%B3%A1.gif" class="" title="sucessful"></p><h5 id="3-2-2-选择排序"><a href="#3-2-2-选择排序" class="headerlink" title="3.2.2 选择排序"></a>3.2.2 选择排序</h5><p>选择排序（Selection Sort）是一种简单的排序算法，它的基本思想是找到最小元素并将其放置在数组的起始位置，然后继续找到剩余元素中的最小元素并放置在已排序序列的末尾，以此类推，直到所有元素都排好序为止。</p><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E9%80%89%E6%8B%A9.gif" class="" title="sucessful"><p>具体实现过程如下：</p><ol><li>遍历整个数组，找到其中最小的元素，并记录其位置。</li><li>将最小元素与数组的第一个元素进行交换。</li><li>排除已排序的第一个元素，对剩余元素执行步骤 1 和 2，直到所有元素都被排序。</li></ol><p>下面是一个代码示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">selection_sort</span>(<span class="params">lst</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(lst)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        min_idx = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> lst[j] &lt; lst[min_idx]:</span><br><span class="line">                min_idx = j</span><br><span class="line">        lst[i], lst[min_idx] = lst[min_idx], lst[i]</span><br><span class="line">    <span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure></p><h5 id="3-2-3-插入排序"><a href="#3-2-3-插入排序" class="headerlink" title="3.2.3 插入排序"></a>3.2.3 插入排序</h5><p>一个一个插入到已排序序列中的合适位置，最终完成排序。具体实现过程如下：</p><ol><li>遍历整个数组，将数组中的第一个元素视为已排序序列。</li><li>遍历未排序序列中的元素，将它插入到已排序序列中的合适位置，使得插入后的序列仍然有序。</li><li>重复步骤 2 直到所有元素都被插入到已排序序列中。</li></ol><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E6%8F%92%E5%85%A5.gif" class="" title="sucessful"><p>下面是一个代码示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">lst</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(lst)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        key = lst[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> lst[j] &gt; key:</span><br><span class="line">            lst[j + <span class="number">1</span>] = lst[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        lst[j + <span class="number">1</span>] = key</span><br><span class="line">    <span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure></p><h5 id="3-2-4-希尔排序"><a href="#3-2-4-希尔排序" class="headerlink" title="3.2.4 希尔排序"></a>3.2.4 希尔排序</h5><p>希尔排序（Shell Sort）是一种改进的插入排序算法，它是通过将整个序列分成若干个子序列来实现排序，每个子序列分别进行插入排序，最终完成整个序列的排序。</p><p>希尔排序的基本思想是将待排序序列按照一定的步长进行分组，对每组使用插入排序算法进行排序。然后将步长逐渐缩小，重复进行分组和排序，直到步长为 1。此时，序列已经被分成了若干个有序子序列，最后进行一次插入排序即可完成整个序列的排序。</p><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%B8%8C%E5%B0%94.gif" class="" title="sucessful"><p>下面是实现的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">shell_sort</span>(<span class="params">lst</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(lst)</span><br><span class="line">    gap = n // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap, n):</span><br><span class="line">            key = lst[i]</span><br><span class="line">            j = i - gap</span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> lst[j] &gt; key:</span><br><span class="line">                lst[j + gap] = lst[j]</span><br><span class="line">                j -= gap</span><br><span class="line">            lst[j + gap] = key</span><br><span class="line">        gap //= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure><br>其中，参数 lst 是一个待排序的列表，函数返回一个新的已排序的列表。函数首先将整个序列分成若干个子序列，对每个子序列使用插入排序算法进行排序。然后将步长 gap 逐渐缩小，重复进行分组和排序，直到步长为 1。在每个子序列中，将当前元素存储为关键字 key，并将它与已排序序列中的元素进行比较，找到合适的位置并插入，直到所有元素都被插入到已排序序列中为止。</p><h5 id="3-2-5-归并排序"><a href="#3-2-5-归并排序" class="headerlink" title="3.2.5 归并排序"></a>3.2.5 归并排序</h5><p>归并排序（Merge Sort）是一种稳定的排序算法，它采用分治思想将待排序序列分成若干个子序列，每个子序列都是有序的，然后再将这些有序的子序列合并成一个有序序列。</p><p>归并排序的基本思想是将待排序序列不断地对半分割，直到每个子序列只有一个元素，然后将相邻的子序列进行合并，形成新的有序子序列，直到最终只剩下一个有序序列为止。合并操作时，需要额外的一个数组来存储已经排序好的元素，最后再将排序好的元素复制回原数组。</p><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%BD%92%E5%B9%B6.gif" class="" title="sucessful"><p>以下是使用 Python 实现的归并排序代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">lst</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(lst) &gt; <span class="number">1</span>:</span><br><span class="line">        mid = <span class="built_in">len</span>(lst) // <span class="number">2</span></span><br><span class="line">        left_half = lst[:mid]</span><br><span class="line">        right_half = lst[mid:]</span><br><span class="line"></span><br><span class="line">        merge_sort(left_half)</span><br><span class="line">        merge_sort(right_half)</span><br><span class="line"></span><br><span class="line">        i = j = k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left_half) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right_half):</span><br><span class="line">            <span class="keyword">if</span> left_half[i] &lt; right_half[j]:</span><br><span class="line">                lst[k] = left_half[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lst[k] = right_half[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left_half):</span><br><span class="line">            lst[k] = left_half[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(right_half):</span><br><span class="line">            lst[k] = right_half[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure><br>其中，参数 lst 是一个待排序的列表，函数返回一个新的已排序的列表。函数首先将待排序序列不断地对半分割，直到每个子序列只有一个元素，然后将相邻的子序列进行合并，形成新的有序子序列，直到最终只剩下一个有序序列为止。在合并操作中，需要额外的一个数组来存储已经排序好的元素，最后再将排序好的元素复制回原数组。</p><h5 id="3-2-6-快速排序"><a href="#3-2-6-快速排序" class="headerlink" title="3.2.6 快速排序"></a>3.2.6 快速排序</h5><p>快速排序（Quick Sort）是一种常见的排序算法，它采用分治思想将待排序序列分成两个子序列，一部分小于基准元素，一部分大于基准元素。然后对这两个子序列分别进行递归排序，最终得到一个有序序列。</p><p>快速排序的基本思想是选定一个基准元素，然后通过一趟排序将待排序序列分成两部分，使得左边的子序列都小于基准元素，右边的子序列都大于基准元素，然后分别对左右两部分递归地进行快速排序，最终得到一个有序序列。</p><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%BF%AB%E9%80%9F.gif" class="" title="sucessful"><p>以下是使用 Python 实现的快速排序代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">lst, left, right</span>):</span><br><span class="line">    <span class="keyword">if</span> left &lt; right:</span><br><span class="line">        pivot_index = partition(lst, left, right)</span><br><span class="line">        quick_sort(lst, left, pivot_index - <span class="number">1</span>)</span><br><span class="line">        quick_sort(lst, pivot_index + <span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">lst, left, right</span>):</span><br><span class="line">    pivot = lst[left]</span><br><span class="line">    i, j = left + <span class="number">1</span>, right</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">while</span> i &lt;= j <span class="keyword">and</span> lst[i] &lt; pivot:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j <span class="keyword">and</span> lst[j] &gt;= pivot:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &lt;= j:</span><br><span class="line">            lst[i], lst[j] = lst[j], lst[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    lst[left], lst[j] = lst[j], lst[left]</span><br><span class="line">    <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure><br>其中，参数 lst 是一个待排序的列表，参数 left 和 right 是列表的左右边界，函数使用递归的方式实现快速排序。在递归的过程中，首先选定一个基准元素，然后通过 partition 函数将待排序序列分成两部分。partition 函数使用双指针的方式将待排序序列分成两部分，左边部分的元素都小于基准元素，右边部分的元素都大于等于基准元素。最后，将基准元素放在分界点上，返回分界点的位置。然后分别对左右两部分递归地进行快速排序，最终得到一个有序序列。</p><h3 id="4-树"><a href="#4-树" class="headerlink" title="4. 树"></a>4. 树</h3><p>不多介绍，直接看实现与算法</p><h4 id="4-1-树的实现"><a href="#4-1-树的实现" class="headerlink" title="4.1 树的实现"></a>4.1 树的实现</h4><h5 id="4-1-1-实现方法1：列表之列表"><a href="#4-1-1-实现方法1：列表之列表" class="headerlink" title="4.1.1 实现方法1：列表之列表"></a>4.1.1 实现方法1：列表之列表</h5><p>例如，a为根节点，有子节点b，c，节点b又有子节点d（左），则使用列表：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a,[b,[d,[],[]],[]],[c,[],[]]]</span><br></pre></td></tr></table></figure><br>不说了，这方法真的会有人用吗</p><h5 id="4-1-2-实现方法2：节点与引用"><a href="#4-1-2-实现方法2：节点与引用" class="headerlink" title="4.1.2 实现方法2：节点与引用"></a>4.1.2 实现方法2：节点与引用</h5><p>基础类：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,rootObj</span>):</span><br><span class="line">self.key=rootObj</span><br><span class="line">self.leftChild=<span class="literal">None</span></span><br><span class="line">self.rightChild=<span class="literal">None</span></span><br></pre></td></tr></table></figure><br>插入左节点（如果已经存在左子节点，插入时要把原先的左子节点降一层，自己到那个位置）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">instertLeft</span>(<span class="params">self,newNode</span>):</span><br><span class="line"><span class="keyword">if</span>(self.leftChild==<span class="literal">None</span>):</span><br><span class="line">self.leftChild=BinaryTree(newNode)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">t=BinaryTree(newNode)</span><br><span class="line">t.leftChild=self.leftChild</span><br><span class="line">self.leftChild=t</span><br></pre></td></tr></table></figure><br>右子节点也一样。<br>访问函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getRightChild</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.rightChild</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getLeftChild</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.LeftChild</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setRootVal</span>(<span class="params">self,obj</span>):</span><br><span class="line">self.key=obj</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getRootVal</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.key</span><br></pre></td></tr></table></figure></p><h4 id="4-2-树的遍历"><a href="#4-2-树的遍历" class="headerlink" title="4.2 树的遍历"></a>4.2 树的遍历</h4><p>树的遍历方式分为三种：前序遍历、中序遍历、后序遍历</p><h5 id="4-2-1-前序遍历"><a href="#4-2-1-前序遍历" class="headerlink" title="4.2.1 前序遍历"></a>4.2.1 前序遍历</h5><p>先访问根节点，然后递归地前序遍历左子树，最后递归地前序遍历右子树<br><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%89%8D%E5%BA%8F.gif" class="" title="sucessful"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">tree</span>):</span><br><span class="line"><span class="keyword">if</span> tree:</span><br><span class="line"><span class="built_in">print</span>(tree.getRootVal())</span><br><span class="line">preorder(tree.getLeftChild())</span><br><span class="line">preorder(tree.getRightChild())</span><br></pre></td></tr></table></figure></p><h5 id="4-2-2-中序遍历"><a href="#4-2-2-中序遍历" class="headerlink" title="4.2.2 中序遍历"></a>4.2.2 中序遍历</h5><p>先递归地中序遍历左子树，然后访问根节点，在中序遍历右子树<br><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E4%B8%AD%E5%BA%8F.gif" class="" title="sucessful"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">tree</span>):</span><br><span class="line"><span class="keyword">if</span> tree:</span><br><span class="line">inorder(tree.getLeftChild())</span><br><span class="line"><span class="built_in">print</span>(tree.getRootVal())</span><br><span class="line">inorder(tree.getRightChild())</span><br></pre></td></tr></table></figure></p><h5 id="4-2-3-后序遍历"><a href="#4-2-3-后序遍历" class="headerlink" title="4.2.3 后序遍历"></a>4.2.3 后序遍历</h5><p>先递归地后序遍历右子树，然后递归地后序遍历左子树，最后访问根节点<br><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%90%8E%E5%BA%8F.gif" class="" title="sucessful"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">postorder</span>(<span class="params">tree</span>):</span><br><span class="line"><span class="keyword">if</span> tree:</span><br><span class="line">postorder(tree.getLeftChild())</span><br><span class="line">postorder(tree.getRightChild())</span><br><span class="line"><span class="built_in">print</span>(tree.getRootVal())</span><br></pre></td></tr></table></figure></p><h4 id="4-3-利用二叉堆实现优先级队列"><a href="#4-3-利用二叉堆实现优先级队列" class="headerlink" title="4.3 利用二叉堆实现优先级队列"></a>4.3 利用二叉堆实现优先级队列</h4><p>二叉堆（binary heap）是一种特殊的二叉树数据结构，它可以用数组来实现，并且常用于实现优先队列。</p><p>二叉堆分为最大堆和最小堆两种类型。最大堆满足任何一个父节点的键值大于等于它的任何一个子节点的键值；最小堆则满足任何一个父节点的键值小于等于它的任何一个子节点的键值。因此，最大堆的堆顶是堆中的最大元素，最小堆的堆顶是堆中的最小元素。</p><p>二叉堆的数组实现中，数组的第一个元素是根节点，数组的下标从1开始（而不是0）。对于第i个节点，它的左子节点在2i的位置，右子节点在2i+1的位置，父节点在i/2的位置（向下取整）。</p><p>二叉堆的主要操作包括插入一个元素、删除堆顶元素和查找堆顶元素。插入一个元素需要将元素插入到堆的最后一个位置，然后通过向上逐级比较交换，将新元素移动到合适的位置以维护堆的性质。删除堆顶元素需要将堆顶元素与堆中最后一个元素交换位置，然后删除最后一个元素，并通过向下逐级比较交换，将堆顶元素移动到合适的位置以维护堆的性质。查找堆顶元素只需要返回数组的第一个元素。</p><h5 id="4-3-1-二叉堆的实现"><a href="#4-3-1-二叉堆的实现" class="headerlink" title="4.3.1 二叉堆的实现"></a>4.3.1 二叉堆的实现</h5><p>在实现二叉堆时，我们通过创建一颗完全二叉树来维持树的平衡。在完全二叉树中，除了最底层，其他每一层的节点都是满的。在对底层，从左往右填充节点。</p><p>完全二叉树的特殊之处在于，可以用一个列表来表示它。<br>完全二叉树节点在列表中的排序为：从上而下，从左往右。<br>按此排布，对于在列表中位置p的节点来说，其左子节点的位置为2p，右子节点的位置为2p+1（请读者自行推算一遍）</p><p>二叉堆的实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">self.heapList=[<span class="number">0</span>]</span><br><span class="line">self.currentSize=<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>对于一个要求子节点大于父节点的堆来说，插入的最简单、最高效的方法就是将元素追加到列表的末尾，然后和其父节点比较，若小于其父节点，就对换位置。此处代码不再给出，简单来说就是比较插入的第i个和父节点第i//2个对比。</p><p>二叉堆还有一个功能，删除最小元素（即根节点），但是删除后，需要对堆进行重建。重建方法为：</p><ol><li>取出列表中最后一个元素，将其放在根节点的位置</li><li>通过与子节点之间的交换，将新的根节点沿着树推到正确的位置</li></ol><h4 id="4-4-二叉搜索树"><a href="#4-4-二叉搜索树" class="headerlink" title="4.4 二叉搜索树"></a>4.4 二叉搜索树</h4><p>二叉搜索树依赖于这样的性质：小于父节点的键都在左子树中，大于父节点的键则都在右子树中。</p><h5 id="4-4-1-插入"><a href="#4-4-1-插入" class="headerlink" title="4.4.1 插入"></a>4.4.1 插入</h5><p>根据性质，插入算法为：</p><ol><li>从根节点开始搜索二叉树，比较新键与当前节点的键，如果新键更小，搜索左子树，如果新键更大，搜索右子树</li><li>当没有可供搜索的左/右字节点时，说明找到了正确的位置。</li><li>创建一个TreeNode对象，并将其插入到前一步发现的位置上。</li></ol><p>下面是一个利用递归方法实现的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.root:</span><br><span class="line">            self.root = Node(val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._insert(val, self.root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_insert</span>(<span class="params">self, val, node</span>):</span><br><span class="line">        <span class="keyword">if</span> val &lt; node.val:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left:</span><br><span class="line">                node.left = Node(val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self._insert(val, node.left)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                node.right = Node(val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self._insert(val, node.right)</span><br></pre></td></tr></table></figure></p><h5 id="4-4-2-查找"><a href="#4-4-2-查找" class="headerlink" title="4.4.2 查找"></a>4.4.2 查找</h5><p>相似的，查找的方法为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, val</span>):</span><br><span class="line">    node = self.root</span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        <span class="keyword">if</span> node.val == val:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        <span class="keyword">elif</span> val &lt; node.val:</span><br><span class="line">            node = node.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = node.right</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure></p><h5 id="4-4-3-删除"><a href="#4-4-3-删除" class="headerlink" title="4.4.3 删除"></a>4.4.3 删除</h5><p>删除的情况就相对复杂。</p><ol><li>要删除的节点是叶子节点，也就是没有左右子节点的节点。在这种情况下，可以直接删除该节点，将其父节点的左子节点或右子节点指向 None。</li><li>要删除的节点只有一个子节点，可以将该节点的子节点替换为该节点。</li><li>要删除的节点有两个子节点。在这种情况下，可以将该节点的左子树的最大节点或右子树的最小节点替换该节点。（因为左子树的最大节点或右子树的最小节点正好可以填进去）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span>:</span><br><span class="line">    <span class="comment"># 省略插入方法和查找方法...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, val</span>):</span><br><span class="line">        node, parent = self.search_with_parent(val)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 未找到要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">or</span> <span class="keyword">not</span> node.right:  <span class="comment"># 第一种和第二种情况</span></span><br><span class="line">            child = node.left <span class="keyword">or</span> node.right</span><br><span class="line">            <span class="keyword">if</span> parent:</span><br><span class="line">                <span class="keyword">if</span> node == parent.left:</span><br><span class="line">                    parent.left = child</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    parent.right = child</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.root = child</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 第三种情况</span></span><br><span class="line">            succ = node.right</span><br><span class="line">            <span class="keyword">while</span> succ.left:</span><br><span class="line">                succ = succ.left</span><br><span class="line">            node.val = succ.val</span><br><span class="line">            <span class="keyword">if</span> succ == node.right:</span><br><span class="line">                node.right = succ.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = self.search_with_parent(succ.val)[<span class="number">1</span>]</span><br><span class="line">                p.left = succ.right</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="4-5-平衡二叉搜索树"><a href="#4-5-平衡二叉搜索树" class="headerlink" title="4.5 平衡二叉搜索树"></a>4.5 平衡二叉搜索树</h4><p>这个真太烦了，我不高兴看了T.T</p><h4 id="4-6-霍夫曼树"><a href="#4-6-霍夫曼树" class="headerlink" title="4.6 霍夫曼树"></a>4.6 霍夫曼树</h4><p>霍夫曼树（Huffman Tree）是一种带权路径最短的树，通常用于数据压缩。它的构建过程基于贪心算法，根据数据频率构建一棵无损压缩的树。具体来说，给定一组数据和对应的权值，霍夫曼树的构建过程如下：</p><ol><li>对所有的数据按照权值从小到大排序，每个数据作为一个单独的节点。</li><li>每次从排序后的节点中选取权值最小的两个节点，将它们合并为一个新节点，新节点的权值为两个节点的权值之和，左子节点为权值较小的节点，右子节点为权值较大的节点。</li><li>将新节点插入到排序后的节点列表中，并删除原来的两个节点。</li><li>重复步骤2和3，直到只剩下一个节点为止，该节点即为霍夫曼树的根节点。</li></ol><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%93%88%E5%A4%AB%E6%9B%BC.gif" class="" title="sucessful style&#x3D;display: block; margin: 0 auto; max-width: 50%;"><p>下面是一个Python实现示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HuffmanNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value, weight</span>):</span><br><span class="line">        self.value = value</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_huffman_tree</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="comment"># 构建叶子节点列表</span></span><br><span class="line">    nodes = [HuffmanNode(val, weight) <span class="keyword">for</span> val, weight <span class="keyword">in</span> data]</span><br><span class="line">    <span class="comment"># 构建霍夫曼树</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(nodes) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># 按权值排序</span></span><br><span class="line">        nodes.sort(key=<span class="keyword">lambda</span> node: node.weight)</span><br><span class="line">        <span class="comment"># 取出权值最小的两个节点</span></span><br><span class="line">        left_node = nodes.pop(<span class="number">0</span>)</span><br><span class="line">        right_node = nodes.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 构建新节点</span></span><br><span class="line">        new_weight = left_node.weight + right_node.weight</span><br><span class="line">        new_node = HuffmanNode(<span class="literal">None</span>, new_weight)</span><br><span class="line">        new_node.left = left_node</span><br><span class="line">        new_node.right = right_node</span><br><span class="line">        <span class="comment"># 将新节点加入节点列表中</span></span><br><span class="line">        nodes.append(new_node)</span><br><span class="line">    <span class="comment"># 返回根节点</span></span><br><span class="line">    <span class="keyword">return</span> nodes[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p><p>在这个实现中，我们先定义了一个<code>HuffmanNode</code>类，表示霍夫曼树中的节点。每个节点包含一个<code>value</code>属性表示节点的值（如果节点是叶子节点，则为原始数据），一个<code>weight</code>属性表示节点的权值，以及左子节点和右子节点。我们还定义了一个<code>build_huffman_tree(data)</code>函数，用于构建霍夫曼树。<code>data</code>参数是一个二元组列表，每个二元组包含一个数据和对应的权值。函数返回霍夫曼树的根节点。</p><p>在构建完霍夫曼树后，我们可以通过对树进行遍历来获得每个数据的编码。具体来说，我们可以对树进行先序遍历，在遍历过程中，记录每个叶子节点的编码（0表示向左走，1表示向右走）。最终得到的编码就是霍夫曼编码，可以用于数据压缩。</p><p>例如，如果一个数据出现的频率很高，代表着他权值很高，我们可以用一个比较短的编码来表示它，比如说用一个1位的编码表示它。而如果一个数据出现的频率很低，我们可以用一个比较长的编码来表示它，比如说用一个10位的编码表示它。这样，在对数据进行编码后，数据的存储空间就会减少。</p><h3 id="5-图"><a href="#5-图" class="headerlink" title="5. 图"></a>5. 图</h3><p>下面先回顾一下图中的术语以及定义：</p><ol><li>顶点（vertex）：也称为节点，表示图中的一个点，通常用一个唯一的标识符来标识。</li><li>边（edge）：表示两个顶点之间的连线，可以是有向或无向的，可以有权重或无权重。</li><li>权重（weight）：如果边带有数值，则称这个数值为边的权重。</li><li>路径（path）：表示从一个顶点到另一个顶点依次经过的边和顶点的序列，路径的长度为路径上所有边的权重之和。</li><li>环（cycle）：表示一个顶点经过一系列边回到自身的路径。</li><li>连通（connected）：如果图中的任意两个顶点都有一条路径相连，则称该图是连通的。</li><li>连通分量（connected component）：无向图中每个连通的部分称为一个连通分量。</li><li>强连通（strongly connected）：如果有向图中的任意两个顶点都有互相到达的路径，则称该图是强连通的。</li><li>强连通分量（strongly connected component）：有向图中每个强连通的部分称为一个强连通分量。</li><li>入度（in-degree）：有向图中指向一个顶点的边的数量。</li><li>出度（out-degree）：有向图中从一个顶点出发的边的数量。</li><li>邻接点（adjacent vertex）：与一个顶点直接相连的顶点称为它的邻接点。</li><li>邻接矩阵（adjacency matrix）：用矩阵来表示图中每个顶点之间的连通关系，其中矩阵中的行和列分别代表图中的顶点，矩阵中的元素表示两个顶点之间是否有连通关系。</li><li>邻接表（adjacency list）：用链表来表示图中每个顶点的邻接点列表，链表中的每个节点表示一个邻接点。</li></ol><h4 id="5-1-图的抽象数据类型以及其实现"><a href="#5-1-图的抽象数据类型以及其实现" class="headerlink" title="5.1 图的抽象数据类型以及其实现"></a>5.1 图的抽象数据类型以及其实现</h4><h5 id="5-1-1-邻接矩阵"><a href="#5-1-1-邻接矩阵" class="headerlink" title="5.1.1 邻接矩阵"></a>5.1.1 邻接矩阵</h5><p>只是一个矩阵，不多赘述</p><h5 id="5-1-2-邻接表"><a href="#5-1-2-邻接表" class="headerlink" title="5.1.2 邻接表"></a>5.1.2 邻接表</h5><p>python中，字典的键值对可以有效地实现图的边。下面是一个示例，利用字典connectedTo来记录与节点Vertex相邻的点。</p><p>以下给出一个节点类：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,key</span>):</span><br><span class="line">self.<span class="built_in">id</span>=key</span><br><span class="line">self.connectedTo=&#123;&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addNeighbor</span>(<span class="params">self,nbr,weight=<span class="number">0</span></span>):</span><br><span class="line">self.connectefTo(nbr)=weight</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">str</span>(self.<span class="built_in">id</span>)+<span class="string">&#x27; connectedTo: &#x27;</span>+<span class="built_in">str</span>([x.<span class="built_in">id</span> <span class="keyword">for</span> x <span class="keyword">in</span> self.connectedTo])</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getConnections</span>(<span class="params">self</span>):</span><br><span class="line"><span class="comment">#通过获取所有键，获取节点所有相接的顶点名</span></span><br><span class="line"><span class="keyword">return</span> self.connectedTo.keys()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getId</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.<span class="built_in">id</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getWeight</span>(<span class="params">self,nbr</span>):</span><br><span class="line"><span class="keyword">return</span> self.connectedTo[nbr]</span><br></pre></td></tr></table></figure></p><p>Graph类就不再赘述，只需要特别注意两个功能：添加顶点，添加边</p><h4 id="5-2-广度优先搜索（BFS）"><a href="#5-2-广度优先搜索（BFS）" class="headerlink" title="5.2 广度优先搜索（BFS）"></a>5.2 广度优先搜索（BFS）</h4><p>要求边的权值都为0！！！！！！</p><p>BFS，即广度优先搜索（Breadth-First Search），是一种图的遍历算法，用于在图中搜索特定的节点或路径。BFS从给定的起始节点开始遍历图，首先访问起始节点的所有邻居节点，然后按照遍历的深度依次访问下一层节点，直到遍历完整张图或找到目标节点为止。</p><p>BFS通常借助队列（Queue）数据结构来实现。首先将起始节点加入队列中，然后不断从队列中取出最早进入队列的节点，并将其邻居节点加入队列中（如果之前取过了，则不取），并计算节点到起始节点的距离（父节点到起始节点的距离+1）直到队列为空或找到目标节点为止。</p><img src="/2023/09/05/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.gif" class="" title="sucessful style&#x3D;display: block; margin: 0 auto; max-width: 50%;"><p>下面是一个实现的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pythonds.graphs <span class="keyword">import</span> Graph, Vertex</span><br><span class="line"><span class="keyword">from</span> pythonds.basic <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">BFS</span>(<span class="params">g,start,end</span>):</span><br><span class="line"><span class="comment">#储存据起始节点距离</span></span><br><span class="line">distance=&#123;&#125;</span><br><span class="line">distance[start]=<span class="number">0</span></span><br><span class="line"><span class="comment">#储存是否有被访问过</span></span><br><span class="line">visited=[]</span><br><span class="line"><span class="comment">#队列</span></span><br><span class="line">queue=Queue()</span><br><span class="line">queue.enqueue(start)</span><br><span class="line"><span class="comment">#创建字典，用于记录每个节点的父节点，用于回溯路径</span></span><br><span class="line">parent = &#123;&#125; </span><br><span class="line"><span class="keyword">while</span>(!queue.size==<span class="number">0</span>):</span><br><span class="line"><span class="comment">#currentq：当前访问到的节点，名字起错了，不想改了</span></span><br><span class="line">currentq=queue.dequeue()</span><br><span class="line"><span class="keyword">if</span>(currentq==end):</span><br><span class="line"><span class="comment">#回溯打印</span></span><br><span class="line"><span class="keyword">while</span>(!currentq==start):</span><br><span class="line"><span class="built_in">print</span>(currentq.<span class="built_in">id</span>)</span><br><span class="line">currentq=parent[currentq]</span><br><span class="line"><span class="built_in">print</span>(start.<span class="built_in">id</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> currentq.connectedTo:</span><br><span class="line"><span class="keyword">if</span>(item <span class="keyword">not</span> <span class="keyword">in</span> visited):</span><br><span class="line">visited.appenf(item)</span><br><span class="line">queue.enqueue(item)</span><br><span class="line">distance[item]=distance[current]+<span class="number">1</span></span><br><span class="line">parent[item]=currentq</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></p><h4 id="5-3-深度优先搜索"><a href="#5-3-深度优先搜索" class="headerlink" title="5.3 深度优先搜索"></a>5.3 深度优先搜索</h4><p>深度优先搜索（Depth-First-Search, DFS）是一种用于遍历或搜索树或图的算法，其主要思想是从起点开始，不断往深度方向搜索，直到找到目标节点或者无法继续为止，然后返回上一层节点，继续搜索其他未被访问过的节点。</p><p>递归式的DFS可以通过递归调用实现。具体实现过程如下：</p><ol><li>创建一个visited数组，用于记录每个节点是否被访问过，初始值都为False。</li><li>定义DFS函数，输入参数为当前节点和图的邻接表表示。首先标记当前节点为已访问，并输出当前节点。然后遍历当前节点的邻居节点，对于每个未被访问过的邻居节点，递归调用DFS函数。</li><li>在主函数中遍历图中的每个节点，对于每个未被访问过的节点，调用DFS函数。</li></ol><p>以下是Python实现代码示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">currentVertex, visited</span>)<span class="comment">#当前访问的节点，已经访问过的节点列表</span></span><br><span class="line">visited[currentVertex]=<span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span>(currentVertex.<span class="built_in">id</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> currentVertex.connectedTo:</span><br><span class="line"><span class="keyword">if</span>(item <span class="keyword">not</span> <span class="keyword">in</span> visited):</span><br><span class="line">DFS(currentVertex,visited)</span><br></pre></td></tr></table></figure></p><h4 id="5-4-最短路径"><a href="#5-4-最短路径" class="headerlink" title="5.4 最短路径"></a>5.4 最短路径</h4><h5 id="5-4-1-Dijkstra算法"><a href="#5-4-1-Dijkstra算法" class="headerlink" title="5.4.1 Dijkstra算法"></a>5.4.1 Dijkstra算法</h5><p>Dijkstra算法是一种用于求解单源最短路径的贪心算法，它能够计算出从一个源点到图中其他所有点的最短路径。算法的基本思想是维护一个到源点的距离数组，每次选取一个距离最短的点进行松弛操作（通过更新边来减小从起点到顶点的距离），更新其他节点到源点的距离值。当所有节点都被更新后，最短路径就求解完成。</p><p>以下是使用Python实现Dijkstra算法的代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个函数用于实现Dijkstra算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dijkstra</span>(<span class="params">graph, start</span>):</span><br><span class="line">    <span class="comment"># 初始化距离字典，所有节点的距离值默认为无限大</span></span><br><span class="line">    dist = &#123;node: <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125;</span><br><span class="line">    <span class="comment"># 将起点的距离值初始化为0</span></span><br><span class="line">    dist[start] = <span class="number">0</span></span><br><span class="line">    ……<span class="comment">#初始化距离字典</span></span><br><span class="line">    <span class="comment"># 初始化路径字典</span></span><br><span class="line">    path = &#123;start: []&#125;</span><br><span class="line">    <span class="comment"># 将起点放入已访问节点集合中</span></span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 从未访问节点中找到距离起点最近的节点</span></span><br><span class="line">        min_node = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> graph:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">if</span> min_node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    min_node = node</span><br><span class="line">                <span class="keyword">elif</span> dist[node] &lt; dist[min_node]:</span><br><span class="line">                    min_node = node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> min_node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将该节点标记为已访问</span></span><br><span class="line">        visited.add(min_node)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新所有与该节点相邻的节点的距离值</span></span><br><span class="line">        <span class="keyword">for</span> neighbor, weight <span class="keyword">in</span> graph[min_node].items():</span><br><span class="line">            <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                new_dist = dist[min_node] + weight</span><br><span class="line">                <span class="keyword">if</span> new_dist &lt; dist[neighbor]:</span><br><span class="line">                    dist[neighbor] = new_dist</span><br><span class="line">                    path[neighbor] = path[min_node] + [min_node]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist, path</span><br></pre></td></tr></table></figure></p><h5 id="5-4-2-Prim算法"><a href="#5-4-2-Prim算法" class="headerlink" title="5.4.2 Prim算法"></a>5.4.2 Prim算法</h5><p>Prim算法是一种用于解决最小生成树问题的贪心算法。其基本思路是从一个起点开始，不断扩展生成树，每次加入距离已有部分最近的一个点，直到所有点都被加入为止。</p><p>具体步骤如下：</p><ol><li>初始化一个空的生成树，以一个节点作为起始节点；</li><li>找到与生成树相邻的边中，权值最小的那条边，将其连接的点加入生成树中；</li><li>重复第二步，直到所有节点都加入生成树中。</li></ol><p>该算法可以借助优先级队列来实现（Dijkstra算法也可以，但我没用），优先级队列可以弹出包含最小元素的字典。</p><p>下面是一个python实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pythonds.graphs <span class="keyword">import</span> PriorityQueue, Graph, Vertex</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Prim</span>(<span class="params">G, start</span>):</span><br><span class="line">pq=PriorityQueue()</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> G:</span><br><span class="line">v.setDistance(sys.maxsize)<span class="comment">#设置和起始点的距离</span></span><br><span class="line">v.setPred(<span class="literal">None</span>)<span class="comment">#设置前驱结点</span></span><br><span class="line">start.SetDistance(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#创建一个堆，存放河节点的相邻节点</span></span><br><span class="line">pq.buildHeap([(v.getDistance, v) <span class="keyword">for</span> v <span class="keyword">in</span> G])</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> pq.isEmpty():</span><br><span class="line"><span class="comment">#取出最小的起始点的相邻节点</span></span><br><span class="line">currentVert=pq.delMin()</span><br><span class="line"><span class="comment">#遍历该节点的所有相邻节点</span></span><br><span class="line"><span class="keyword">for</span> nextVert <span class="keyword">in</span> currentVert.getConnections():</span><br><span class="line"><span class="comment">#新的距离=节点currentVert和原点的距离+当前节点和currentVert的距离</span></span><br><span class="line">newCost=currentVert.getWeight(nextVert)+currentVert.getDistance()</span><br><span class="line"><span class="comment">#如果新生成的路径长度比原来的短</span></span><br><span class="line"><span class="keyword">if</span> v <span class="keyword">in</span> pq <span class="keyword">and</span> newCost&lt;nextVert.getDistance():</span><br><span class="line">nextVert.setPred(currentVert)</span><br><span class="line">nextVert.setDistance(newCost)</span><br><span class="line">pq.decreaseKey(nextVert,newCost)</span><br></pre></td></tr></table></figure></p><h3 id="6-python基础复习"><a href="#6-python基础复习" class="headerlink" title="6. python基础复习"></a>6. python基础复习</h3><h4 id="6-1-python基础库"><a href="#6-1-python基础库" class="headerlink" title="6.1 python基础库"></a>6.1 python基础库</h4><ol><li>队列：queue，入队和出队的方法分别是put()和get()，empty(): 判断队列是否为空。qsize(): 返回队列中当前的元素个数。</li><li>栈：Python 中没有专门表示栈的基础库，但是可以使用内置的 list类来实现栈的功能，因为list 的 append() 和 pop()方法可以分别实现入栈和出栈操作。</li></ol><h4 id="6-2-基础函数"><a href="#6-2-基础函数" class="headerlink" title="6.2 基础函数"></a>6.2 基础函数</h4><h5 id="6-2-1-列表基础函数"><a href="#6-2-1-列表基础函数" class="headerlink" title="6.2.1 列表基础函数"></a>6.2.1 列表基础函数</h5><ol><li>append：在列表末尾添加一个元素，例如：<code>list.append(item)</code></li><li>extend：将一个列表中的所有元素添加到另一个列表末尾，例如：<code>list.extend(another_list)</code></li><li>insert：在列表的指定位置插入一个元素，例如：<code>list.insert(index, item)</code></li><li>remove：删除列表中指定的元素，例如：<code>list.remove(item)</code></li><li>pop：从列表中删除指定位置的元素，并返回该元素，例如：<code>list.pop(index)</code></li><li>index：返回列表中指定元素的索引位置，例如：<code>list.index(item)</code></li><li>count：返回列表中指定元素出现的次数，例如：<code>list.count(item)</code></li><li>sort：对列表中的元素进行排序，例如：<code>list.sort()</code></li><li>reverse：将列表中的元素反向排序，例如：<code>list.reverse()</code></li><li>clear：从列表中删除所有元素，例如：<code>list.clear()</code></li><li>构建二维数组：Sum=[[0 for i in range(n)]for j in range(m)]</li></ol><h5 id="6-2-2-字典基础函数"><a href="#6-2-2-字典基础函数" class="headerlink" title="6.2.2 字典基础函数"></a>6.2.2 字典基础函数</h5><ol><li>dict()：创建一个新字典</li><li>len(dict)：返回字典中键值对的数量</li><li>dict[key]：获取字典中指定键的值</li><li>dict[key] = value：设置字典中指定键的值</li><li>del dict[key]：从字典中删除指定键</li><li>key in dict：检查字典中是否包含指定键</li><li>dict.keys()：返回一个包含字典所有键的列表</li><li>dict.values()：返回一个包含字典所有值的列表</li><li>dict.items()：返回一个包含字典所有键值对的列表</li><li>dict.get(key, default)：获取字典中指定键的值，如果键不存在返回默认值</li><li>dict.setdefault(key, default)：获取字典中指定键的值，如果键不存在设置默认值并返回</li><li>dict.pop(key, default)：从字典中删除指定键，并返回其对应的值。如果键不存在返回默认值</li><li>dict.update(other_dict)：使用其他字典中的键值对来更新当前字典</li></ol><h5 id="6-2-3-map、filter函数"><a href="#6-2-3-map、filter函数" class="headerlink" title="6.2.3 map、filter函数"></a>6.2.3 map、filter函数</h5><p><code>map()</code> 是 Python 内置的一个高阶函数，它将一个函数作用于一个或多个可迭代对象的每个元素上，并返回一个可迭代对象（迭代器），其中包含应用函数后的结果。</p><p><code>map()</code> 函数的语法如下，下面是一个简单的例子，将一个列表中的每个元素乘以 2：：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">double</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">doubled_numbers = <span class="built_in">list</span>(<span class="built_in">map</span>(double, numbers))</span><br><span class="line"><span class="built_in">print</span>(doubled_numbers)  <span class="comment"># [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure><br>在这个例子中，<code>double()</code> 函数接收一个参数并返回该参数的两倍。<code>map()</code> 函数将 <code>double()</code> 应用于 <code>numbers</code> 列表中的每个元素，并返回一个迭代器，其中包含应用函数后的结果。<code>list()</code> 函数将迭代器转换为一个列表，最终输出 <code>[2, 4, 6, 8, 10]</code>。</p><p><code>filter</code>函数：对一个可迭代对象中的元素进行过滤，返回满足条件的元素组成的新的可迭代对象。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_even</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">return</span> num % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">even_nums = <span class="built_in">filter</span>(is_even, nums)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(even_nums))  <span class="comment"># [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure></p><h5 id="6-2-4-字符串函数"><a href="#6-2-4-字符串函数" class="headerlink" title="6.2.4 字符串函数"></a>6.2.4 字符串函数</h5><ol><li>len()：获取字符串的长度。</li><li>strip()：去掉字符串开头和结尾的空格。</li><li>split()：按照指定的分隔符将字符串分割成列表。</li><li>join()：将列表或元组中的字符串拼接成一个字符串，中间用指定的字符隔开。</li><li>replace()：将字符串中指定的子字符串替换为另一个字符串。</li><li>find()：查找指定的子字符串在字符串中的位置，返回第一个匹配到的位置。</li><li>lower()和upper()：分别将字符串转换成小写和大写。</li><li>startswith()和endswith()：判断字符串是否以指定的字符串开头或结尾。</li><li>isdigit()、isalpha()和isalnum()：判断字符串是否全部由数字、字母或数字字母组成。</li><li>format()：将指定的值格式化到字符串中。</li><li>list()：转化为一个列表</li></ol><p>示例：join的用法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">words = [<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;awesome&#x27;</span>]</span><br><span class="line">sep = <span class="string">&#x27; &#x27;</span></span><br><span class="line">sentence = sep.join(words)</span><br><span class="line"><span class="built_in">print</span>(sentence) <span class="comment"># 输出：Python is awesome</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2023-04-03日上传，2023-04-05日第三次更新。&lt;br&gt;报了个蓝桥杯的python赛道，却没怎么复习……稍微整理了一些数据结构（python实现）的知识点，赛前看一下。&lt;br&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
  <entry>
    <title>书接上回：一些专访的摘录</title>
    <link href="https://atffang.github.io/2023/08/21/%E4%B9%A6%E6%8E%A5%E4%B8%8A%E5%9B%9E%EF%BC%9A%E4%B8%80%E4%BA%9B%E4%B8%93%E8%AE%BF%E7%9A%84%E6%91%98%E5%BD%95/"/>
    <id>https://atffang.github.io/2023/08/21/%E4%B9%A6%E6%8E%A5%E4%B8%8A%E5%9B%9E%EF%BC%9A%E4%B8%80%E4%BA%9B%E4%B8%93%E8%AE%BF%E7%9A%84%E6%91%98%E5%BD%95/</id>
    <published>2023-08-21T12:43:32.000Z</published>
    <updated>2023-08-22T02:24:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>书接上回，本篇摘录了南方人物周刊、花城关注等媒体对于万能青年旅店的采访，或许对深入了解该乐队有一定帮助。<br><span id="more"></span><br><br></p><h5 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h5><p><img align="left" width=62% src="https://s2.loli.net/2023/08/21/IBlmTQEOoxZiFLM.jpg" style="margin-right: 10px;margin-top: 10px;margin-buttom:20px;">&emsp;&emsp;本文主要摘录了两篇个人认为较好也较为重要的报道，一是南方人物周刊邓郁记者的专访《出入太行，骤雨重山》，二是花城关注对姬赓老师的专访《此生再不回太行》。文章仅是略加编排，且由于资料的缺失，内容是我从照片中提取文字而后修改而成，有错别字还望海涵（肯定有）。有时候写博客杂乱无章，说到底是因为有些东西只是空虚时的聊以慰藉，望大家谅解。</p><p><br></p><h5 id="《出入太行，骤雨重山》"><a href="#《出入太行，骤雨重山》" class="headerlink" title="《出入太行，骤雨重山》"></a>《出入太行，骤雨重山》</h5><p><br></p><font face=STKaiti>&emsp;&emsp;在生长之地石家庄,万能青年旅店用根源于旧时代的音乐质感、锐利而柔和的笔触,书写我们共同感知到却难以言说的现实。</font><br>&emsp;&emsp;本刊记者  邓郁 &emsp;&emsp;编辑 周建平<br><font face=STKaiti>&emsp;&emsp;“懒散”和羞涩是自封的外壳，一捅开便是“较真”的内里。万青活在20年前、甚至更早前的音乐中，却又对周遭保持着绝对的敏感。在恒久的稳重、克制和偶尔显山露水的风暴里，精心锤炼，越来越接近他们的内心。不论是身处的石家庄，还是其他地方，他们从未刻意地融入，或是保持距离。“哪里，都是此处。”</font><p><br></p><p>&emsp;&emsp;2010年，以神隐状态扎在石家庄的万能青年旅店乐队，依托创作者在20平的自家房间录制的音乐，发布了首张同名专辑。充满隐喻的现代诗般的歌词、精致的乐器编配和成熟的演奏，令乐评人和歌迷吃惊不小。大V微博推荐、歌迷热传、电台报道，对岸同行翻唱，形成一时蔚为壮观的文化现象。有听众评价该唱片是“对当下时代精神内核抓得最准的一张。没有宏大叙事、耍小聪明、自以为是、口号抗争。它是送给我们每个人的一把最真实的匕首”。<br>&emsp;&emsp;而另一方面，乐队成员造型俭朴如一，表演时木讷寡言，从不上综艺，受访寥寥无几，新歌遥遥无期。首专出来后，不断有人问，真的要“一张(七八首)吃一辈子”?<br>&emsp;&emsp;这种无望在2017年末将至时，终被打破。先是上海，接着成都，万青在两次渤海洗雷音专场里终于演出了三首新曲。<br>&emsp;&emsp;因为只在两个小场地唱，又没有视频流出，新歌的反响只在极其有限的局部发酵，从听众和乐评人那儿收集来，诸如“写词稳定、配器庞杂、万青还是万青”的零星片语,渐渐冷却,消弭在喧哗众声里。4个月过去，其他新曲目的消息依然不太明朗。新专辑眼看着要持续第一张的漫长打磨。<br>&emsp;&emsp;我们好奇的是，这支在20年前组建雏形、10年前基本定型的乐队，究竞有多“另类”?他们如何认清和确立自己？在成名后的这六七年里，成员们做了些什么？新音乐去往何方？当年几乎一面倒的认可，在这个越发难以预判的流量时代是否还会延续？万青和石家庄这座“2.5线城市”之间是怎样一种关系？<br>&emsp;&emsp;这个探知过程，在不善也不爱表露内心的乐队面前，呈现出了预料中的艰难。磕磕绊绊的访谈,拼凑的周边,老到发黄的资料,最终勾勒出山之一角。<br><br></p><h6 id="乌云"><a href="#乌云" class="headerlink" title="乌云"></a><font face=STKaiti>乌云</font></h6><p>&emsp;&emsp;从石家庄往西，行至鹿泉、井陉一带。山体如同被巨雷开腔破肚，劈出一道道的伤疤，裸露出黄褐色或灰白色的内里。巨大的人造天坑和众多的坑口沿着山岭密集分布，碎石遍地。<br>&emsp;&emsp;不远处可见依山而建的水泥厂或是公私矿场，就地取材、收益肥厚。被吸过铁粉的砂土被随意堆在山坡上。钩机正在山顶上采石头，一辆辆运输用的大车等待着装载。凿下来的碎石,每堆恐怕得有一两层楼高。挖掘机不断将这些碎石装进卡车,再倒进碎石机。行驶的噪音过后,扬尘让人看不清几米开外村民的脸。<br>&emsp;&emsp;“爆炸南一响，红色、黄色的粉尘能遮住天。”<br>&emsp;&emsp;昔日葱郁的植被如今只剩零星的几棵在风中抖瑟；而挖山形成的悬崖陡壁，很容易掉下碎石块,砸中路过的车辆或是附近的民居。<br>&emsp;&emsp;从三四年前至今，万青的主创姬赓和董亚千不止一次骑着摩托走过这条路，不仅乐队全体成员,《我爱摇滚乐》的前主编。和前资深编辑、现任万青经纪人的赵亮，也都曾带着家人朋友开车或坐车，与这些骇人的景观擦身而过。<br>&emsp;&emsp;“之前其实很漂亮的一个山,小村子,转过去一看整个一面全被挖了,现在回填,再重新种植被‘补绿’。但完全不是那么回事。”这个画面对姬赓等人触动极大。<br>&emsp;&emsp;那时候哥几个还没想好新专辑要写什么。手头攒着的“音乐动机”(姬赓说，音乐动机是音乐创作的原始动机，觉得这段小旋律与自己有关，包含着某种可能性)已经不少，但很凌乱。<br>&emsp;&emsp;溜达一圈之后就琢磨，要不咱们写这个吧?等把第一首敬《采石》写完,就找着感觉了。<br>&emsp;&emsp;看似直观,却依然意在言外。<br>&emsp;&emsp;赵亮的媳妇就住在太行山里,在深山中的学校教书。每个月他都要从北京乘火车再倒大巴车，回家和妻儿团聚。他曾经在文章里这样描述:“”井陉县,耕地稀少,黑白分明———列挂载了数十节车厢的火车在矿区装满煤炭，中途俯视右侧的县城,汇入这个国家的铁路主干道：而在此之前，还要经过一段漫山遍野白成一道的地方，那里竖着一块白灰覆盖的牌子：建设中国钙都。人们向下挖掘煤炭，向上崩山采石，炼制白色钙产品。一黑一白，不是琴键，而是一整个县的营生，还有县里人的两个肺。”<br>&emsp;&emsp;难怪他看到姬医的歌词忍不住哭出来。鼓手史立过年前还带着朋友走了这条线，他说“见多识广”的艺术家们看到山体，都惊了。“我们住在石家庄、河北这一带的，一看这词儿，都明白写的是什么。”<br>&emsp;&emsp;不过，“概念组曲”前两首呼之欲出的压抑、阴郁，到了第三首《山雀,却明显给人感受到清新宁静之美。演出时的大屏幕上，密林里透出微煦晨光，鸟儿高低回旋。长笛加入的旋律也悠然起来。<br>&emsp;&emsp;直到最后一句，”火光汹汹，指引盗寇入太行”，到底泄露了创作者的底色。<br>&emsp;&emsp;“三部歌曲相互关联，又是一个大的概念的组成部分。整张专辑完成之后，会把概念呈现得更加完整。”截稿前的夜里,姬赓确认了这一点。<br>&emsp;&emsp;很多人都注意到，乌云”取代“黑暗””，成了新歌的关键词。当然，还有三部曲每首都出现的“太行”。<br>&emsp;&emsp;是被那种巨大的、掠夺式的资源消耗击中了?“不是。”姬赓第一时间反驳。<br>&emsp;&emsp;“这首歌跟生态，不是那种关系，不是说你作为一个旁观者去批评。我特别不愿意让大家只是想到环保生态，太把自己当成一个城市里的人了。什么‘环保生态”，这就是你本人的世界，我们是一体的。你看见它被填回去，种上树，但是重要的珍责的东西早就没有了。这和一个人被消耗的过程是一样的。”<br><br></p><h6 id="解读"><a href="#解读" class="headerlink" title="解读"></a><font face=STKaiti>解读</font></h6><p>&emsp;&emsp;对万青歌词的“误读”或者说争相解读，由来已久。除去纯乐器演奏和仅仅七八句的《不万能的喜剧》,首专的七首曲目和后来的单曲，每一首都会在网络的上引发提问,“谁能告诉我《××》歌里到底讲了什么?”<br>&emsp;&emsp;那首令乐队名声鹊起的《杀死那个石家庄人》,总难免让人联想到靳如超案。<br>&emsp;&emsp;2001年,石家庄人靳如超因婚姻问题与同居女友争吵,盛怒中举刀将对方砍死。儿时落下耳背的靳如超生活窘困，与邻居、亲人因琐事争吵不休。当年3月16日，他引爆预先放好的炸药，造成五栋居民楼相继爆炸，死伤过百。<br>&emsp;&emsp;姬赓从来不解读自己的歌词，《杀死那个石家庄人》引发了围绕爆炸案、旧工业城市下岗潮和转型困境的各种播测和议论。“逼”得急了，他最“直白”的解释唯有一次：“这歌讲的就是一家三口，日常生活的悲剧。冷漠的父亲，绝望的母亲，尚未被驯服的儿子。这样的家庭在我生活的家属院就有很多。这不是一个正常的成长过程，是对热情和自尊的蚕食。”<br>&emsp;&emsp;“杀死的，是精神啊。”一个本地出租车司机，在听完一个拜访万青的朋友在车里播放这首歌后，忽然明白了。<br>&emsp;&emsp;姬赓的歌词里有《十万嬉皮》的骈句式工整；更多的是长短句的交错，密度大，满是诗的意味。看似充满象征和隐喻的叙事与抒情，生猛又浪漫，曲折迁回而欲说还休。稳重、克制,又充满了无限的想象空间。<br>&emsp;&emsp;“孤独的海怪”，“独脚大盗”，“云和闪电的脾气”…歌迷乐于在这些词句里揣摩作者的意图，如同他们从仅有的几篇访谈里追索黑塞、谷崎润一郎、帕蒂·史密斯带给姬赓的影响。这种乐趣甚至从听歌延展到了私下的社交生活,形成了一个个互认知己的精神共同体。一个万青粉丝微信群要求入群者必须能说出乐队早年的三首作品名，另一个微信群则需要申请者说出对于“自由或许问心脏”这句万青歌词的个人理解。<br>&emsp;&emsp;解读当然是个人权利，不过如果集向一端，总有断章取义和自以为是的“危险”。乐评人马加和陈郁都认为，就一首音乐作品而言，如果仅仅停留在为时代做注脚的功能上，那它的审美效用则变得可疑。对歌曲进行种种翻转式阐释，终将成为“另一种不义，一种被绑架了的短视”。<br>&emsp;&emsp;但这依然挡不住忠实歌迷的各种品读和咀嚼。在去年11月26日成都万青专场开场前，我偶遇一对看来如同姐俩的师生忘年交阿爽(化名）和张蓓。她们操着利索的川音，在候场的嘈杂声里讨论得甚是热烈。<br></p><font face=STKaiti>&emsp;&emsp;张蓓：你像,“来到自我意识的边疆，看到父亲坐在云端抽烟，他说孩子去和昨天和解吧”，他们的歌词很能引起共鸣。还有，长句子很多，用词不是那么口语化。比如，“囿于”这种字眼（见歌词:是谁来自山川湖海,却囿于昼夜厨房与爱)。估计受外国文学影响。姬老师,英美文学嘛……<br>&emsp;&emsp;阿爽：其实华语（音乐）圈里,诗意的不止他们。<br>&emsp;&emsp;张蓓：对啰。你说周云蓬,他本来是个诗人，不用说了。野孩子，属于草根性很重的乐队，他们向子都很朴实，不华丽。<br>&emsp;&emsp;阿爽：还有吴吞。<br>&emsp;&emsp;张蓓：吴吞又不一样,很不一样。万青更文学性，我不想用小清新这个词，感觉他们(万青）像小说诗歌的印刷体……吴吞更酣畅，更强悍，语言天分也很高。<br>&emsp;&emsp;反正，听他们的歌，你要是没有感觉，咋个都没有感觉捏。有感觉的人，你听就是了。我觉得，好的音乐人，共同点就是诚恳，不装，不炫。<br></font><p>&emsp;&emsp;戴着眼镜、留平头的“资优生”姬赓一路读完硕士,深受英美文学熏陶，如今在石家庄的一所高校当英文教师。同样教授语言的姬父素来采取宽容的教育方式。姬赓不喜所谓名著.便乐得自在吸收。<br>&emsp;&emsp;在他，写歌并不苦，“排绒还是比较程字化，写歌很有乐趣。”他总说,虽然也想写点轻松的东西，但或许性格使然。写着写着就成了那样。有人说新歌有了“雕琢”感。姬赓承认,从来灵越都非飘然而至，一笔挥就。唯一的原则就是，“要能说服自己，是对的。”<br>&emsp;&emsp;可以想见，这条路走得不轻松。<br><br></p><h6 id="萌芽"><a href="#萌芽" class="headerlink" title="萌芽"></a><font face=STKaiti>萌芽</font></h6><p>&emsp;&emsp;姬赓和昵称“二千”的董亚千是小学同学，初中高中都一起组过乐队。某天，从《音乐天堂》里听到盲瓜乐队（BlindMelon）的《Car Seat》，顿时觉得不一样。“那时候正好在听Grunge ( Grunge，油渍摇滚，又译垃圾摇滚、颓废摇滚,隶属于另类摇滚的音乐流派）嘛，哎，就觉得这个蛮特别的，有大提琴，非常喜欢。”<br>&emsp;&emsp;去年“双十一”那天,后台见到的董亚千，文着花的浅棕色皮靴尖头微微翘着，钥匙像上世纪80年代中年人似的挂在牛仔裤腰上，口袋里塞了包纸巾。格子衬衫上的扣眼开得随意。过肩的头发，油腻得卷儿都黏乎了，像一礼拜没洗。拿把单排齿梳子，刮嚓两下完事。<br>&emsp;&emsp;几天后，去宁波的音乐节演出前，他提溜着一个白布袋子，晃晃悠悠去机场。里头装的，也是那双长到膝下的牛仔旧皮靴。<br>&emsp;&emsp;“他的仔靴靴腿儿特别高嘛，每次过安检,机场的人就要给他脱下来检查。”赵亮说,“Jimmi Hendrix在老董心里有比较至上的地位，还有Stevie Ray Vaughan。他的打扮就是典型的德州牛仔样儿。我一开始看他们最早的照片时，也穿那种法兰绒啊，非常的Grunge。”<br>&emsp;&emsp;1996年4月，他俩加上鼓手张培栋，给鼓捣出的乐队取名 The Nico，那是28岁嗑药而死的盲瓜主唱Shannon Hoon襁褓中的女儿的名字。“说组建有点正式，实际就是几个小屁孩凑在一起胡闹。”姬赓说过。<br>&emsp;&emsp;他笑着调侃，因为中“盲瓜”的毒很深，“对他们那种丰富性的迷恋，和自身技术水平低下导致了后来作品的难产。其实晚点听到盲瓜就好了，Grunge那股劲还能在身上多保留几年。这事都怪（朋友)炸子马，是他在地摊上给我挑了张《soup 》。那时候放学回家的路上就能买到打口带(“打口”，指国外积压的音像制品处理后被作为塑料垃圾进口，却以音像制品的身份在中国各地的非主流渠道流通)。”<br>&emsp;&emsp;和西安、兰州、成都相比，石家庄的“摇滚重镇”之名来得没那么有底气。但在乐迷心里，两本曾补给过他们青春饥渴的石家庄本土摇滚杂志，分量绝对够重。<br>&emsp;&emsp;1987年《通俗歌曲》在石家庄创刊，1999年改版为16开的摇滚刊物，喊出“摇滚你的生活”的口号。路子更野的《我爱摇滚乐》也在同年由《通俗歌曲》前主编晓朱(朱晋辉)创刊，成了最摇滚却最不像音乐杂志的反主流小报。晓朱还开过录音棚，有自己的厂牌，录了一堆唱片。这两本经常在报刊亭断货的杂志,加上蓝恐龙、金旋律和极端音乐这些音像店里的打口带，滋养了无数寻求精神慰藉和精力出口的青年。<br>&emsp;&emsp;装束是外化，涅槃、珍珠酱、碎瓜等乐队，以及 MilesDavis，终究成为 The Nico们血液里的一部分。不到18岁的董亚千立志，这辈子就磕在摇滚上了。<br>&emsp;&emsp;所幸，父母反对、家庭封锁这些发生在别人青春期的痛苦史，他都没遇着。唯一要较劲的，就是自己。<br>&emsp;&emsp;有人在网上爆料，以“石家庄吉他一把手”出名前,董亚千为了在秦川琴行挑到一把理想的吉他，每天去得比员工还早。店门一开，就试上整整一天——除了吃饭上厕所，所有时间一直在试琴，试奏各种不同风格，一直到人家下班。就这样，整整试了三天,最后才挑中自己满意的吉他。<br>&emsp;&emsp;“那时候贼喜欢西雅图那些东西(音乐，嘿，吉他怎么会弹成这样？其实他们打骨子里都是精通blues(布鲁斯)的，后来我就觉得我应该把那东西弹明白了。就开始尝试自己慢慢学呗。但是爵士乐也容易特别庸俗化,所以运用的时候特别小心。”董亚千回忆。<br>&emsp;&emsp;先是扒那些经典的歌，后来就学理论，现在还在学——最近他在啃的是减音阶。20岁时没有特明白的老师，告诉自己这个体系怎么弄。这两年，董亚千认识了几个受过传统训练的萨克斯手。听他们讲了讲，才明白更多的子丑寅卯。“JimmyHendrix技术上其实没有什么特别难的地方，关键是他作曲的想法和意识，很难企及。”他抽根烟，定定看着空气。<br>&emsp;&emsp;“董是早早混迹社会的野路子，一路摸爬滚打过来。能从演奏里听出来90年代自学成才的技术流乐手的痕迹，长长的solo，那种从逼仄之处磨出来的扎实，狭隘。”乐评人和小宇写道，“他理想中的音乐应该有成人摇滚乐的质地，严肃，优美，精纯，老到。另一方面，他对成年人所栖身的世界兴趣寥寥，他的音乐世界没有什么文化和性征的痕迹。”<br>&emsp;&emsp;所有的歌都是董亚千写出旋律，姬赓填词。旺盛的时候一天三五个动机，稍有点瑕疵，玩玩就扔了不要了。<br>&emsp;&emsp;1997年，晓朱说有个合辑，你们掺和一下吧。几个人就用一个星期写完了一个动机，“也不是当时最好的，那时候想把好的先留一下，结果后来都给扔了。”这便是收录在《非常次序》合辑里的《巢穴在望》。<br></p><font face=STKaiti>青鸟儿，快带来些温暖的消息吧! 它眨眼飞走了，飞走了<br>挤出泪，如同胶水<br>这粘稠的讥笑<br>我失望地拒绝了它<br></font><p>&emsp;&emsp;歌词和那时董亚千的嗓音一样的青涩。晓朱把他们带到北京，去一个琴行借了把贝司，在一个录音棚里录了两天，刨去开销，每人分了200块钱，,那是他们第一次用自己的音乐换到银子。而这首处女作，他们此后再没怎么听过。<br>&emsp;&emsp;弹琴，教教小孩。有时跑去秦皇岛，直接租条船。“凌晨3点钟出海，撒网，第二天早上去捞，然后再把新的网放下去，一天的收获就是一大堆皮皮虾和螃蟹什么的。”<br>&emsp;&emsp;在后来可见的报道里，总能见到“艰苦、潦倒”这样形容他们的字眼。不管是姬和董，还是后来加入的小耕他们，倒没觉得。<br>&emsp;&emsp;“所谓潦倒，只会来自于你希望有更大的房子。来自于(想要）一个美丽的女人给你做饭。”朋友小河说。<br><br></p><h6 id="傻鸟"><a href="#傻鸟" class="headerlink" title="傻鸟"></a><font face=STKaiti>傻鸟</font></h6><p>&emsp;&emsp;The Nico成立的21年后，我坐在民心河边红砖楼里董亚千的小套间，他们排练过千百次的老房子。这是11月中旬。北方的采暖还未普及到每一户。甭管见到谁，董亚千都要进出一句，“来暖气了吗?”<br>&emsp;&emsp;楼梯过道的小广告好像铲去了一些。屋里屋外的墙皮四处剥落，多到让你没了要扶一扶粘上的欲望。短短的走廊到头便是打通了的客厅和小厅，音箱、声卡、录音器材，胡乱堆地上。<br>&emsp;&emsp;房子中间镶着的钢结构生出斑驳的锈。桌上，废烟盒、酒瓶、打火机，各自占领着一席之地。书架上，黑塞的《悉达多》(也许借自姬赓)，刘慈欣的小说，吉他教材，参差摆放着。看不出来历的水晶奖杯被搁在后头。<br>&emsp;&emsp;十多年前，本地的livehouse(一类具备专业演出场地和高质量音响效果的小型室内场馆)还未出生，玩音乐的年轻人一来二去，,都寻到此，抽烟喝酒，就地而卧，,董宅自动发育成了石家庄音乐青年的原乡。有段子说，除了主人，谁都有这家的钥匙。还有的说，只要扒开门边的水泥砖块就能找到门径——这也成了此后乐队改名的根由之一。<br>&emsp;&emsp;“也不是一开始就成心留在那儿。千儿(董亚千)丢三落四，他找不着就问我们要。要来要去的，干脆留一把搁那儿了。”采访时，史立笑着解释。<br>&emsp;&emsp;房子，人，都老样子。只是曾经的颓顿，到底远了。<br>&emsp;&emsp;2000年，姬赓离开石家庄,去南方上学。走的前几天，董亚千的狗死了。“自此，事情开始变化，这个很酷的世界用了几个简单的例子就证明了我们的不万能。”<br>&emsp;&emsp;在那之前，董亚千已经扛不住，爆脾气，或者一言不发，砸东西。用姬赓的话说,“那是源于他对生活的漠不关心和对音乐的贪得无厌。”<br>&emsp;&emsp;曾经认为自己天分高，足以成为rock star。又觉得周围环境太糟。越急越写不出东西。<br>&emsp;&emsp;十多岁便辍学的董亚千没有焦虑体验。想不上学就不上,想干啥就干啥。等到岁数大一点的时候，进入社会“欸，才发觉你不是这个样子，你不可以这样。没受过那么强的刺激，人一下子就失衡了。”<br>&emsp;&emsp;他们像喜欢自己一样喜欢鸵鸟，但这丝毫不能改变鸵鸟可怜的本质：跑得快却撵不上汽车，有翅膀又飞不起来，鸟蛋大得碍事，养着费劲宰了可惜。简直傻鸟。<br>&emsp;&emsp;姬赓去湖南读书第一年，董亚千跟过去当了一个月陪读。没钱，打一份饭，俩人一块吃。<br>&emsp;&emsp;折腾过了，董亚千跑去了秦皇岛。“那会儿没兴趣琢磨摇滚，就是一个劲儿练琴。我甚至都忌讳弹摇滚乐，光弹爵士、布鲁斯，比如John Scofield。”<br>&emsp;&emsp;他养了好多流浪狗，有的都被拉去宰狗场，生生让他救了回来。“狗是个通人性的东西，它知道你救它。我在海边租了个房子，最多的时候五六条去林子里溜达。”<br>&emsp;&emsp;也就是在那段日子，董亚千写出了富有画面感和冲击力的《秦皇岛》。有歌迷说，“每每听到这首歌，仿佛身处在一座四周是灰蒙的雾气与海水的孤岛上，小号声一起，恍如天光拨散迷雾。然而，并不能知晓，照亮我们的究竟是什么。”<br>&emsp;&emsp;后来，人便回来了。狗带回来一只（没多久死了)，给梁皇岛哥们儿一只，有些狗上山看果园去了。“这就是命运。”他说。<br>&emsp;&emsp;2001年，鼓手张培栋去日本上学。次年鼓手荀亮加入，年底姬赓给乐队改名“万能青年旅店”——想冲冲此前乐队的晦气。“二千和二崔（乐队成员）不停出游，还是以蹭为主要谋生手段。我躲在南方，用白沙烟、低度啤酒和几首老歌打发着时间。没有奇迹发生但也没想象的那么糟糕。”<br><br></p><h6 id="粘稠"><a href="#粘稠" class="headerlink" title="粘稠"></a><font face=STKaiti>粘稠</font></h6><p>&emsp;&emsp;起初董亚干是不习惯中文词的。首专里第一首《不万能的喜剧》写出来，姬赓劝了他足足三天。《十万嬉皮》这首直接点名“董二千先生”的白描作品，他也花了好多天，才终于克服障碍，心无旁骛地唱出来。<br>&emsp;&emsp;台湾音乐人马世芳说，姬赓和董亚千的搭档，好比Lennon 与 McCartney. Jagger与Richards、Morrissey和Marr，两人互为阴阳表里，缺了谁就不是那么回事了。<br>&emsp;&emsp;和他们合作过《音乐肖像》项目的小河也会提到两人之间的关系。“音乐上的好搭档可遇不可求。音乐圈里,最早的是野孩子的）佺和小索，说兄弟太江湖，太白了，说‘夫妻’又有点过。后来五条人的阿茂和仁科，我觉得也特别好。你看姬赓跟亚千一起吃饭聊天、喝酒，也能感觉到他们之间那种特别微妙的东西。亚千不爱表达，我们做《张洲》采访的时候,都是姬赓说话。”<br>&emsp;&emsp;好朋友焦雪雁和他们认识多年。她叫董亚干“圈哥”。“发音像,还有就是调侃嘛。有点傻。圆圈嘛。”<br>&emsp;&emsp;“圈哥对能律的感觉没得说，但他做人实际上特别幼稚，特别容易被人坑。走在路上，一个十块钱三串的佛珠他都能买，做事的逻辑为零。我跟姬赓两个人电话里面最多可以聊到三个小时，像手术一样去解剖一件事情。圈哥没有的。我们去聊一件事，六句话之内解决。这事牛不牛逼、好不好，好、行、干，就这样。”<br>&emsp;&emsp;听得忍不住笑。她接着来：“很多有天才性质的人存在，但是他不见得能碰到一个像姬赓这样，知道他在旋律上有这种与生俱来的东西，还能去帮他砍掉身边所有的威胁。”<br>&emsp;&emsp;什么威胁?骗局?焦雪雁不再言语。只说董亚千没少翻过跟头。<br>&emsp;&emsp;直到2006年，把《秦皇岛》和《揪心的玩笑和漫长的白日梦》写完，他们才重新开始找乐手排练。大提琴有过四个，鼓手五个，吉他三个。从来没有什么正式一说，来去自由。<br>&emsp;&emsp;那会儿加入的杨友耕，年龄17，比另外几个小七八岁、和入行时的董亚千一般大。到今天，姬赓成了“老鸡””，二千成了“老董”。小耕还是小耕。<br>&emsp;&emsp;在众人的眼里，小耕眼神单纯,想法也单纯，人谦虚好学，关键还懂谱，好像是个“派来的使者”。<br>&emsp;&emsp;史立的加入则留下不少经典笑话。董亚千曾在早年受访时形容他“面如重枣，目似朗星，面相还不错”。第一次见面，董把干妈给自己的200块，全掏出来给史立，”然后他就特别感动，后来就龈我家吃住。”<br>&emsp;&emsp;末了发现，这家伙不只烧得一手好川菜，音乐上还特灵。那时爱听爵士的董亚千对小号的感觉是，“除了音儿大没别的。”可史立一吹，给他印象特别深，因为他可以把小号的音量吹得很低，而且很准。<br>&emsp;&emsp;接近今日的万青，就这样成型了。<br>&emsp;&emsp;作曲核心是董亚千。所有的编曲，除了吉他也来自他，其他都是各门乐器自己负责，排练时一起商量。“一个人包办，当然效率特别高，但那个融合度，彼此的关系，就没那么粘稠。”姬赓说。<br>&emsp;&emsp;他举例《秦皇岛》先不是现在这样的编排，特别婉转。“其实音全部一样，但之前小号是一个间奏。写完以后，我们一听，哦，这个旋律特别好，就说把它(小号放到前面吧，色彩会特别不同。高潮提前了。更直接了。”<br>&emsp;&emsp;待在这支乐队11年，小耕说，无他，人和音乐都投缘。对于老爵士和布鲁斯的喜爱，已经说不清谁受谁的影响。比如《在这个行星所有的酒馆》的结尾，空掉第一拍，第二拍进来，形成特别好的一个反差，便是从爵士乐的经验里来。<br>&emsp;&emsp;几个月前，我去他们石家庄棉二生活区附近的新排练厅“探班”。排练登台作品之前，几个人jam(多人即兴）了老长时间。“其实即兴才是爵士的魂对吧。你看我们这几首歌都练了有几千遍，可是每次上台，绝不重样。”史立和小耕说。<br>&emsp;&emsp;“先多练练布鲁斯吧，弹好了这个，思维方式都不同了。”排练完，吃罩饼的饭局上，董亚千认真地对加入不久的吉他手苏雷说。<br>&emsp;&emsp;“每个人跟作品的距离不同。乐手就是要很克制很准确，不会出错。但一个(摇滚）乐队的话，就有好多粗糙的东西。是有温度的。所有人到我们乐队来，我们都希望他变成乐队之一，不要只是一个（录音）乐手。”董亚千告诉我。<br>&emsp;&emsp;陈郁、赵亮、董亚千等人。都提到了King Crimson ( KC）。对这支前卫摇滚乐队的欣赏和借鉴，万青的成员们也几乎是同步的。<br>&emsp;&emsp;“KC复杂、精确，又还保留那个最灵动的东西。古典音乐，爵士乐、摇滚乐，全部融会贯通，其他乐队里我们还没发现有这样的。还会发明乐器,，基本没有什么缺点。”姬赓总结。<br>&emsp;&emsp;所听，即所得。<br>&emsp;&emsp;他提起国内的假假条乐队，“刘与操（假假条主唱）特别聪明，那是我这么多年印象最深，最喜欢的一个新乐队吧。有时候还挺羞愧的，小的时候都喜欢山东Grunge的好些乐队。那个劲儿单纯有力……我们后来可能想要的感觉太多。这个也没办法。”<br><br></p><h6 id="荒谬"><a href="#荒谬" class="headerlink" title="荒谬"></a><font face=STKaiti>荒谬</font></h6><p>&emsp;&emsp;新的排练厅刚刚装好半年多。面积至少得是一二十个董宅。弧形顶相、浅色吸音板和几面大自墙,显得空间格外敞亮。贴场不同了，乐器也比从前帅了好些。<br>&emsp;&emsp;习惯，却是老的。桌上的茶盏、烟盒，拉拉杂杂。姬赓嘴里，不是叼着烟，就是嚼着一口湘潭槟榔——大学时养成的积习，早已传染了整支乐队。<br>&emsp;&emsp;舞台上，姬赓习惯侧身，脚步微弓、似乎带着点微醺和借力感。<br>&emsp;&emsp;“你看他们演了几百场了，到现在还是紧张。”赵亮说，姬赓习惯演出前端点带浓度的饮料。“不光是啤酒，威士忌啊白酒啊，,都直接往台上拎过的。但他掌握一个度，喝到这个度正好，能放得开，又不会乱了阵脚。”<br>&emsp;&emsp;紧张感与生俱来。都见过五六回了，谈话时姬赓也总会把脸别向一边,说几句以后眼睛再慢慢转向对方。好像不这么做，对不住人。但那点不自然又明白地晾了出来。<br>&emsp;&emsp;“喝点酒可能还正常，不喝酒不知道怎么说，特别的怪，特别的荒谬。”酒是他的转圜，也是他的挡板。<br>&emsp;&emsp;眯眯眼的董亚千眼皮老耷拉着。小河说，几年前第一次见到他，“那种不温不火，也不兴奋也不颓丧，话很少。”<br>&emsp;&emsp;死忠歌迷和对互动没要求的，已经接受了舞台上这样的主唱。但那些乍来听的，都要嘀咕，这乐队怎么这么“零交流”、玩范儿?<br>&emsp;&emsp;“都说你们不喜欢听台下合唱？”<br>&emsp;&emsp;“嗨。我们没那么高冷。只是因为台下声音大了，会影响到耳返（监听)。”董亚千说，“不知道在台上该说什么。你不能老被台下那个什么，会出错嘛。得精神集中，少受干扰。”<br>&emsp;&emsp;“也很少和人合影？”<br>&emsp;&emsp;“不是傲气，是不好意思。”姬赓搓搓手，一副“不知该如何解释”的局促。<br>&emsp;&emsp;要澄清的误会远不止这些。“还有说我怎么老穿拖鞋上场，不尊重观众。其实我就是容易出汗，冬天都这样。”我终于明白，为何十一二月史立腿上也只是穿着一条萝卜裤，脚踝每每露着。<br>&emsp;&emsp;这么多年，怎么专场演出这么少?<br>&emsp;&emsp;“专场的话，一定要有新的东西。新东西如果不够，或者自己觉得不够好，就先暂缓。而且，我们还是想要演livehouse嘛，剧场啊体育馆啊，一直都没有考虑。大小也合适、气氛也舒服的，很不好找。这事儿我们一直拧着。”姬赓低下头，眉头皱起。<br>&emsp;&emsp;什么才叫理想的现场呢？<br>&emsp;&emsp;“就是演出状态还是要形成一个……场。就感觉你和观众特别靠近。我们属于,如果自己不在这个气氛里面，就会觉得特别荒谬。觉得这个演出本身没有意义。”<br>&emsp;&emsp;姬赓说，哥儿几个不会表演。不兴奋，人就木了。不是职业的表演者——随时可以演得很嗨的那种，完全不会。这种情况，早些年安排在中下午场的尴尬时刻，常遇到。”在家里弹琴能打九分，到了现场六分都打不到。心理素质不行。这几年慢慢好了。”<br>&emsp;&emsp;十几年下来，乐队编制日趋复杂，除了老几样，大小提琴、长简、曼陀铃都不时登场。在姬展看来,对这种编制的现场，音响具有“决定性的”影响。<br>&emsp;&emsp;“上海音响就很好，声音层次能听出来。去年广州草莓你在的那场（我们表现）就特别差，应该是去年我们演得最差劲的一场。”姬赓有些羞愧。“那个下午被晒得……还想跟你讲，挺不好意思，跑那么远去看，我们莫名其妙稀里糊涂就演完了。可能就是状态不好，有点疲，有点松了，快过年了。”一年之后，他为当时的他们拖歉。<br>&emsp;&emsp;上海演出那天，董亚千介绍新歌：“这三首是各自独立又相互关联的作品。”台下有人大声喊，”你最牛×！你说什么都对！”<br>&emsp;&emsp;底下一片哄笑。笑声里有不屑，也有几分包容。<br>&emsp;&emsp;台下摇放呐喊，乐手向观众招手示意，都与万青风马牛不相及。有人说他们的现场万难酣畅，因为“台上和台下之间从未形成合适的沟通管道”。但这管道，应在一点一点地扩大。<br>&emsp;&emsp;上海和成都渤海洗雷音专场，董亚千在一气唱完三首新曲后，嘱咐在场歌迷，尊重尚未制作完成的专辑，不要上传视频。几个月里,果然不见流出。”说了还挺管用。”专场之后他和矩摄总结，”看来以后该说还得说。”<br>&emsp;&emsp;这和早年的“靴腿”效应形成了一种有趣的呼应。当年尚未发首专时，网络上充斥着歌迷在各种live录制的万青现场录像，完了十多块一张拿出去卖。英文里管这叫 bootleg，意即“未经授权、私自发行的出版品”。像素很渣，但索求、分享者众。乐队当时既不反对，也不鼓励——觉得有些效果不好，怪丢人。<br>&emsp;&emsp;几乎是一夜之间，韩寒、罗永浩等人发微博力推万青，首专获得华语音乐传媒大奖，同时获得乐迷和专业人士的欢迎，“蹿红”来得有些不可思议。一位叫刘思远的音乐人分析：万青的首专，赶上2010年前后中国数字音乐，新媒体传播的突然发达。这支好乐队出来，恰恰是在年轻人有了顺畅的信息接收和传播渠道之时，二者同步。“消费者可以这么自由地用手机寻找和接受好的音乐。他们是跟这个时代一起走的。这是这些年轻乐迷的青春记忆里非常幸运的一点。在自媒体时代之前，是不太能想象的。比如左小(祖咒),木马(乐队)，当年的纸媒和网络都不会传插。对年轻人而言，这些像传说一样。但这个年代不同了。机会均等。”<br>&emsp;&emsp;即使是基于“十年磨一剑”，姬赓也觉得,那时万青的爆火，有很大的随机性。<br>&emsp;&emsp;“这些人(不止万青)，从少年时为这些事儿努力，到最后连个合理的，怎么说，呈现的机会都没有，这个是不正常的。现在好与不好，大多数摇滚人还是没有钱，没有什么收入。而且之后怎么样也不好说，没准哪天我们就……这可能性是很大的。”<br>&emsp;&emsp;2014年，代表摩登天空（简称“摩登”)签下万青的公司高管乌莉雅素和他们足足喝了一箱酒，才签下合同。<br>&emsp;&emsp;“后来才知道那酒过期了。”一切皆成笑谈。乌莉严肃地强调，“他们一定是先建立信任才会跟你合作。”<br>&emsp;&emsp;她和摩登天空的掌舵人沈黎晖都用了“难搞”这个词来形容万青。<br>&emsp;&emsp;做独立音乐的，很多人都“难搞”，不奇怪吧。沈黎晖还是微笑着，“他们，怪得很。”<br>&emsp;&emsp;乌莉说，很多人来签摩登。是希望要有一个保护伞——上草莓（摩登公司打造的户外音乐节）。“但是万青进来，不是说我要上草莓。他只说有人打理（演出事务）就行呗。而且他们也是第一个说不需要公司给我预付。”<br>&emsp;&emsp;“他说拿了公司预付，感觉就是欠公司钱，或者欠公司很多东西，他们觉得很不自在。所以这就是跟所谓商业逻辑挺相反的一个思路。但在他们身上呢就不奇怪,，这种事情经常发生。”沈黎晖解释。<br>&emsp;&emsp;为了保证做唱片时的全部独立，万青和摩登签的只是演出约，不是唱片约。沈黎晖说，这样的乐队，在全公司，也不超过五支。<br>&emsp;&emsp;在他眼里，万青有点嬉皮，有点“根源”，然后又有点人文，很难替代。“他们没有生活在北京这个名利场里面，他们远离了这里，有自己的节奏。他们的看法。他们跟这个世界打交道的方式，我觉得很有意思……我觉得他们会成为摩登（一份子），也会改变摩登一些东西。”<br><br></p><h6 id="根源"><a href="#根源" class="headerlink" title="根源"></a><font face=STKaiti>根源</font></h6><p>&emsp;&emsp;“远离”北京的石家庄，如今乘坐高铁只需要不到一个半小时。<br>&emsp;&emsp;几年前，阿爽大学一毕业，工作不顺心，便辞了职，坐火车旅游了一趟。其中的石家庄意义特殊，离开前她还抽空在火车站写了明信片给张蓓——上面是万青的歌词。<br>&emsp;&emsp;从河南到河北，她眼瞅着窗子外面，天色一点一点发乌发黄，视线模糊。<br>&emsp;&emsp;到地儿了。人民商场、八角柜台、师大附中、药厂……早在小本儿上抄好的“标志性地点”，她一个一个“踩”，一处处拍照。<br>&emsp;&emsp;“本来带着朝圣心情，后来发现，非常平淡。很萧瑟。百货商店，改名字了。坐车经过也不知道。华药(药厂)我去了，像遗迹。”<br>&emsp;&emsp;董亚千在方北路上的房子，就挨着华药宿舍区。离发小姬赓住的师大家属院不过一两条街。三十多年，他们的活动范围就在这两三平方公里内。<br>&emsp;&emsp;1958年建成投产的华药，青霉素等各类杭生素是主打药品。姬赓记得，厂区和宿舍区的空气里天天飘着一股特别的味道。”像玉米发酵的那股味儿。不是特剌鼻，说不上，就跟别的味儿不一样。”<br>&emsp;&emsp;据说常闻华药的怪味能预防感冒和慢性咽炎。不知是否有科学依据。可以肯定的是，每到饭点。你总能透过围栏，目睹一片片的大褂端着不锈钢饭盒打饭的药厂固定一景。曾经自诩“亚洲最大国企”，华药工人的脸上写着装不出来的自豪。<br>&emsp;&emsp;“我们那个发酵罐，当时全国最大，,苏联人援建的。现在说爱厂、爱单位，都是被感动。那时是真的以厂为荣。发棉袄，发卫生纸，米面油。啥都发。管饭。住也很好，我们都买过公司股票。”在华药干了一辈子的退休老职工白阿姨回忆着往昔，乐呵呵地。<br>&emsp;&emsp;“现在挣不了钱了，没人来。”白姨说。<br>&emsp;&emsp;白姨的朋友拍了数月前厂里老车间拆迁前的照片：硕大的罐子，管道横竖林立，瓦砾遍地，空无一人。<br>&emsp;&emsp;“可我们还是有烤火费呢，你知道吧。”她用手指指那一边，嘴一努，“从棉一到棉四,他们的工资少得可怜呢。”<br>&emsp;&emsp;棉纺业曾是制药以外这座城市能顶半边天的支柱产业。如今，从棉一到棉七的厂区，悉数成为商品房或待价而沽的房企”必争之地”。<br>&emsp;&emsp;“好多好多年前就不行了，九几年可能就不行了，挺早开始就走下坡，最早下岗的开始。”中午，站在不远处的街口，姬赓说。<br>&emsp;&emsp;他说母亲以前就在纺织工业学校工作——那会儿还有这种专门的学校去为这个产业输送人。等到1990年代，就被别的学校合并了。从纺织工业到连带的行业全都没落。<br>&emsp;&emsp;第二天一早，我和董亚千道别，骑车从他家到棉三、棉四生活区，也不到10分钟。<br>&emsp;&emsp;不像药厂宿舍区的沉寂，棉纺厂宿舍的冬日早市一片热气腾腾。路口，运货车刚卸下当季菜，成捆的大葱和胡萝卜哧溜一地，等待着买家摘走。从南头走到北头，葱花饼、豆腐、烧饼、糯米蛋糕、拔丝蛋糕，一溜溜地沿街摆着，诱人馋虫。“现包的茴香鸡蛋馅儿”，“糖炒栗子啦”，“小米会说话，馒头五元11个”……一片带着笑意和挑衅的叫卖声里，婆婆爷爷们推着自行车，提着菜筐，慢慢挪着步子。隔不多久就得欠个身、踩在他人的光影里，继续赶各自的集。<br>&emsp;&amp;emsp姬赓所叹息的局面，不在他们的焦虑清单上。“暖气管道裂了，没人管，你帮我们反映反映？”好几位老人家看着我，眼神里满是期待。<br>&emsp;&emsp;“对头，就是这个样子。”在重庆长大的张蓓，看到我手机上的华药车间照片时说，她从小生活在军工厂一带，所见无差。<br>&emsp;&emsp;回过头看昔日的万青踩点之旅，阿爽笑笑，“那时候年少轻狂，现在大概再不会单为乐队去一个城市一日游了。可是有灵魂的人，会把这些发生的历史留下来。做成专辑也好，写成书也好，这是值得尊敬和感谢的。”<br>&emsp;&emsp;对于长于斯的姬赓、董亚千和史立，还有在此成家的秦皇岛人杨友耕，待在石家庄的理由没多高尚，没多复杂。<br><br></p><h6 id="飞起来-沉下去"><a href="#飞起来-沉下去" class="headerlink" title="飞起来,沉下去"></a><font face=STKaiti>飞起来,沉下去</font></h6><p>&emsp;&emsp;随着年岁渐长，许多人会用适合自己的方式把荷尔蒙的消退、价值观的反复给“镇压”住。但在赵亮看来，董亚千的“彼得潘人格”(不愿长大）不会把那些灰色地带压住（或许他也不想压住)。姬赓的写词、喝大酒是一种纾解。至于董亚千，他好像除了吉他，对其他东西都没什么依赖性——除了摩托。<br>&emsp;&emsp;一起吃罩饼的那天，董亚千和小耕几个说起老戏骨安东尼·霍普金斯主演的电影《世上最快的印第安摩托》，眉飞色舞。<br>&emsp;&emsp;新西兰人伯特·芒罗在上世纪70年代以近七旬的高龄和亲自改装的爱车，创造了1000ec摩托的最快速度纪录,保持至今。电影里，“正牌”赛车手们看到菜鸟芒罗那台各方面都不达标的破古董笑掉了大牙，他们奚落芒罗用餐刀休整的轮胎、厨房门板做的外壳、白兰地木塞塞着的油箱，不留情面地羞辱他“你老了”。<br>&emsp;&emsp;老董和小耕却连声赞道，“太帅了，这老头儿!“<br>&emsp;&emsp;董家靠阳台窗的墙上，贴着英国老牌摩托品牌皇家恩菲尔德的图片。它曾是帝国的元老车型，历史可追流到两次世界大战期间。吊诡的是，几乎和华药、国棉的路径一样，深受其他车型冲击及别的原因制约，皇家恩菲尔德英国工厂在上世纪六七十年代便关门了。<br>&emsp;&emsp;而现在，改装版的真家伙就摆在万青排练厅的一侧。还有长油箱、高脚踏的咖啡、宝马等复古车，像排练时忠实的听众，一字排开。<br>&emsp;&emsp;本职服装设计的老杨，身材挺拔，老帅哥一枚。喜爱动手改装摩托的他，已经和董亚千搭伙了几年。两个人在附近小区的一个老车间里，研磨、讨论，几乎全套工序自己动手。<br>&emsp;&emsp;“亚千很有想法，喜欢与众不同。那份艺术感和认真钻研的劲儿，和做音乐很像。”老松指着面前的R100，“你看这个有咖啡典型的猪头罩，前导流罩，趴式车座。时尚又古老。我们自己改了一个飞机驾驶舱式的仪麦盘。有电压、转速、慢速，很有科技感。他很满意。”<br>&emsp;&emsp;《现代画报》报道，三四年前，董亚千看到哥们儿翻新了一台1980年代的嘉陵70，开始对摩托产生浓烈的兴趣。紧接着他花几百块买了一明1985年的嘉陵。重新做漆，骑了起来。接着又入手2007年的皇家菲尔德。小耕则直接买了捷克斯洛伐克产的佳娃150，“两冲程的发动机，冒浓烟那种，特复古。”姬赓也弄了一辆雅马哈SR400。史立没那么疯狂，是老的嘉陵125。四个人，已然组成了摩托车队。<br>&emsp;&emsp;但对改装最上心的，还是董亚千。<br>&emsp;&emsp;改装一部车，怎么都得半年、一年。设计、绘图、找人加工，从无到有，很难，也乐趣无穷。在董亚干眼里，摩托车不仅仅只是一个机器，它更是一种美学和科学表达。<br>&emsp;&emsp;在他家客厅，他就地拿起一个钣金件给我演示:“用纸，先要做纸模，感觉大小。出了样后就把拓样剪裁，剪裁完后塑形时，用英国螺压弯。这上面下面都有一个轮子，上下夹紧，轮子上有不同的弧度，就像擀面一样。你把这个铝板搭成弯的了，好多地方还得用锤子敲。做得不合适还得焊接，焊接完还得打磨就看不出来了。这里面的想法,有点像飞机-….…”<br>&emsp;&emsp;如果不是赶去演出，一向寡言的董亚千估计可以就这个话题说个把钟头。<br>&emsp;&emsp;姬赓以前常骑摩托去大学上班，“舒服、方便、自由、便宜”，人和机械的关系也让他着迷。董亚千更喜欢骑到山里，速度并不是追求的唯一，他享受的是“浑然忘却所有,一切都跟自己无关”的那种超然。<br>&emsp;&emsp;“注意力很集中,，世界上仿佛只有你和这台摩托。”<br>&emsp;&emsp;玩得最痴的董亚千和小耕都受过伤，小耕是高速上差点撞到董。而董亚千的伤更戏剧化：2013年的张北音乐节,他在山上骑马，马越跑越快，眼看悬崖就在眼前。<br>&emsp;&emsp;董亚千觉得马要像摩托一样冲到悬崖里了，他立刻跳了马——形同跳车。<br>&emsp;&emsp;这两年，几个人基本没法骑这些老帅车了，不是因为受伤后遗症，而是禁摩令。<br>&emsp;&emsp;姬赓和哥儿几个，找到浸淫艺术圈的老友焦雪雁,，开起了画廊。这也不是玩摩托受限的替代。“先做一些好玩的艺术项目，过几年再看一看这种形态和发展怎么样。”<br>&emsp;&emsp;在焦雪雁看来.,首专阶段的万青,就是在微一个真实的自我描述,青春期剖白。<br>&emsp;&emsp;当代艺术这个充满新思维和触角、职业化程度又比较高的领域,给姬康等人打开了一个新世界。<br>&emsp;&emsp;“发布首专之后的万青，生活没有发生真刀真枪的变化，依然是在一个真空里面。姬赓给人感觉是，他像在一团迷雾里面，努力要看透，还要钻出来。他们可能有在音乐里面还没有完全表达出的东西。借由这个空间，扩充了观察世界的方式，也跟更多的人发生了关系。”<br>&emsp;&emsp;“待在石家庄是有点保守，这几本来就比较闭塞。”姬展姬赓同意焦雪雁所说，虽然也没觉得这是个多大的问题。“有点矛盾。和人联系太多了没用，没意义，又不喜欢，不是那样的人。但如果毫无联系，就会显得很保守，很笨拙。没有健康的人际交流，自己很明显的问题可能看不到。”<br>&emsp;&emsp;画廊在北京草场地，狭小的门布满铁锈，拉开之后会走进一个由乌黑墙面与白色地板组成的不规则空间。<br>&emsp;&emsp;画廊首展取名“世界砼””。“砼”是1953年的新造汉字，意为水泥，更确切地说是混凝土，被普遍使用在建筑工程学中。“水泥巨大的量使它成为了人类生活中最基础的存在物，水泥无处不在，尤其是在中国，水泥给我们提供了一种最低限度的现实感，一种人类早已不再拥有纯粹自然性的现实感。”十多位青年艺术家利用各种材质诠释他们对这一物质与背后世界的理解。<br>&emsp;&emsp;和太行之旅可有关联？姬赓笑说纯属巧合，“都是鲍栋（策展人）的创意。”<br>&emsp;&emsp;选择艺术家和作品的尺度，是他们眼中认定的价值——无论对方是否留过学，是否年轻，是否时髦。有趣是最高标准。他提到合作过的张鼎和“小天才”蒋竹韵，前者能把握时代脉络，后者对声音的质感和声音背后的生成逻辑都有自己的独特见解。<br>&emsp;&emsp;“趣味就是没有历史包袱，纯粹的诗意或者是很干净的一个才华，其他没有什么界限，或者说年龄性别。我说不清楚，但我能感觉到。这就跟选音乐是一样的，特别干净的音乐，很透，很清澈，会发光。”</p><h6 id="生活"><a href="#生活" class="headerlink" title="生活"></a><font face=STKaiti>生活</font></h6><p>&emsp;&emsp;四五年前，姬赓当了父亲，写歌中断了一两年。<br>&emsp;&emsp;“那几年真是生活变化太大了，压力一下子来了。时间特别碎，还需要挺强的自律，才能有点效率，否则就是一塌糊涂，每天不知道在干嘛。”<br>&emsp;&emsp;调整是必须的：早起、排练形成制度。<br>&emsp;&emsp;而今，写歌、排练演出、教书、开画郎，还带孩子、会会朋友，喝酒品茶，生活完全称得上丰富了。<br>&emsp;&emsp;“是很丰富呵，太丰富了。”这么一罗列，姬赓笑了。“但我哪样也不是陷得特别深，乐队这边算投入精力最大的了。主要还是积累。审美没有进步，低水平的重复没什么意义。这几年主要忙着生活，干干这些事。”<br>&emsp;&emsp;说到中年危机这样的词儿，他有点愕然。<br>&emsp;&emsp;“我不明白中年危机是怎么回事儿，因为一直在危机里，从青春期就是在危机里，无忧无虑的时间很短。那个(所谓的万能,年轻的无限可能性)，很早在我们心里面就幻灭了。就是自己想做的事儿，和条件、和才华之间的距高，挺早就没那么自信了。全面的悲观。”<br>&emsp;&emsp;在陈郁看来，姬赓敏感而聪明。他不会沉溺在这种情绪里头，更不会把这个当成一种优越性，自我标榜的东西。<br>&emsp;&emsp;采访了这么久，姬赓说得最多的就是“该怎么着就怎么着”。一星期前我们见面，他告诉我，棉二排练厅的房子产权好像有变动，又得折腾新地儿。<br>&emsp;&emsp;首专的录音备受好评，但他们一直对录音的空间感不满意。“数码时代就会有电子感。塑料味儿。我们一直想要的是很暖、结实的那种声音。所以我就想要是能找到一个大的地方，自然声场就很好，后期不再过多地修饰。”看来，这计划还得随着条件变化而变动。<br>&emsp;&emsp;各种裂变、消逝，如锚兀白扔出，扎在不同的角落。<br>&emsp;&emsp;2015年，他们钟爱并翻弹过的Stone Temple Pilots的主创去世，乐队难过了好一阵子。聊起这，董亚千叹了口气，“那个年代的人都快死绝了。我靠。”<br>&emsp;&emsp;他在秦皇岛住过的房子，从前无比荒凉，现在大楼都塞满了。树林子也没了。<br>&emsp;&emsp;对银翼杀手和A，笃信外星人的董亚千都很好奇。“你说将来会不会全都AI写文章了？”他间我，又像问自己。“要有艺术性的，暂时还得靠人哈。”<br>&emsp;&emsp;“演出市场这两年还是挺好的，但是我不知道别的行业怎么样。”董亚千起身,挠挠头。<br>&emsp;&emsp;姬赓听到我的转述。嘴上咧开一道轻微的褶子。“行业？！这家伙现在都会说这词儿了。真是正常了。那些年（他心情比现在差多了〕….….”<br><br><br><br></p><h5 id="《此生再不回太行》（访谈：“流失确实是存在的”）"><a href="#《此生再不回太行》（访谈：“流失确实是存在的”）" class="headerlink" title="《此生再不回太行》（访谈：“流失确实是存在的”）"></a>《此生再不回太行》（访谈：“流失确实是存在的”）</h5><p>何平，姬赓<br><br></p><p><font face=STKaiti><br>&emsp;&emsp;何平：“花城关注”做到现在，已经两年了。这是准备时间最长的一个专题，也是我做得最艰难的个专题。记得2016年和朱燕玲主编设想这个栏目的时候，就有传统文学之外各种艺术激发“文学”可能性的专题，“歌与诗”自然是首先想到的，另外还有电影。后来做好第一个专题——“导演的小说”，鲍勃·迪伦获得了诺贝尔文学奖，怕别人说我们跟风，就把“歌与诗”这个专题停下来了。两年过去了，现在回过头看，这两年，因为有鲍勃·迪伦做参照系，可以让我们好好想想“歌与诗”的关系。我是去年春天和你联系上的，我查了下我们的微信记录，恰好是《南方人物周刊》邓郁那篇长文《出入太行，骤雨重山》出来的时刻。这一年，我“听”“读”了能找到的你们所有的“歌”，包括现场录像，如果让我下一个判断，如果也确实存在着先入为主的歌与诗的区分，我肯定地说你的那些“歌”就是“诗”，我不知道你是不是同意我这个判断？</font><br><br></p><p>&emsp;&emsp;姬赓：这个判断本身已经是对这些歌词很高的评价了，先谢过。前些年也想过这个问题，老实说我现在仍然不确定。<br><br></p><p><font face=STKaiti><br>&emsp;&emsp;何平：记得最早的时候，我和你谈这个专题的设想，你说：“只是歌词写作受到旋律气氛影响非常大，所以，我一直也不太会把它们看作单纯文学文本。”我理解你的意思，歌词是整个音乐图景的一部分，它和一首完成的歌、和歌手、和乐队，甚至和现场是彼此共生彼此生发的，歌词的文学意义也应该在此完整的音乐图景想象中才能充分被发明和揭发。我也注意到，确实有些歌词对整个音乐图景依赖性很强，但也有些歌词可以独立抽离出来，是自足的文学。你的歌词在我看来就是可分可合自足独立的，这就是我为什么说你的歌词是“诗”。换句话说，我并不认为所有的歌词都能独立自足成为“诗”。你有英美文学的教育背景，有完整的西方文学谱系，更重要的你是“万能青年旅店”重要一员，对歌与诗的问题你是怎么理解的?</font><br><br></p><p>&emsp;&emsp;姬赓：对我来说,这两者成立的条件是不同的，歌词除了考虑语言本身的节奏之外还要符合音乐部分的律动。这两个律动有时叠加、支撑，有时则发生冲突。我们的工作方式是先写曲，再填词，之后微调，使二者融合。但在这个过程中，作为乐队，要关心的第一件事是它能不能被歌唱而不是诵读。而且汉语发音吐字的特点使中文歌曲在音乐部分可以让步的空间很小，所以更多时候要做的是歌词语义和韵律上的妥协。其间流失掉的信息我也不知道该如何去描述，但这种流失确实是在发生的。<br>&emsp;&emsp;所以，我的经验是，与抽离了旋律的歌词相比，好的诗歌保留更天然的语言气息，致密而悠长。而歌词，在被当作诗去读的时候，有些语句会令人感到僵硬滞重。至于我的某些词在被从曲中抽离出之后仍然自足，可能是因为我不能接受仅作为旋律填充物而自身并不具有表达价值的文字。为了尽可能多地保留重要的文字信息和音乐信息，我们花在词曲磨合上的时间会特别多，产量也就很低。这种困扰对词曲一人完成的创作者会小一些。<br><br></p><p><font face=STKaiti><br>&emsp;&emsp;何平：因为“歌与诗”是文学期刊的一个独立专题，而不是一般意义上诗人的诗歌混排，读者读你的这些作为歌词存在过的——特殊的“诗”，肯定会再去听你的歌，因此可以想象你这些歌词的文学性从“看(读)”到“听”的迁移和增殖。而从我们的初衷也是希望唤起文学界重新认识诗歌和音乐的关系，你是如何看待这个问题的。</font><br><br></p><p>&emsp;&emsp;姬赓：好的文字有节奏。在我的阅读经验里，无论是在读诗或小说甚至一些哲学著作时，经常能感受到文字节奏和身体的共振。它与语义无关，显然是音乐性的。同样，在根据旋律写歌词的时候，有时会察觉旋律似乎也带有一种微弱但执拗的叙事意图。当这种意图不被理睬和回应的时候，词曲融合度就很低，听起来蹩脚。我不知道这是不是可以被视为音乐旋律的文学性，但至少“诗”与“歌”，“读”与“听”的关系值得被认识。<br><br></p><p><font face=STKaiti><br>&emsp;&emsp;何平：回到你的歌词，你对时间有一种尖锐的敏感和痛感。你几乎所有的作品都存在一个无法逆转的过去、现在和未来的时间矢量。因此，无论是老工业城市石家庄，还是冀西南太行山，都是时间上的空间。我不会简单附会你的作品和时代之间的关系，而是从“个人史诗”的角度理解这些文字，这些时间，这些空间都是和你的生命休戚与共的。</font><br><br></p><p>&emsp;&emsp;姬赓：是的，于我而言，同一空间在不同的时间里，色彩、气息、意味是完全不同的，很多平常的场景或人在某个时间的样子对我好像有格外的意义，很难绕开，所以就试图把他们记录下来。<br><br></p><p><font face=STKaiti><br>&emsp;&emsp;何平：其实，时同也才几十年，空间也就几百里，但你却在这几十年，几百里的时空写出了剧变的“时刻”，这也是我的同时代。</font><br><br></p><p>&emsp;&emsp;姬赓：每个个体对同一时代的见知多少会有共通的部分。<br><br></p><p><font face=STKaiti><br>&emsp;&emsp;何平：“不万能的喜剧”和“揪心的玩笑与漫长的白日梦”这两个题目，我认为对专辑《万能青年旅店》具有命名性：一定意义上，也是你自己对这个时代某些部分的命名。</font><br><br></p><p>&emsp;&emsp;姬赓：可以这么说。《不万能的喜剧》是我们真正意义上的第一首歌，虽然只两句词，但它像是一个阀门。<br><br></p><p><font face=STKaiti><br>&emsp;&emsp;何平：像《大石碎胸口》《杀死一个石家庄人》《揪心的玩笑与漫长的白日梦》等，你的许多作品都有《史记·列传》的传神和力量，这种高度的典型能力和“诗史”力量恰恰是今天许多诗歌所不具备的，也是我特别珍视你作品的部分。</font><br><br></p><p>&emsp;&emsp;姬赓：可能与性格有关吧，我大概算是个内向的人，愤慨和温情激荡的时候，没有太多直接或即时的出口。那只好让这些经验沉积，慢慢提炼之后留下只言片语，它的密度会比较大，诚实，有力量，缺点是沉重，不好消化。但是在那些年里，对我来说歌词似乎只有这样一种写法。有几次也试着轻快起来，最后还是失败了。<br><br></p><p><font face=STKaiti><br>&emsp;&emsp;何平：从《万能青年旅店》到《冀西南林路行》,你歌词的遣词造句有着微妙的变化，这是一种自然蜕变，还是有意为之?</font><br><br></p><p>&emsp;&emsp;姬赓：歌词的语气和我平时说话是不一样的，我猜它的形成与音乐部分有很大的关联(这也是我对第一个问题不确定的原因)，新作品在音乐部分做了更多的尝试，歌词也就随之改变。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;书接上回，本篇摘录了南方人物周刊、花城关注等媒体对于万能青年旅店的采访，或许对深入了解该乐队有一定帮助。&lt;br&gt;</summary>
    
    
    
    <category term="随想录" scheme="https://atffang.github.io/categories/%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>《冀西南林路行》简析</title>
    <link href="https://atffang.github.io/2023/08/16/%E3%80%8A%E5%86%80%E8%A5%BF%E5%8D%97%E6%9E%97%E8%B7%AF%E8%A1%8C%E3%80%8B%E7%AE%80%E6%9E%90/"/>
    <id>https://atffang.github.io/2023/08/16/%E3%80%8A%E5%86%80%E8%A5%BF%E5%8D%97%E6%9E%97%E8%B7%AF%E8%A1%8C%E3%80%8B%E7%AE%80%E6%9E%90/</id>
    <published>2023-08-16T11:05:48.000Z</published>
    <updated>2023-08-19T08:08:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>炫耀一下我的实体专辑，以及对于全专作词的分析。<br><span id="more"></span><br>&emsp;&emsp;2015年「河北墨麒麟」专场，万能青年旅店第二张专辑显露雏形，此时距乐队首张同名专辑已过去五年。“墨麒麟”这一形象来自封神演义，龙头麋身马蹄牛尾，乘云腾雾而行，隐秘而孤独，赋予了尚未出世的转移浓重的神秘主义色彩。又是一个五年，2020年末，《冀西南林路行》(<em>Inside The Cable Temple</em>)发行。词作者姬赓附上了如下一段话：</p><p><img align="left" width=62% src="https://s2.loli.net/2023/08/17/4jptPahmbkKzJAs.webp" style="margin-right: 5px;margin-top: 10px;margin-buttom:20px;"><font face=STKaiti>&emsp;&emsp;发端似乎在2013年<br>　　一次出河北去西北<br>　　火车钻入太行山腹<br>　　景色突然叠加变幻<br>　　山脚的村庄还运行着古老仁慈的秩序<br>　　而对面山腰<br>　　炸药歌舞团的表演拉开大幕<br>　　神话握手现代化<br>　　启动了荒原上最悲怆的谜语<br>　　/<br>　　那一次眩晕令人至今难忘<br>　　之后就开始旷日持久的漫游解谜<br>　　偶尔是美妙的精神游艺<br>　　更多时候则不得不面对<br>　　内部的洪水和外部的歧路<br>　　像一个胸闷的哑巴<br>　　打不赢就大醉一场<br>　　丢人并且伤神<br>　　/<br>　　漫游搞复杂了，抬头已是2020<br>　　这几年间，气象风物变化急促<br>　　几人仍眼睛明亮，几人已失了魂？<br>　　感谢大家还有耐心听完这样一张唱片<br>　　轨迹和谜底都录在这44分22秒之中<br>　　各位可自助提取<br>　　/<br>　　西郊有密林 助君出重围</font></p><p>&emsp;&emsp;实体专辑在线上上架了多次，无奈没有留心，一直没抢到。今年四月，终于在万青石家庄专场演出时购入，也算是圆了许久未能完成的愿望。冀西南林路行比传统专辑外壳要大一圈，仅使用黑色与土黄两种配色，厚度可达1.5cm，主要由歌词本贡献。该歌词本制作可谓及其考究，采用了折页设计，通体散发着纸张与油墨的香气，正面为中英文歌词，背面为插画。歌词、插画无不诉说了这张专辑古朴的气概：中文歌词是拼字而成，即采用了不同书体的字拼接、布局；而插图设计源于对拓片文物中形象的解构再重组。《冀西南林路行》是国内少有的概念专辑，和著名的月之暗面一样。整轨可被拆分为八首单曲：早  泥河  平等云雾  采石  山雀  绕越  河北墨麒麟  郊眠寺，其中造、平等云雾与绕月为纯器乐曲目。<br><br><img align="left" width=40% src="https://s2.loli.net/2023/08/17/Mh9etWbiPvj41cf.jpg" style="margin-right: 10px;margin-top: 10px;margin-buttom:20px;">&emsp;&emsp;专辑的封面即为一只卧着的墨麒麟。根据封神演义所述，闻仲随其恩师金灵圣母学艺五十载，在艺成下山时，金灵圣母共赐了闻仲两件宝贝，兵器雌雄鞭和坐骑墨麒麟。其中对墨麒麟的评价为：<br>“<strong>四足风云声响亮，麟生雾彩映金光；周游天下须臾至，方显玄门道术昌。</strong>”<br>&emsp;&emsp;多么神气！<br>&emsp;&emsp;墨麒麟概念的引入让我想起了一专时期频繁出现在海报上的鸵鸟形象。姬赓老师赞誉鸵鸟说：<br>“对于鸵鸟我一直认为是种万能的动物，能飞能跑能下蛋，长得又帅，简直万能。曾经我对鸵鸟十分着迷，并幻想有一天能骑着只威风的鸵鸟穿过石家庄破烂的街道，与那些面无表情的人们对视，唤起他们心底隐秘的温情。“<br>&emsp;&emsp;由此可见，墨麒麟也是一只万能的神兽，它在云雾中穿梭，俯视华夏土地的各个角落，时而发出冲天的叫声，时而抖擞鳞片上的金光。跟随墨麒麟的视角，新专的号角由太行山展开。<br><br></p><h5 id="《早》"><a href="#《早》" class="headerlink" title="《早》"></a>《早》</h5><p>&emsp;&emsp;低沉的小号吹响，彰示新时代的来临。《早》由小号、次中音萨克斯、中音萨克斯和上低音萨克斯缓缓推出，温暖祥和，仿佛日光注入太行山，唤醒山脉与众生万物。个人认为，《冀西南林路行》中众多线索都指引我们用时代的眼光来解读他，那么《早》或许指代的是新中国的建立。随着编钟似的浑厚拨弦声，浓雾渐散，专辑的内容拉开序幕。<br><br></p><h5 id="《泥河》"><a href="#《泥河》" class="headerlink" title="《泥河》"></a>《泥河》</h5><p><img align="left" width=100% src="https://s2.loli.net/2023/08/17/Eaj3KOBoePHGsdS.jpg" style="margin-right: 10px;margin-top: 10px;margin-buttom:20px;"></p><font face=STKaiti>骤雨重山 将甘苦注入他 气息交换 吞石铁吐泥沙 水鸟风帆 跟随着他舒展 知觉情感 在形成严格而缓慢 可听到雷声隐隐 可感到夏日来临 可听到雷声隐隐 可感到夏日来临 高地奔流 掠山光过太行 平原午休 纵鱼儿跃夕阳 明日壮阔 就奋力托帆船 明日难测 就放任潮流划水道 可听到雷声隐隐 可感到未知来临 可听到雷声隐隐 可感到未知来临 不速之客 一贫如洗 劳动 饮酒 叹息 夜宿河床枕露珠 测量绘图 爆破合围 加固文明幻景 开山拦河建水库 泥沙沉积 运动停息 随后水鸟隐迹 人造湖泊无颜色 可听到雷声阵阵 可感到危险来临 可听到雷声阵阵 可感到危险来临 乌云汇合 乌云高空踏步 再生泥河 就投身激流冲水坝 乌云汇合 乌云高空踏步 再生泥河 就投身激流冲水坝 乌云汇合 乌云高空踏步 再生泥河 就投身激流冲水坝 可听到雷声滚滚 可感到怒潮来临 可听到雷声滚滚 可感到怒潮来临</font><p>&emsp;&emsp;歌词的第一句“骤雨重山”对应了2018年南方人物周刊的专访《出入太行，骤雨重山》，姬赓和董亚千在报道中说，作品的缘起是太行山与水泥厂：</p><p><font  face=STKaiti>&emsp;&emsp;井陉县，耕地稀少，黑白分明——一列挂载了数十节车厢的火车在矿区装满煤炭，中途俯视右侧的县城，汇入这个国家的铁路主干道；而在此之前，还要经过一段漫山遍野白成一道的地方，那里竖着一块白灰覆盖的牌子：建设中国钙都。人们向下挖掘煤炭，向上崩山采石，炼制白色钙产品。一黑一白，不是琴键，而是一整个县的营生，还有县里人的两个肺。</font><br>&emsp;&emsp;结合姬赓的叙述，我们可以窥见《泥河》字面上描绘的是对于太行山的开采与建设。“吞石铁吐泥沙”即用太行山的血肉资源交换社会发展的物质，而“知觉情感 在形成严格而缓慢”意指社会精神文明的缓慢发展。“雷声”在全文中穿插往复出现多次，雷声隐隐-雷声阵阵-雷声滚滚构筑了整个故事的时间线，从“平原午休 纵鱼儿跃夕阳”时的隐约雷声，到“开山拦河建水库”时的的阵阵雷声，再到“乌云汇合”后的滚滚雷声，可以见得夏日的暴雨怒潮由这三个阶段分别暗示、导致与加剧。<br>&emsp;&emsp;在分别剖析这三个阶段之前，我们还要弄清一个问题：太行山代表什么？<br>&emsp;&emsp;许多人都以环保主义为出发点解析这张专辑，是因为歌词多有描述对于太行山（自然资源）的开发。实际上，太行又是人民的一个寓指，劳动者与太行山，同样都是用血肉换取社会发展动力，这一观点在下一曲《采石》中也可以得到证实。<br>&emsp;&emsp;1984年，《人民日报》一篇标题为《牵住了「牛鼻子」——罗庄公社乡镇企业纪事》的文章创造出了“人矿”这一让人唏嘘却又无比贴切的概念。中华五千年，人口资源一直是封建王朝开采并赖以延续的矿藏，一般来说，统治阶级对人口生产力的索取与劳动者的生存维持着微妙的平衡，但当这一索取超过了某个阈值时，必然会导致王朝的根基不稳，乃至覆灭。<br>&emsp;&emsp;回到那三个阶段，“不速之客”的来临意味着缓慢、自然发展的第一阶段结束，统治者对于太行山开始了系统性的开发与建设。先是“爆破”、“开山拦河建水库”，但实际效果仅仅是“加固文明幻景”；随后又“泥沙沉积 运动停息”，忽然停止了破坏与开发，遗留下“水鸟隐迹 人造湖泊无颜色”的残局。第二阶段中，统治者的无知与强暴给太行，也就是人民带来了严重的动荡，其中包括了大量无意义的社会政治运动，也留下了满目疮痍的政治遗产。统治者对于生产的扰乱与对于劳动者的过度索取在导致灾难的同时，同样也会引发人民的愤怒与反思，于是转而走向第三阶段。雷声阵阵，似乎在控诉太行遭受的创伤，然而“乌云汇合”，遮天蔽日。在第三阶段，“乌云”二字重复出现了六次之多，其必然有所意指。<br>&emsp;&emsp;实际上，在万青首专和随后发行的单曲中，以及本专接下来的曲目中，也多次出现了乌云这一意象。我们先看首专的《这颗行星所有的酒馆》（以下简称《酒馆》）写到：</p><p><font  face=STKaiti>&emsp;&emsp;那些智力超常的人啊/认为已经 /熟悉了云和闪电的脾气</font><br>&emsp;&emsp;这里虽然只写了云，但与闪电一起出现的，不就是乌云么。在随后发行的单曲《乌云典当记》（智利政治电影《NO》在台湾上映的中文主题曲）中，如下写道：</p><p><font  face=STKaiti>&emsp;&emsp;谁用乌云换日星/谁用匕首换光明</font><br>&emsp;&emsp;以及在这张专辑《采石》、《河北墨麒麟》中出现的”乌云遮目“以及“乌云阻拦明月涌河湾”云云。个人认为，穿插于万青职业生涯中的乌云意象，大多描绘的是统治者的权威压迫、威权社会人人自危的恐惧以及看不得、说不得的囚禁之痛。<br>&emsp;&emsp;因此，乌云骤雨与泥河是因果关系，雨水冲刷泥土汇与河，裹挟大地上层没有那么稳定的、新生的土壤，“就投身激流冲水坝”，雷声滚滚，怒潮来临，然后呢？诉说戛然而止。显然，这样的统治方式引发了人们的不满，不能再持续下去，自此，《泥河》一曲终了。既然《早》代表了新中国伊始，那么《泥河》讲述的就是50~70年代的威权社会主义时期，在社会建设与重构的同时对太行造成了大量破坏与伤害。<br><br></p><h5 id="《平等云雾》"><a href="#《平等云雾》" class="headerlink" title="《平等云雾》"></a>《平等云雾》</h5><p>&emsp;&emsp;平等云雾只是一小段噪音旋律，仿佛是太行深处传出的控诉。而云雾这样笼罩在众人头上，没有实体，时刻变化的东西，正是意识形态最好的比喻，如此平等云雾就可以被解读为平等的意识形态。平等云雾，是平等还是不平等，留给听众思考。<br><br></p><h5 id="《采石》"><a href="#《采石》" class="headerlink" title="《采石》"></a>《采石》</h5><p><font face=STKaiti>开采 我的血肉的火光 发动 新世界的前进的泡影 雷鸣 交织爆破成动荡 此生再不归太行 捶打我天然的沉默 切割我卑微与困惑 面貌已生疏 前方模糊 灵魂在山口又回顾 崭新万物 正上升幻灭如明星 我却乌云遮目 崭新万物 正上升幻灭如明星 乌云遮目 愤怒急促地流失 收回不安的目光 山河地理 退入大雾后 明天是复杂的漫游 以我之身躯为阶梯 以我之身躯为樊篱 陌生与敌意 其中凝聚 千座山峰化水泥 唔—— 前进的泡影 唔—— 复杂的漫游 崭新万物 正上升幻灭如明星 我却乌云遮目 崭新万物 正上升幻灭如明星 乌云遮目</font><img align="right" width=100% src="https://s2.loli.net/2023/08/18/sB8YHlamMpcCE7Q.jpg" style="margin-right: 10px;margin-top: 10px;margin-buttom:20px;"></p><p>&emsp;&emsp;有了前面的铺垫，我们就大概能猜到采石讲的是什么了。我个人趋向于泥河与采石讲的是以80年代为分水岭的新中国的两个时代，因此，采石的背景是改革开放后的高速发展时期。“开采 我的血肉的火光 发动 新世界的前进的泡影”，无数的农民涌入工厂，在车间生产衣服，鞋子，半导体和玻璃摆件。在货币与商品的交易中推动新世界的前进，中国社会已走向巨大的转型，决定”此生再不回太行“。装满煤炭与岩石的火车从太行驶出，像是装满民工迷茫的脸庞，在山口回顾，却发现自己已经处于不进则退的隘口上，只能被时代的洪流裹挟着前进。这些煤炭和岩石在城市中被燃烧或碎裂，构成这个庞大生物的血液和骨肉，它不断成长代谢，新的建造起来，旧的倒下去，高楼林立，摩肩接踵，眼中的繁荣却自然而然地流向金字塔的上层，正是一派“崭新万物上升幻灭如明星”的景象。<br>&emsp;&emsp;世事变迁，蒙蔽在人们上空的乌云却依旧存在，但社会的高速发展掩盖了许多问题，以至“愤怒急促地消失 收回不安的目光”，殊不知自己的身躯以作为基石构筑了他人上升的阶梯，而消失的愤怒也默许了逐渐闭合的藩篱。千座山峰化水泥，正是宏大叙事中最壮丽的一副画卷。<br>&emsp;&emsp;《采石》的尾奏，是萨克斯与噪音的不断争斗。随着噪音的增强，最后一声萨克斯也被淹没在漫长的黑白雪花中，象征着抗争者声音的消逝。<br><br></p><h5 id="《山雀》"><a href="#《山雀》" class="headerlink" title="《山雀》"></a>《山雀》</h5><p><font face=STKaiti>自然赠予你 树冠 微风 肩头的暴雨 片刻后生成 平衡 忠诚 不息的身体 捕食饮水 清早眉间白云生 跳跃漫游 晚来拂面渤海风 朝霞化精灵 轻快 明亮 恒温的伴侣 她与你共存 违背 对抗 相同的命运 爱与疼痛 不觉茫茫道路长 生活历险 并肩莽莽原野荒 山崖复远望 仓皇 无告 不回的河流 平原不可见 晦暗 无声 未知的存亡 大雾重重 时代喧哗造物忙 火光忷忷 指引盗寇入太行 大雾重重 时代喧哗造物忙 火光忷忷 指引盗寇入太行</font><img align="left" width=30% src="https://s2.loli.net/2023/08/18/1uv5RCZcYhlENyI.jpg" style="margin-right: 10px;margin-top: 10px;margin-buttom:20px;"></p><p>&emsp;&emsp;《山雀》可以说是这张专辑传唱度最好的一首，曲风轻盈，有浓重的民谣韵味。从《泥河》到《采石》的痛苦、冷峻戛然而止，转而赞颂了动物朋友山雀。姬赓老师不惜溢美之词，把山雀描绘成了一位自然孕育的，轻快、温暖且忠诚的伴侣，与叙事的主人公作伴，一起“对抗相同的命运”。这里的命运，或许指代的就是工业时代的异化与威权的倾轧，但山雀这位完美的伴侣，又是从何而来呢。姬赓老师在这里没有玩“三七或六四”那样的文字游戏，也没有做“雷鸣、乌云”那样明确的比喻，如此使我有理由相信，山雀就是在大雾重重的时代陪伴主人公飞翔的伴侣，她可以是人，热爱或者幻想，在面对“盗寇入太行”时，摒弃逃避和抗争，选择新的前进方式，即下一首乐曲的名称：绕越。<br><br></p><h5 id="《绕越》"><a href="#《绕越》" class="headerlink" title="《绕越》"></a>《绕越》</h5><p>&emsp;&emsp;绕越是专辑最后一首纯器乐乐曲，随着紧凑的2/4拍进行曲，《山雀》曲末中的盗寇成群结队前来。然而悠扬的管乐响起，似乎意指着山雀携我们的主人公乘风而行，绕过气势汹汹的盗寇，穿梭于太行山中。<br><br></p><h5 id="《河北墨麒麟》"><a href="#《河北墨麒麟》" class="headerlink" title="《河北墨麒麟》"></a>《河北墨麒麟》</h5><p><font face=STKaiti>听雷声 滚滚 他默默 闭紧嘴唇 停止吟唱暮色与想念 他此刻沉痛而危险 听雷声 滚滚 他渐渐 感到胸闷 乌云阻拦明月涌河湾 他起身独立向荒原 试试 冰冷昂贵入云涉水的轻身术 看看 演员王公游民盗贼的心电图 试试 冰冷昂贵入云涉水的轻身术 看看 演员王公游民盗贼的心电图 试试 冰冷昂贵入云涉水的轻身术 看看 演员王公游民盗贼的心电图 试试 冰冷昂贵入云涉水的轻身术 看看 演员王公游民盗贼的心电图</font> <img align="right" width=100% src="https://s2.loli.net/2023/08/18/mo9LyEhKMZb7RTO.jpg" style="margin-right: 10px;margin-top: 10px;margin-buttom:20px;"></p><p>&emsp;&emsp;个人认为，《冀西南林路行》中最为浓墨重彩的一笔，极强的前卫摇滚风格、紧扣心弦的旋律以及错综复杂的器乐让人爱不释手。至此，专辑中终于出现了墨麒麟的形象，我们也得以猜测，之前的画面皆是墨麒麟所见。在目睹太行的动荡后，这头神兽似乎欲有所动。然而“乌云阻拦明月涌河湾”，当抗争被制止，高墙筑起，墨麒麟选择了另一个途径：“他起身独立向荒原”。行文至此，忽然想到水浒传里有河北玉麒麟之称的卢俊义，他“威风凛凛，仪表似天神“，出身富豪却命途多舛，最终被逼上梁山。同样的命运下，墨麒麟也选择了出世，以一个观察者的姿态道出了两句话“试试 冰冷昂贵入云涉水的轻身术 看看 演员王公游民盗贼的心电图”。<br>&emsp;&emsp;姬赓老师创作的晦涩难懂让人又爱又恨，前半句“冰冷昂贵入云涉水的轻身术”大抵描绘的仍然是墨麒麟，对于神通广大的神兽而言，为什么轻身术是“昂贵”的？或许，这里的轻身术并不指上天遁地，而是从高处跃下，了结性命，”轻身“同”轻生“，代价是生命而因此昂贵。但墨麒麟终归只是“试试”，没没有做出这一举动。<br>&emsp;&emsp;下句“演员王公游民盗贼的心电图”提及了四个职业，演员古称优伶，出卖才艺讨好看客而谋生之人；王公自然是王公贵族；游民指无田可耕，流离失所之人，《礼记·王制》曰“无旷土，无游民，食节事时，民咸安其居”，可见无游民是社会安定的体现；盗贼指的是盗窃财产致富的人。由此可见，在一个畸形的社会中，有着大权在握的王公，讨好王公谋生的演员，偷窃社会财富的盗贼以及孤苦无依的游民，即失业者这四个不安定因素。这些不安定因素共同导致了“心电图”这一图景，而心电图可以指同样起伏的股票。这里的股票或许有两个解读的选项：一是股票是资本主义的象征，而演员王公游民盗贼正是威权资本主义社会客观存在的社会构成；二是股票意指波动的社会财富，正是演员王公游民盗贼的存在，导致了社会的不安定。《河北墨麒麟》就在看到这一番图景的墨麒麟的愤怒咆哮中结束。<br><br></p><h5 id="《郊眠寺》"><a href="#《郊眠寺》" class="headerlink" title="《郊眠寺》"></a>《郊眠寺》</h5><p><font face=STKaiti>新语言 旧语言 该怎样回答 不眠的时间 星河下 电子荒原 亿万场冷暖 亿万泥污人 切断电缆 朝霞晚风 临时收入 临时生活 切断电缆 数字云烟 免费月光 免费惊险 月光熔铁星 铸我神与心 月光熔铁星 铸我神与心 渤海地产 太行水泥 宗教医保 慈善股票 幻觉贸易 阶级电梯 高级魔术 高级发明 凝聚神与心 建此不夜城 凝聚神与心 建此不夜城 演员失业 电缆失窃 共享富裕 共享恐惧 东方睡衣 涌上街头 街头嘈杂 公共聋哑 紧急换电缆 循环追捕令 紧急换电缆 循环追捕令 我有迷魂 额头滚烫 我有迷魂 人间明暗 鸟兽暗语 危险消息 自然友谊 自然躲避 西郊有密林 助君出重围 西郊有密林 助君出重围 人间明暗 人间明暗 人间明暗 人间明暗 新语言 旧语言 该怎样回答 不眠的时间 星河下 电子荒原 亿万场冷暖 亿万泥污人</font><br><img align="right" width=100% src="https://s2.loli.net/2023/08/19/mbzfCZL3795Nykc.jpg" style="margin-right: 10px;margin-top: 10px;margin-buttom:20px;"><br>&emsp;&emsp;日月交替，或许以2012年为节点，中国从旧语言的世界走向新语言，在阐述新语言与旧语言之前，我们需要先了解一个哲学观念：维特根斯坦在《逻辑哲学论》中提及的“语言的界限就是思想的界限”。<br>&emsp;&emsp;英格博格·巴赫曼对此解释道，作为人的思维工具的语言本身，一方面固然能够描述和塑造世界。但是，恰恰在对世界的描述和塑造中，它也遇到了其局限性。我们站在“界限”的这一侧，思考，用语言表述。因为作为形而上学主体的我们自己不再是世界的一部分，而是“界限”，所以世界作为有限的整体的感觉才会产生。另一方面，这个逻辑形式就是“界限”，因为它虽然使描述成为可能，但是它自身却不能再被描述。在其中出现了一些超越现实之外的东西。只有当在逻辑形式中展现出一些我们无法思考的东西时，它才是超越现实之外的，因为它是无法思考的，所以它就不能被说出来。<br>&emsp;&emsp;也就是说，在语言和语言所表达的概念的限度之外的东西，是我们的思考无法触及的，语言框定了思维的疆界与深度。而在过去的十年，特别是近五年里，我们深刻感受到了互联网中语言的进一步收缩。从敏感词语的限制，到各种滑稽的替换，再到令人厌倦的同质化表达，统治者通过管控语言而从大众脑中剥离政治，短视频与反复出现的文案不断压缩观众的思想。表面上的欣欣向荣，实际上只是“电子荒原”。也应对了姬赓老师的那句话：<font face=STKaiti>这几年间，气象风物变化急促 　　几人仍眼睛明亮，几人已失了魂？</font>至此，60-80年代，80-10年代和10-20年代三个时代各自所特有的苦难与无奈全都被剖析出来。<br>&emsp;&emsp;《郊眠死》做为专辑的最后一曲，在前面抛出了这么多困顿与质问后，应当是给出答案的一曲，加之万青新的录音室也被命名为“郊眠寺”，那么这个寺指代的定是困境中的容身之所，摆脱一切束缚与烦恼的地方。或许“切断电缆”就是郊眠寺对个体给出的答案之一，既然无法抗衡权威，就像绕越与“起身独立向荒原”，应当首先脱离阻滞思想发展的环境，去感受“朝霞晚风”。但为何切断电缆后又变为了”临时收入，临时生活“？个人认为，既然”电“是限制我们思维，限制我们去感受”免费月光“的桎梏，那么也可以认为”电缆“指的是运输电的工具，是生产权力的意识形态。在众多的四言句中，我们不难看出对应的两段：<br>&emsp;&emsp;<font face=STKaiti>渤海地产 太行水泥 宗教医保 慈善股票 幻觉贸易 阶级电梯 高级魔术 高级发明</font><br>&emsp;&emsp;以及：<br>&emsp;&emsp;<font face=STKaiti>演员失业 电缆失窃 共享富裕 共享恐惧 东方睡衣 涌上街头 街头嘈杂 公共聋哑</font><br>&emsp;&emsp;前一段描述的是现在，那么后一段或许描述的就是未来，一个脱离了意识形态，削弱了公权力的时代。然而《郊眠寺》实在过于晦涩，“紧急换电缆 循环追捕令”又是为何，还望后人的智慧可以解答。个人简单理解为，这样幻想中的未来世界终究被打破，而“凝聚神与心 建此不夜城”的主人公（或许可以是墨麒麟）被通缉，只能因此逃亡，重回太行山。“我有迷魂 额头滚烫 我有迷魂 人间明暗 鸟兽暗语 危险消息 自然友谊 自然躲避”，遁入山野，阐述去往的目的地的正是整张专辑最重要的一句歌词：<br>&emsp;&emsp;<font face=STKaiti>西郊有密林 助君出重围</font><br>&emsp;&emsp;郊眠寺，或许就是掩藏于西郊的寺庙。“该怎样回答不眠的时间”，如何应对不断前行的时代，答案应当就是这一句“西郊有密林，助君出重围”。然而时至今日，我仍然没有完全弄清楚它到底是怎样的一处密林，或许是出世回归于劳动、饮酒、叹息，或许是从荒芒的旷野回到茂密的丛林，从抽象的爱恨回归到具体的爱，这一切的答案作为最后一个谜底让读者与多年后回看的我自行揣测吧。</p><h5 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h5><p>&emsp;&emsp;或许会有人觉得我是过度解读，但以我对于万青的了解，以及从《喜剧》到《酒馆》，从《大石》到《乌云》，他们表达的困顿、愤怒、思考与疑问都非常丰富，而《冀西南林路行》的内涵必然只增不减，奈何能力有限，很多地方只是揣测，也与网上许多其他解读有所冲突。但我觉得对于高深晦涩又没有谜底的文字的解读乐趣就在于此，通过理解与感悟来提高自己的认知，亦可以接触到众多不同的思想，相信作者也乐于读者思考与遐想。写下这篇解读，距离专辑发布已三年多，期间一直在思考是否要提笔，却一直缺少知识与畅所欲言的平台，如今终于了却一桩心事。感谢万青，感谢在网络上发表自己见解的同仁，感谢读到这里的朋友，欢迎大家批评指正。</p><p>2023年8月19日于南京</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;炫耀一下我的实体专辑，以及对于全专作词的分析。&lt;br&gt;</summary>
    
    
    
    <category term="随想录" scheme="https://atffang.github.io/categories/%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>JS实现地理流可视化</title>
    <link href="https://atffang.github.io/2023/07/06/JS%E5%AE%9E%E7%8E%B0%E5%9C%B0%E7%90%86%E6%B5%81%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <id>https://atffang.github.io/2023/07/06/JS%E5%AE%9E%E7%8E%B0%E5%9C%B0%E7%90%86%E6%B5%81%E5%8F%AF%E8%A7%86%E5%8C%96/</id>
    <published>2023-07-06T05:42:38.000Z</published>
    <updated>2023-08-16T13:49:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>前端对于地理流数据进行可视化。<br><span id="more"></span><br>地理流是一种地理对象间交互的表现形式，一般来说，地理流是单向的，如北京向上海的人口流动，而两个地理流构成了一对地理对象之间的交互，如北京-上海人口流动由北京向上海的人口流动与上海向北京的人口流动构成。由此，在一组地理对象间的地理流数据可以表示为一个OD(origin-destination)矩阵。基于一些需求，我需要将地理流数据展现在网页地图上，下面给出一个基于mapbox的原生解决方案。</p><h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><h5 id="一-贝塞尔曲线"><a href="#一-贝塞尔曲线" class="headerlink" title="一.  贝塞尔曲线"></a>一.  <strong>贝塞尔曲线</strong></h5><p><img align="left" width=50% src="https://s2.loli.net/2023/08/16/dMDqrkQty71zNLI.gif" style="margin-right: 20px;margin-top: 10px;margin-buttom:20px;">&emsp;&emsp;贝塞尔曲线是一种<strong>使用数学方法描述的曲线</strong>，被广泛用于计算机图形学和动画中。一般来说，除起点与终点外，贝塞尔曲线拥有两个控制点，确定控制点与终末点的位置关系即可得到设想中的曲线。<br>&emsp;&emsp;&emsp;能力有限我们无法直接得到一条曲线公式，故使用点集替代，再将其转化为弧段。</p><p>&emsp;&emsp;&amp;emsp定义一个函数<code>getCurvedLine</code>,输入ps（起始点）,pe（结束点）,arci（弧度），返回一个点集，表示包含500个点的贝塞尔曲线：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getCurvedLine</span>(<span class="params">ps,pe,arci</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(ps==pe)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">computeControlPoint1</span> = (<span class="params">ps, pe, arc = arci</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> deltaX = pe[<span class="number">0</span>] - ps[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">const</span> deltaY = pe[<span class="number">1</span>] - ps[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">const</span> theta = <span class="title class_">Math</span>.<span class="title function_">atan</span>(deltaY / deltaX);</span><br><span class="line">        <span class="keyword">const</span> len = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>((deltaX * deltaX) + (deltaY * deltaY)) / <span class="number">2</span> * arc;</span><br><span class="line">        <span class="keyword">const</span> newTheta = theta - <span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">          (ps[<span class="number">0</span>] + pe[<span class="number">0</span>]) / <span class="number">2</span> - len * <span class="title class_">Math</span>.<span class="title function_">cos</span>(newTheta),</span><br><span class="line">          (ps[<span class="number">1</span>] + pe[<span class="number">1</span>]) / <span class="number">2</span> - len * <span class="title class_">Math</span>.<span class="title function_">sin</span>(newTheta),</span><br><span class="line">        ];</span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> controlpoint1=<span class="title function_">computeControlPoint1</span>(ps,pe)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> linePoints=[ps,controlpoint1,pe];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> line = turf.<span class="title function_">lineString</span>(linePoints);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> curved = turf.<span class="title function_">bezierSpline</span>(line);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> curveCoordinates = curved.<span class="property">geometry</span>.<span class="property">coordinates</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> curveCoordinates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="二-生成featureCollection"><a href="#二-生成featureCollection" class="headerlink" title="二.  生成featureCollection"></a>二.  <strong>生成featureCollection</strong></h5><p>&emsp;&emsp;&emsp;FeatureCollection 是 GeoJSON 格式中的一种，它用于组织多个地理要素（features）。其基本格式如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;FeatureCollection&quot;</span>,</span><br><span class="line">  <span class="string">&quot;features&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Feature&quot;</span>,</span><br><span class="line">      <span class="string">&quot;geometry&quot;</span>: &#123;...&#125;,   <span class="comment">// 地理要素的几何信息</span></span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;...&#125;  <span class="comment">// 地理要素的属性信息</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 可以有更多的 features</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;FeatureCollection包含了地理要素的类型、几何信息与属性信息。在本项目中，使用mapbox展示弧线段。将点集转化为FeatureCollection的代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getArcFeature</span>(<span class="params">lineList, valueList, arc</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> curveCoordinatesList=[];</span><br><span class="line">      lineList.<span class="title function_">forEach</span>(<span class="function">(<span class="params">line</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 在回调函数中使用 line 进行操作</span></span><br><span class="line">        curveCoordinatesList.<span class="title function_">push</span>(<span class="title function_">getCurvedLine</span>(line[<span class="number">0</span>],line[<span class="number">1</span>],arc))</span><br><span class="line">      &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> featureCollection = &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;FeatureCollection&#x27;</span>,</span><br><span class="line">    <span class="attr">features</span>: []</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; curveCoordinatesList.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> curveCoordinates = curveCoordinatesList[i];</span><br><span class="line">      <span class="keyword">const</span> feature = &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;Feature&#x27;</span>,</span><br><span class="line">        <span class="attr">geometry</span>: &#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&#x27;LineString&#x27;</span>,</span><br><span class="line">          <span class="attr">coordinates</span>: curveCoordinates</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">properties</span>: &#123;</span><br><span class="line">          <span class="string">&#x27;value&#x27;</span>:valueList[i]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    featureCollection.<span class="property">features</span>.<span class="title function_">push</span>(feature);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> featureCollection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;其中，LineList包含多个点集，valueList是这些点集对应的地理流强度。本项目中使用的数据格式具体如下：<br><img align="left" width=50%  src="https://s2.loli.net/2023/08/16/ugZfTRaCh87bWJx.jpg" style="margin-right: 20px;margin-top: 10px;margin-buttom:20px;"><br><br><br><br><br><br></p><h5 id="三-在Mapbox上添加弧段"><a href="#三-在Mapbox上添加弧段" class="headerlink" title="三.  在Mapbox上添加弧段"></a>三.  <strong>在Mapbox上添加弧段</strong></h5><p>&emsp;&emsp;&emsp;将填充好的featureCollection加载在map的source中。mapbox的初始化本文不再赘述。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加线图层</span></span><br><span class="line">map1.<span class="title function_">addSource</span>(<span class="string">&#x27;line_flow&#x27;</span>+drawnum, &#123;</span><br><span class="line">  <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;geojson&#x27;</span>,</span><br><span class="line">  <span class="attr">lineMetrics</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;data&#x27;</span>: featureCollection</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;其中，drawnum是每个featureCollection唯一标识符，需要保证每次添加时唯一标识符不同，否咋将导致冲突。<br>&emsp;&emsp;按照赋予的id将弧线作为图层添加到map中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">map1.<span class="title function_">addLayer</span>(&#123;</span><br><span class="line">    <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;line_flow&#x27;</span>+drawnum,</span><br><span class="line">    <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;line&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;source&#x27;</span>: <span class="string">&#x27;line_flow&#x27;</span>+drawnum,</span><br><span class="line">    <span class="string">&#x27;layout&#x27;</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;line-join&#x27;</span>: <span class="string">&#x27;round&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;line-cap&#x27;</span>: <span class="string">&#x27;round&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">paint</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;line-width&#x27;</span>: [</span><br><span class="line">        <span class="string">&#x27;interpolate&#x27;</span>,</span><br><span class="line">        [<span class="string">&#x27;linear&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;value&#x27;</span>], <span class="comment">// 使用 feature 的 value 字段作为插值属性</span></span><br><span class="line">        min, <span class="comment">// 最小值</span></span><br><span class="line">        <span class="number">0.5</span>, <span class="comment">// 最小线宽</span></span><br><span class="line">        max, <span class="comment">// 最大值</span></span><br><span class="line">        <span class="number">5</span> <span class="comment">// 最大线宽</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&#x27;line-gradient&#x27;</span>: [</span><br><span class="line">        <span class="string">&#x27;interpolate&#x27;</span>,</span><br><span class="line">        [<span class="string">&#x27;linear&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;line-progress&#x27;</span>],</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        colorList[<span class="number">0</span>],</span><br><span class="line">        <span class="number">0.4</span>,</span><br><span class="line">        colorList[<span class="number">1</span>],</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        colorList[<span class="number">2</span>]</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><br><img align="left" width=50% src="https://s2.loli.net/2023/08/16/GsXR5UATWij7ZDO.png" style="margin-right: 20px;margin-top: 10px;margin-buttom:20px;">&emsp;&emsp;在paint中使用line-width与line-gradient设置颜色与宽度的插值。添加起点和终点数据，作为点图层添加在map中，大致效果如左图所示<br>&emsp;&emsp;&emsp;至此，归纳一下总体流程。首先需要将OD数据与OD点对间地理流的强度存储于数据库中，在显示时读取并生成贝塞尔曲线，将曲线作为geometry，地理流强度作为properties生成弧线类型的FeatureCollection，并显示在地图上。此外，mapbox还可以实现对于属性的筛选，这就可以帮助我们做两件事：一是根据流动强度筛选要显示的高于或地域某一阈值的地理流；二是通过单击基础的geojson面，通过其反馈的地级市名称，查询该地的流入\流出数据并显示，例如：<br><code>&#39;filter&#39;: [&#39;==&#39;,&#39;NAME&#39;, states[0].properties.NAME]</code></p><h5 id="四-添加动画"><a href="#四-添加动画" class="headerlink" title="四.  添加动画"></a>四.  <strong>添加动画</strong></h5><p><img align="left" width=50% src="https://s2.loli.net/2023/08/16/LPjHkU46cCOu1Qh.gif" style="margin-right: 20px;margin-top: 10px;margin-buttom:20px;">&emsp;&emsp;在展示单个城市的流入\流出时，可以适当添加动画以提升美观性。例如，通过递归调用绘制点的函数，来展示点扩散，以体现”向外传播“的视觉效果。动画的代码网上种类繁多，我作为前端开发业余爱好者的工作便不做展示。<br>&emsp;&emsp;值得注意的是，在添加新的数据时，最好将先前的source和layer清除，以减轻内存负担。动画的添加也可能会导致卡顿、丢帧等问题，故需要兼容性能，不过这个领域的工作我就完全不了解了T.T<br><br><br></p><h5 id="五-项目介绍"><a href="#五-项目介绍" class="headerlink" title="五.  项目介绍"></a>五.  <strong>项目介绍</strong></h5><p>&emsp;&emsp;&emsp;该项目爬取了2019、2020及2023年城市在五一期间的两种有向OD流数据:高德迁徙平台地级市间与人口流入流出数量正相关的迁徙指数数据共 889,375 条；百度指数平台地级市间PC端搜索量、手机端搜索量、网络搜索总量数据共 5,595,450 条。对比不同年份五一节假日虚（搜索数据）实（迁徙数据）两种地理流的空间格局，以得出相关结论。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前端对于地理流数据进行可视化。&lt;br&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
  <entry>
    <title>摘录：纽约客对刘慈欣的采访</title>
    <link href="https://atffang.github.io/2023/04/03/%E6%91%98%E5%BD%95%EF%BC%9A%E7%BA%BD%E7%BA%A6%E5%AE%A2%E5%AF%B9%E5%88%98%E6%85%88%E6%AC%A3%E7%9A%84%E9%87%87%E8%AE%BF/"/>
    <id>https://atffang.github.io/2023/04/03/%E6%91%98%E5%BD%95%EF%BC%9A%E7%BA%BD%E7%BA%A6%E5%AE%A2%E5%AF%B9%E5%88%98%E6%85%88%E6%AC%A3%E7%9A%84%E9%87%87%E8%AE%BF/</id>
    <published>2023-04-03T12:14:09.000Z</published>
    <updated>2023-04-03T12:31:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>逛红迪的时候看到了19年纽约客对刘慈欣的采访，记录一下。<br><span id="more"></span></p><p>不可否认的是，刘慈欣以三体为代表的若干作品仍是中国科幻届的掌上明珠，但这两年个人越来越讨厌刘慈欣了。一是因为b站上把他奉若圭臬的粉丝太多（我知道不应该因为他的脑残粉讨厌他，但我忍不住啊sorry）；二是因为回头想他的一些文字，确实不乏中年男子的意淫。</p><p>下面是一段采访记者的口述（美国的记者也都一个b样，意识形态太入脑/政治任务太重，两位半斤八两）：</p><p>And so, Liu explained to me, the existing regime made the most sense for today’s China, because to change it would be to invite chaos. “If China were to transform into a democracy, it would be hell on earth,” he said. “I would evacuate tomorrow, to the United States or Europe or—I don’t know.” The irony that the countries he was proposing were democracies seemed to escape his notice. He went on, “Here’s the truth: if you were to become the President of China tomorrow, you would find that you had no other choice than to do exactly as he has done.”</p><p>When I brought up the mass internment of Muslim Uighurs—around a million are now in reëducation camps in the northwestern province of Xinjiang—he trotted out the familiar arguments of government-controlled media: “Would you rather that they be hacking away at bodies at train stations and schools in terrorist attacks? If anything, the government is helping their economy and trying to lift them out of poverty.” The answer duplicated government propaganda so exactly that I couldn’t help asking Liu if he ever thought he might have been brainwashed. “I know what you are thinking,” he told me with weary clarity. “What about individual liberty and freedom of governance?” He sighed, as if exhausted by a debate going on in his head. “But that’s not what Chinese people care about. For ordinary folks, it’s the cost of health care, real-estate prices, their children’s education. Not democracy.”</p><p>声明：本博客仅记载客观事实，对于记载的事实不发表任何观点（上述的观点也只是针对大刘个人的一些看法）。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;逛红迪的时候看到了19年纽约客对刘慈欣的采访，记录一下。&lt;br&gt;</summary>
    
    
    
    <category term="随想录" scheme="https://atffang.github.io/categories/%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>GCJ02toWGS84</title>
    <link href="https://atffang.github.io/2023/03/25/GCJ02toWGS84/"/>
    <id>https://atffang.github.io/2023/03/25/GCJ02toWGS84/</id>
    <published>2023-03-25T05:26:55.000Z</published>
    <updated>2023-03-25T05:33:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>json文件GCJ02向WGS84坐标系转换的小工具<br><span id="more"></span><br>在做地图学作业时，需要对json数据完成GCJ02向WGS84坐标系的转换，QGIS实现时遇到了一些问题，因此借助openAI的帮助，写了个小脚本，分享给大家。</p><iframe  height=200width=60%src="https://atffang.github.io/GeoJson_GCJ02_WGS84/"  frameborder=0  allowfullscreen></iframe>]]></content>
    
    
    <summary type="html">&lt;p&gt;json文件GCJ02向WGS84坐标系转换的小工具&lt;br&gt;</summary>
    
    
    
    <category term="工具" scheme="https://atffang.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>基于群体智慧的中国人口多情景时空仿真建模与预测</title>
    <link href="https://atffang.github.io/2023/03/14/%E5%9F%BA%E4%BA%8E%E7%BE%A4%E4%BD%93%E6%99%BA%E6%85%A7%E7%9A%84%E4%B8%AD%E5%9B%BD%E4%BA%BA%E5%8F%A3%E5%A4%9A%E6%83%85%E6%99%AF%E6%97%B6%E7%A9%BA%E4%BB%BF%E7%9C%9F%E5%BB%BA%E6%A8%A1%E4%B8%8E%E9%A2%84%E6%B5%8B/"/>
    <id>https://atffang.github.io/2023/03/14/%E5%9F%BA%E4%BA%8E%E7%BE%A4%E4%BD%93%E6%99%BA%E6%85%A7%E7%9A%84%E4%B8%AD%E5%9B%BD%E4%BA%BA%E5%8F%A3%E5%A4%9A%E6%83%85%E6%99%AF%E6%97%B6%E7%A9%BA%E4%BB%BF%E7%9C%9F%E5%BB%BA%E6%A8%A1%E4%B8%8E%E9%A2%84%E6%B5%8B/</id>
    <published>2023-03-14T11:24:51.000Z</published>
    <updated>2023-10-07T14:01:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>2022ESRI大赛参赛作品（一等奖）。<br><span id="more"></span></p><h3 id="1-设计思想"><a href="#1-设计思想" class="headerlink" title="1 设计思想"></a>1 设计思想</h3><h4 id="1-1-作品背景"><a href="#1-1-作品背景" class="headerlink" title="1.1 作品背景"></a>1.1 作品背景</h4><p>作为人口大国，人口问题始终是中国高度关注的重要战略问题，深刻影响着国家政治改革、经济发展、社会进步和文化建设等方面。然而，目前中国人口发展面临着深刻而复杂的形势变化，人口负增长下“少子老龄化”将成为常态。因此，推动人口长期均衡、可持续发展成为国家急需解决的问题，各类政策调整与社会经济因素变动对人口发展的影响亟待探索。</p><p>目前学界对于人口的研究多基于现有多期人口普查数据，从宏观、综合的视角对人口发展基本状况进行统计分析和预测模拟。研究方法多为Malthus指数模型和Logistic阻滞增长模型等数学方法；研究对象多为人口的<strong>总体</strong>或多个人口<strong>群体</strong>，缺乏对个体差异的深入考量；研究尺度多聚焦国家总体或特定地区，视角较为单一，未能全面地探讨人口的地域性特征。</p><p>为从地理学的视角解决社会问题、完善人口研究，本作品运用群体智慧与复杂系统建模的方法，从单一的智能体（即人口<strong>个体</strong>）的视角出发，自下而上地对中国各等级城市单元人口动态发展过程进行仿真建模，构建三大民生关切的场景，探究人口对于不同情景下社会决策的响应；同时，根据多项人口发展指标分别创建时空立方体，总结人口时空演变规律，并进行人口发展可持续性综合评价及分区，为区域人口发展规划提供参考。总体上，本作品运用创新的模型构建、空间分析方法，从数据层、特征层和决策层实现对中国人口发展的深入探索，从地理学的视角为缓解人口与政治、经济、社会的矛盾提供区域化解决思路，对中国人口可持续发展路径探索具有重要意义。</p><h4 id="1-2-方法设计"><a href="#1-2-方法设计" class="headerlink" title="1.2 方法设计"></a>1.2 方法设计</h4><p>如图1的技术路线所示，设计流程总体上可概括为数据获取、模型构建、情景模拟与规律探索四部分，最终在应用层面实现<strong>人口多情景决策模拟与推演</strong>以及<strong>人口时空演变规律探索</strong>。<div align=center><a href="https://imgse.com/i/pplzRUA"><img src="https://s1.ax1x.com/2023/03/14/pplzRUA.jpg" alt="pplzRUA.jpg"></a><br>图1 作品技术流程图</p><div align=left><p>第一部分为基础数据的获取与处理，通过多种手段为后续模型构建完成了数据准备；第二部分为基于群体智慧和复杂系统方法的人口动态仿真建模，运用涵盖了个人基本属性、地区特性、健康状况、经济状况及婚育状况的多主题多时期人口数据，构建了仿真的智能体属性库和智能体行为逻辑链，并进行实验验证模型的可行性；第三部分为人口多情景社会决策模拟与推演及时空演变规律探索，结合社会实际问题设定三类情景，通过不同情景下对具体参数的推演，模拟人口动态响应过程，并使用3D时空立方体模型可视化展现不同情景下多项人口指标发展过程，总结人口时空演变规律；第四部分为人口发展可持续性评估及区域划分，此部分综合城市人口自然增长率、性别比例及总抚养比评估人口发展可持续性，以此进行顾及空间约束的多要素地理分区，总结人口可持续发展区域化路径。</p><h5 id="1-2-1-数据获取与处理"><a href="#1-2-1-数据获取与处理" class="headerlink" title="1.2.1 数据获取与处理"></a>1.2.1 数据获取与处理</h5><p>本作品将中国全域（除港澳台）的所有地市纳入研究范围，综合城市的人口和经济指标，如图2所示，所有城市被划分成0、1、2共三个等级，将属于同一省份同一等级的城市集合作为基本城市等级单元进行研究。<a href="https://imgse.com/i/pplzrjO"><div align=center><img src="https://s1.ax1x.com/2023/03/14/pplzrjO.jpg" alt="pplzrjO.jpg"></a><br>图2 城市等级分类及人口总量统计图<div align=left><br>本作品所使用的数据包含统计数据、文献数据及流动数据，主要数据来源为《中国统计年鉴》《中国2010年人口普查资料》《中国2020年人口普查资料》等官方统计资料及人口研究相关文献。其中，对获得的各省各等级城市单元多主题多时期等人口统计数据进行分类处理，以便后续机理分析与模型构建；使用文献研究法，综合文献与经验数据，归纳得出模型构建中的相关参数，如参与匹配概率、生育年龄阈值等。</p><h5 id="1-2-2-基于群体智慧与复杂系统方法的人口动态仿真建模"><a href="#1-2-2-基于群体智慧与复杂系统方法的人口动态仿真建模" class="headerlink" title="1.2.2 基于群体智慧与复杂系统方法的人口动态仿真建模"></a>1.2.2 基于群体智慧与复杂系统方法的人口动态仿真建模</h5><p><strong>复杂系统</strong>泛指规模大、变量多、各部分关系和运动规律复杂或具有较大不确定性的动态系统，人口发展便是人口总体通过婚育行为决策、个人生命发展及人与环境交互等组成的动态复杂过程。目前，动态事件仿真建模主要有三种方法：离散事件、基于智能体以及系统动力学建模。在多方法仿真建模过程中，针对系统不同部分采用不同的建模方法进行详细描述，能够综合不同方法的优点，构建高效且可管理的模型，对现实世界复杂案例进行有效模拟。</p><p>本作品结合离散事件和基于智能体的方法，对中国人口动态发展过程进行时空仿真建模。一方面，如图3(a)所示，分别构建<strong>城市智能体</strong>和<strong>个人智能体</strong>，设置地理坐标、城市人口总数等城市属性以及年龄、性别等个人属性，关注智能体的个性行为及其之间的交互关系，城市智能体间的交互的现实表现为人口跨区域流动行为，个人智能体间的交互的现实表现为适龄异性间的匹配及婚育行为；另一方面，如图3(b)所示将每个个体的人生历程视为完整流程，基于未成年、成年、匹配、生育、死亡等人生状态构建系统流程，模拟个人对于婚育等的行为选择。即本作品采用离散事件模型描述个人智能体的内部流程，个人作为智能体显示在其所属城市范围内，城市作为智能体显示在中国全域范围内。<div align=center><a href="https://imgse.com/i/pplz6De"><img src="https://s1.ax1x.com/2023/03/14/pplz6De.jpg" alt="pplz6De.jpg"></a><br>图3 基于复杂系统的人口发展过程建模示意图<div align=left></p><h5 id="1-2-3-时空立方体格局分析法与多要素地理分区分析法"><a href="#1-2-3-时空立方体格局分析法与多要素地理分区分析法" class="headerlink" title="1.2.3 时空立方体格局分析法与多要素地理分区分析法"></a>1.2.3 时空立方体格局分析法与多要素地理分区分析法</h5><p>人口发展具有区域性、动态性、综合性，兼具了丰富的时间和空间内涵。而传统的空间分析并不能全面、深入地刻画中国城市人口变化及其未来发展，因此，需要从时空综合的视角对重要人口指标进行演变发展的规律性总结。</p><p><strong>时空立方体</strong>由若干个具有行、列和时间步长属性的立方图格组成，如图4(a)所示，通过创建时空立方体，可对动态发展数据进行可视化和分析。对于既定的行列位置可获得相应条柱时间序列，以此可分析变量时间变化差异。如图4(b)所示，基于同一位置可获取感兴趣变量的时序变化特征。基于多个目标要素的特征值，设置预期分类数量，可实现多元数据的聚类分析；顾及地理空间连续性，需要进一步对已经实现的聚类结果结构化，得到如图4(c)所示结果，整个研究区域被划分为三个分别空间连续的分区，从而实现多元数据的地理分区。<div align=center><a href="https://imgse.com/i/pplzcHH"><img src="https://s1.ax1x.com/2023/03/14/pplzcHH.jpg" alt="pplzcHH.jpg"></a><br>图4 时空立方体格局与多要素地理分区分析过程<div align=left></p><h3 id="2-主要功能"><a href="#2-主要功能" class="headerlink" title="2 主要功能"></a>2 主要功能</h3><h4 id="2-1-多情景社会决策模拟与推演"><a href="#2-1-多情景社会决策模拟与推演" class="headerlink" title="2.1 多情景社会决策模拟与推演"></a>2.1 多情景社会决策模拟与推演</h4><p>基于人口发展原始情景，调整社会经济、文化环境，通过提高就业率与工资水平、降低失业率、缩短工作时长、延长婚产假等改善工作环境，通过完善医疗设施、提升医疗水平等提升医疗条件，通过降低房价、提升住房公积金等缓解住房压力，以此构建三类生育友好情景，从而将影响个人生育决策及总体人口发展，为分析提供数据支持。如图5为人口仿真模型构建的部分逻辑图，社会情景的变动将直接影响个人行为选择，进而影响人口总体发展。<div align=center><a href="https://imgse.com/i/pplz48P"><img src="https://s1.ax1x.com/2023/03/14/pplz48P.jpg" alt="pplz48P.jpg"></a><br>图5 模型构建逻辑图<div align=left></p><h4 id="2-2人口演变响应模式挖掘"><a href="#2-2人口演变响应模式挖掘" class="headerlink" title="2.2人口演变响应模式挖掘"></a>2.2人口演变响应模式挖掘</h4><p>基于原始及多情景模拟过程，选取2020-2030十年间共120期人口发展指标数据，从人口发展演变过程与人口结构变化挖掘人口发展对不同情景的响应模式，并通过时空立方体及人口金字塔实现人口演变过程可视化。</p><h5 id="2-2-1-分情景人口时空演变规律"><a href="#2-2-1-分情景人口时空演变规律" class="headerlink" title="2.2.1 分情景人口时空演变规律"></a>2.2.1 分情景人口时空演变规律</h5><p>基于模型预测结果，根据人口发展指标的时间序列创建多情景时空立方体，下如图6所示，各项指标均具有显著的空间异质性特征和邻近时空域中的自相关性特征，性别比例及劳动人口占比存在显著的时间异质性，且在不同情景下人口发展具有显著响应。</p><p>人口总量整体呈现“东多西少” 的空间特征，东部沿海及川渝地区持续存在人口总量热点；性别比例与地区性别偏好相关性强，地区差异显著但相关性强，各情景下均呈现西北-东南-东北“倒三角点状”性别比例热点，其中在医疗情景下西北地区预测结果高值聚集显著性更强；老龄人口占比总体呈现“东北高-西南低”的空间格局，存在东北及华北地区的老龄占比热点，老龄化问题严重，东北地区预计将成为新增老龄占比热点，而南方城市老龄化将得到一定程度缓解；劳动人口占比时间异质性显著，呈现西部-华中-东部沿海及东北的“H型”劳动力占比热点，云南、海南及广西等地区劳动人口占比将逐渐提升，激发地区活力，同时相较原始情景，住房情景下新疆地区高值聚集现象弱化，工作情景下新疆及东北地区劳动力占比高值聚集更显著，社会劳动力将更为充足。<div align=center><a href="https://imgse.com/i/pplz2Ed"><img src="https://s1.ax1x.com/2023/03/14/pplz2Ed.jpg" alt="pplz2Ed.jpg"></a><br>图6 人口发展时空立方体（社会情景-人口发展指标）<div align=left></p><h5 id="2-2-2-人口结构动态变化趋势"><a href="#2-2-2-人口结构动态变化趋势" class="headerlink" title="2.2.2 人口结构动态变化趋势"></a>2.2.2 人口结构动态变化趋势</h5><p>年龄结构是人口发展和社会劳动生产的关键因素，会随着人口发展动态变化，为清晰反映人口结构情况，选取多时段全国总体人口预测结果，并进行多情景分析。如图7所示，横向为同一时段中不同情景预测结果，纵向为同一情景下不同时段人口结构预测。从时间发展角度看，受上世纪70年代“计划生育”政策影响，2023年41-50岁人口占比小，且中国人口总体老龄化程度加深；而随着近年来二孩、三孩政策的落实，生育潜力释放，青少年占比逐步升高，并具有继续增加的趋势，老龄人口占比短暂上升后保持相对稳定状态；此外在各类情景下，人口结构整体将更加趋于稳定，各年龄占比较为均衡，更有利于社会发展。从社会情景变动视角看，在工作环境改善、医疗条件提升、购房压力减小等生育友好情景下，青少年人口增长趋势更加显著，生育意愿提升。人口发展对外部环境变化响应显著，生育政策调整及社会环境优化能够缓解人口老龄化问题，促进人口长期均衡发展。<div align=center><a href="https://imgse.com/i/pplzW4I"><img src="https://s1.ax1x.com/2023/03/14/pplzW4I.jpg" alt="pplzW4I.jpg"></a><br>图7 多情景下人口金字塔结构动态变化预测图<div align=left></p><h4 id="2-3区域视角下人口发展可持续性综合评价"><a href="#2-3区域视角下人口发展可持续性综合评价" class="headerlink" title="2.3区域视角下人口发展可持续性综合评价"></a>2.3区域视角下人口发展可持续性综合评价</h4><p>人口可持续发展要求人口能够源源不断地适度增长，考虑各项人口指标，自然增长率反映地区人口总量变化幅度及发展趋势；性别比例为男性人数与女性之比，对婚姻及人口再生产具有重要意义，性别比失衡将导致婚姻挤压等问题，阻碍人口健康发展；总抚养比为非劳动人口与劳动人口的比值，反映劳动人口抚养负担及社会年龄结构，过重的负担将对生育产生负面影响。基于上述指标，从<strong>总量平稳性</strong>、<strong>性别平衡性</strong>、<strong>年龄均衡性</strong>三个角度综合评价人口发展可持续性，并进行多情景下顾及空间约束的多要素地理分区，探索区域现阶段人口可持续发展相似性，为区域人口决策规划提供建议。</p><p>基于多情景模拟结果，计算各地市三项人口指标，并调整设定聚类数进行多要素地理分区，如图8(a)-(d)所示，中国全域可基本划分为九大人口发展区域，按照自然增长率可分为增长、平稳与衰退三大类型，综合性别比例及总抚养比评估未来短期生育及人口发展潜力，可分为潜力型、稳定型及隐患型，在原始情景中，III区域包含上海、江苏、山东等省市部分地区，其三项指标均较低，属于衰退-潜力型，人口增长缓慢或出现负增长，但性别较为平衡且劳动人口抚养压力小，生育潜力较大，通过适当引导即可实现人口增长。在各类生育友好情景下，区域人口可持续类型发生变化，人口发展可持续性区域划分结果存在显著差异，表明社会情景动对人口发展区域相似性有重大影响。结合人口发展类型及具体指标情况，地区可根据发展<a href="https://imgse.com/i/pplzhCt"><div align=center><img src="https://s1.ax1x.com/2023/03/14/pplzhCt.jpg" alt="pplzhCt.jpg"></a><br>图8 多情景人口发展可持续评价区域化结果图<div align=left></p><h3 id="3-作品特点"><a href="#3-作品特点" class="headerlink" title="3 作品特点"></a>3 作品特点</h3><h4 id="3-1-仿真性"><a href="#3-1-仿真性" class="headerlink" title="3.1 仿真性"></a>3.1 仿真性</h4><p>在本作品中，人被视作拥有特有属性和情感智慧的真实个体，个体的行为决策构成了整体的共享决策，基于此构建的模型自下而上地还原了人类个体的生命进程和人类社会总体发展的真实情境。</p><h4 id="3-2-社会现实性"><a href="#3-2-社会现实性" class="headerlink" title="3.2 社会现实性"></a>3.2 社会现实性</h4><p>本作品面向人口问题进行仿真建模，并设置多个民生关切的现实情景，通过政策模拟与推演来探索人口响应规律，为国家战略制定与调整提供启示性参考，具有丰富的现实意义与应用价值。</p><h4 id="3-2-直观可视性"><a href="#3-2-直观可视性" class="headerlink" title="3.2 直观可视性"></a>3.2 直观可视性</h4><p>作品中运用的时空立方体2D及3D可视化技术将时空数据用多维立体的形式展现出来，直观地展现了时间序列的变化趋势，便于使用者厘清时空数据的结构、变化趋势和时空分异特征。</p><h3 id="4-意义及展望"><a href="#4-意义及展望" class="headerlink" title="4 意义及展望"></a>4 意义及展望</h3><p>本作品为科学把握人口发展规律，促进人口可持续发展提供参考。政策鼓励与国民福利保障方面，优化生育政策，加强生育家庭医保、购房租房等福利保障；经济支持与婚育压力缓解方面，完善假期用工成本分担机制，提高居民收入，延长假期，缓解积蓄少与时间紧带来的生育压力；在设施健全与公共服务提质方面，完善住房、医疗等基础设施条件，加快发展普惠托育服务体系，构建全面生育友好的社会环境。</p><p>后续研究拟深入挖掘个体交互行为，拓宽模型适用范围以用于解决其他人口问题；在现有分析基础上，将进一步探索基于人口动态发展时间序列的聚类分析，并顾及空间约束进行地理分区，为国家政策实施与管理提供便利。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2022ESRI大赛参赛作品（一等奖）。&lt;br&gt;</summary>
    
    
    
    <category term="作品" scheme="https://atffang.github.io/categories/%E4%BD%9C%E5%93%81/"/>
    
    
  </entry>
  
  <entry>
    <title>VS2019-AnalysisService部署数据挖掘无法连接服务器的问题</title>
    <link href="https://atffang.github.io/2023/03/13/VS2019-AnalysisService%E9%83%A8%E7%BD%B2%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://atffang.github.io/2023/03/13/VS2019-AnalysisService%E9%83%A8%E7%BD%B2%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2023-03-13T07:51:36.000Z</published>
    <updated>2023-03-24T09:00:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>VS2019-AnalysisService挖掘SQLServer2012数据库时，无法连接本地服务器的问题<br><span id="more"></span><br>&emsp;&emsp;起因是使用Visual Studio2019的Analysis Service模块，对SQLServer2012数据库进行挖掘时，部署后软件报错：无法连接localhost服务器，遂找了各种资料，最终综合两个方法解决了问题。<br>首先，在Visual Studio2019挖掘项目的属性-部署中，可以看到服务器名为localhost，即本台电脑。<br>但在SQLServer中，服务器名却为：<br><a href="https://imgse.com/i/ppQwGut"><div align=center><img src="https://s1.ax1x.com/2023/03/13/ppQwGut.md.jpg" alt="ppQwGut.md.jpg"></a><div align=left><br>即localhost+数据库实例名，因此，将Visual Studio2019中的服务器也改为相同的名称：<br><a href="https://imgse.com/i/ppQwJDP"><div align=center><img src="https://s1.ax1x.com/2023/03/13/ppQwJDP.md.jpg" alt="ppQwJDP.md.jpg"></a><div align=left><br>替换后，我的项目部署时仍然报错：缺少用户名NT SERVICE\MSOLAP$SQLSERVE。此时只需要在SQLServer中的安全性-登录名中，新建该登录名，并赋予其一定的权限即可。<br><a href="https://imgse.com/i/ppQwYHf"><div align=center><img src="https://s1.ax1x.com/2023/03/13/ppQwYHf.md.jpg" alt="ppQwYHf.md.jpg"></a><div align=left></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;VS2019-AnalysisService挖掘SQLServer2012数据库时，无法连接本地服务器的问题&lt;br&gt;</summary>
    
    
    
    <category term="或许用得到的tips" scheme="https://atffang.github.io/categories/%E6%88%96%E8%AE%B8%E7%94%A8%E5%BE%97%E5%88%B0%E7%9A%84tips/"/>
    
    
  </entry>
  
  <entry>
    <title>核密度分析</title>
    <link href="https://atffang.github.io/2023/03/13/%E6%A0%B8%E5%AF%86%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <id>https://atffang.github.io/2023/03/13/%E6%A0%B8%E5%AF%86%E5%BA%A6%E5%88%86%E6%9E%90/</id>
    <published>2023-03-13T02:59:32.000Z</published>
    <updated>2023-10-07T14:01:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单介绍了GIS空间分析/地统计中极其基础，但非常重要的算法：核密度分析<br><span id="more"></span><br>&emsp;&emsp;核密度估计法认为地理事件可以发生在空间的任何位置上，但是不同的位置上事件发生的概率不一样。点密集的区域事件发生的概率高，点稀疏的地方事件发生的概率低，核密度估计即获得随机变量在每个可能取值处出现的概率。<br>&emsp;&emsp;根据概率理论（Rosenblatt-Parzen核估计），核密度估计的定义为：</p><script type="math/tex; mode=display">\hat{f}_h(x) = \frac{1}{nh}\sum_{i=1}^{n}K_h(x - x_i)</script><p>&emsp;&emsp;其中，$X1,……Xn$为从分布密度函数为f的总体中抽取的样本，$f_n (x)$是估计函数f在某点x处的值。$K()$称为核函数，h为带宽，$(x-Xi)$表示估值点x到事件Xi处的距离。<br>&emsp;&emsp;核函数的选择对统计结果有很大的影响。常用的核函数主要为经典核函数，高斯核函数、四次多项式函数等。其中，高斯核函数的公式为：</p><script type="math/tex; mode=display">K_h(x) = \frac{1}{\sqrt{2\pi}h}\exp\left(-\frac{x^2}{2h^2}\right)</script><p>&emsp;&emsp;读者可以发现，所谓高斯核函数，其实就是高斯分布概率函数的变换，相比高斯概率密度函数：</p><script type="math/tex; mode=display">f(x) = \frac{1}{\sqrt{2\pi}\sigma}\exp\left(-\frac{(x-\mu)^2}{2\sigma^2}\right)</script><p>&emsp;&emsp;核密度函数将标准差$\sigma$ 换成了带宽$h$，将$x-\mu$(均值)换成了$x - x_i$（核密度估计函数里的高斯核函数，自变量为$x - x_i$）。实际上，就是将高斯函数作为加权工具。让我们回到一开始描述的核密度估计的目的：获得随机变量在每个可能取值处出现的概率，剖析一下这一问题。<br>&emsp;&emsp;1970年，地理学家威廉·托布勒（William Tobler）提出了著名的地理学第一定律：<br>“Everything is related to everything else, but near things are more related than distant things.”<br>&emsp;&emsp;翻译过来的就是“一切事物都与其他事物相关，但接近的事物比远离的事物更相关。”这条定律的核心思想是：地理空间上距离越近的地方，它们之间的相互作用和相似性就越高，距离越远的地方则相互作用和相似性就越低。这意味着地理空间上的事物不是孤立的存在，而是相互联系、相互作用的。<br>&emsp;&emsp;譬如你的唯二两个邻居李二王五都身家千万，那么地理学家会估计你也是个富哥。继续增加条件，李二身家1000万，他家距离你家2km，王五身家2000万，他家距离你家3km，那么地理学家可以将你的身家推算为：(1000x2+2000x3)/(2+3)=1600万，这就是地理学中著名的反距离权重插值：</p><script type="math/tex; mode=display">z_0 = \frac{\sum_{i=1}^{n}w_i z_i}{\sum_{i=1}^{n}w_i}</script><p>&emsp;&emsp;现在你了解了地理学中空间连续的思想，再回头重新理解核密度函数，其概念可以被解释为：用区域内事件的多少，来估计该地发生事件的概率。并且，越靠近该位置的地方发生的事件，必然对该位置是否发生事件的影响更大，这大小体现在权重上，因此上述高斯核函数，就是对传统的反距离加权的补充，相比反距离函数，高斯函数在概率上更加贴合现实情况。</p><p>&emsp;&emsp;为演示，我使用海南省两个仙级行政区人口分布数据做了简单的核密度分析。图中，sigma即带宽h。<br><a href="https://imgse.com/i/ppQJdyT"><div align=center><img src="https://s1.ax1x.com/2023/03/13/ppQJdyT.md.jpg" alt="ppQJdyT.md.jpg"></a><div align=left><br>&emsp;&emsp;可以清晰的看到，随着内核直径sigma的增加，核密度估计的影响范围也沿着点像四周扩散。每个数据点对密度估计的贡献范围就越大，产生更加粗略的密度图像。<br><a href="https://imgse.com/i/pplQMuQ"><div align=center><img src="https://s1.ax1x.com/2023/03/14/pplQMuQ.jpg" alt="pplQMuQ.jpg"></a><div align=left><br>&emsp;&emsp;高斯核函数（Gaussian kernel）具有平滑的形状，能够很好地把每个数据点的影响扩散到周围的区域。高斯核函数的带宽与核宽度是同一个概念，均等于核函数的标准差（sigma）。<br>&emsp;&emsp;经典核函数（epanechnikov kernel）具有类似三角形的形状，在距离较近的区域有较大的权重，而在距离较远的区域权重减小。经典核函数的带宽等于核函数的最大值，即 2。核宽度则等于带宽的一半，即 1。<br>&emsp;&emsp;四次多项式函数（quartic kernel）具有类似方形的形状，在距离较近的区域有较大的权重，而在距离较远的区域权重减小。四次多项式函数的带宽和核宽度由使用者定义。<br>&emsp;&emsp;圆锥函数（disc kernel）具有类似圆锥形的形状，在距离较近的区域有较大的权重，而在距离较远的区域权重减小。圆锥函数的带宽（bandwidth）等于核函数的最大值，即 2。核宽度（kernel width）则等于带宽的一半，即 1。<br>&emsp;&emsp;在图中可以看到，前三种插值方式得出的结果较为相似，都相对平滑，但是圆锥核函数插值得出的结果则较为粗糙，且数据间过渡不平滑。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文简单介绍了GIS空间分析/地统计中极其基础，但非常重要的算法：核密度分析&lt;br&gt;</summary>
    
    
    
    <category term="空间分析与GIS算法" scheme="https://atffang.github.io/categories/%E7%A9%BA%E9%97%B4%E5%88%86%E6%9E%90%E4%B8%8EGIS%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>2022，我们的记忆</title>
    <link href="https://atffang.github.io/2022/12/31/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://atffang.github.io/2022/12/31/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</id>
    <published>2022-12-31T15:54:15.000Z</published>
    <updated>2023-03-24T09:05:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个时代遗忘的疾病正变得越来越严重，仅一下2022年发生的事情，为以后翻阅。<br><span id="more"></span></p><The rest of contents | 余下全文><img src="/2022/12/31/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/2022.jpg" class="" title="sucessful">]]></content>
    
    
    <summary type="html">&lt;p&gt;这个时代遗忘的疾病正变得越来越严重，仅一下2022年发生的事情，为以后翻阅。&lt;br&gt;</summary>
    
    
    
    <category term="随想录" scheme="https://atffang.github.io/categories/%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo框架下部署个人博客</title>
    <link href="https://atffang.github.io/2022/10/15/hexo%E6%A1%86%E6%9E%B6%E4%B8%8B%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://atffang.github.io/2022/10/15/hexo%E6%A1%86%E6%9E%B6%E4%B8%8B%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2022-10-15T06:47:14.000Z</published>
    <updated>2023-11-12T02:59:46.318Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下第一次使用hexo框架的摸索过程<br><span id="more"></span></p><h4 id="啰嗦两句"><a href="#啰嗦两句" class="headerlink" title="啰嗦两句"></a>啰嗦两句</h4><p>&emsp;&emsp;参考了很多篇博客，花了一天时间终于把不那么完整的博客上线了，对于我这个HTML小白来说还是挺有成就感的哈哈，简单记录一下。<br>&emsp;&emsp;Hexo是一个快速、简介的博客框架，用户可以将Markdown格式文件上传并生成网页。以下是我进行部署时的步骤与一些要点：</p><h4 id="Step1：安装Git与node-js"><a href="#Step1：安装Git与node-js" class="headerlink" title="Step1：安装Git与node.js"></a>Step1：安装Git与node.js</h4><p>1.1 <strong>安装Git</strong> &emsp;&emsp;官网：<a href="https://git-scm.com/">https://git-scm.com/</a></p><p>1.2  <strong>安装node</strong> &emsp;&emsp;官网：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p><p>1.3  在系统环境变量中添加node的路径，以确保你的电脑能访问到他<br>（系统环境变量：右击此电脑-属性-高级系统设置-环境变量）</p><p>1.4  打开gitbash命令界面，输入以下命令检验是否安装成功：<br>  <code>node -v</code><br> <code>npm -v</code></p><img src="/2022/10/15/hexo%E6%A1%86%E6%9E%B6%E4%B8%8B%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/01hexo1.jpg" class="" title="sucessful"><h4 id="Step2：安装hexo"><a href="#Step2：安装hexo" class="headerlink" title="Step2：安装hexo"></a>Step2：安装hexo</h4><p>2.1  更换国内镜像源：防止下载速度过慢<br><code>npm config set registry https://registry.npm.taobao.org</code></p><p>2.2  确认更换状态：<br><code>npm config get registry</code></p><p>2.3  进入node安装目录，创建文件夹<code>node_global</code>和<code>node_cache</code> 并执行以下命令</p><img src="/2022/10/15/hexo%E6%A1%86%E6%9E%B6%E4%B8%8B%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/01hexo.2.jpg" class="" title="sucessful"><p><code>npm config set prefix &quot;D:\programming\nodejs\node_global&quot;</code><br><code>npm config set cache &quot;D:\programming\nodejs\node_cache&quot;</code></p><p>2.4 环境配置：新增环境变量<code>NODE_PATH</code>和添加<code>Path</code>（用户变量和系统变量），两个值都为 <code>\node_global</code>文件夹位置。</p><p>2.5 <strong>安装hexo</strong>!<br>在你想要安装hexo的地方（我在node里）右键：gitbash here<br><code>npm install hexo-cli -g</code><br>可以再装个：<br><code>npm install hexo -save</code></p><h4 id="Step3：新建博客文件夹"><a href="#Step3：新建博客文件夹" class="headerlink" title="Step3：新建博客文件夹"></a>Step3：新建博客文件夹</h4><p>3.1 新建一个blog文件夹</p><p>3.2 gitbash here，输入<code>hexo init</code>，初始化hexo环境</p><p>3.3 输入<code>npm install</code>，安装npm依赖包</p><p>3.4 输入<code>hexo generate</code>或者是<code>hexo g</code>，生成静态页面，输入<code>hexo server</code>或者是<code>hexo s</code>，打开静态页面链接查看生成的hexo博客</p><p>3.5 <code>ctrl+C</code>关闭</p><h4 id="Step4：连接至GitHub"><a href="#Step4：连接至GitHub" class="headerlink" title="Step4：连接至GitHub"></a>Step4：连接至GitHub</h4><p>&emsp;&emsp; 在之前的步骤中，我们只是生成了一个本机才能访问的页面，接下来我们利用GitHub使所有人都可以访问你的网页</p><p>4.1 确保你拥有一个<strong>科学上网</strong>的途径以及一个GitHub账号</p><p>4.2 使本机和GitHub可以连接：</p><p>&emsp;&emsp; 4.2.1 检验本机是否产生过秘钥<br>&emsp;&emsp;&emsp;&emsp; <code>cd ~/.ssh</code><br>&emsp;&emsp;&emsp;&emsp;  <code>ls</code></p><p> &emsp;&emsp; 4.2.2 如果没有，执行以下命令来生成密钥：<br>&emsp;&emsp;&emsp;&emsp;  <code>ssh-keygen -t rsa -C &quot;自己的邮箱地址&quot;</code></p><p>&emsp;&emsp; 4.2.3 按三次回车，生成成功后，去对应默认路径里用记事本打开id_rsa.pub，得到ssh key公钥。</p><p> &emsp;&emsp; 4.2.4 在个人GitHub账号里，找到setting-&gt;SSH and GPG keys-&gt;new SSH key，输入title，将id_rsa.pub中的内容粘贴到下面key中，点击下面的add SSH key。</p><p>&emsp;&emsp; 4.2.5 新建一个GitHub仓库，命名为<code>username.github.io</code></p><h4 id="Step5：设置博客文件夹"><a href="#Step5：设置博客文件夹" class="headerlink" title="Step5：设置博客文件夹"></a>Step5：设置博客文件夹</h4><p>5.1 在之前新建的博客文件夹（我之前提到的blog文件夹）中，打开配置文件_config.yml，按照以下方式更改：</p><img src="/2022/10/15/hexo%E6%A1%86%E6%9E%B6%E4%B8%8B%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/01hexo.3.jpg" class="" title="sucessful"><p>5.2 在Git Bash中执行<code>npm install hexo-deployer-git --save</code>命令</p><p>5.3 最后执行 <code>hexo deploy</code>或者<code>hexo d</code>，完成部署</p><h4 id="Step6：发布文章"><a href="#Step6：发布文章" class="headerlink" title="Step6：发布文章"></a>Step6：发布文章</h4><p>6.1 Git Bash中输入<code>hexo new title</code>，title是文章的名字。完成后可以看到在<code>\Blog\hexo\source_posts\</code> 文件夹中新建了一个markdown文件</p><p>6.2 编辑文件，执行<code>hexo g</code> 与<code>hexo d</code> 即可发布</p><p>6.3 访问<strong><code>username.github.io</code></strong>查看博客</p><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>当然，以上是最简单的博客部署方式，你可以下载不同的主题(theme)并更改配置文件以更改主题，获得更好的视觉效果</p><p>注意，更改配置文件后，出现无法提交的问题，一个原因是改错了，一个原因是网速，此时重新部署，或先执行<code>hexo clean</code>，再g、d。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一下第一次使用hexo框架的摸索过程&lt;br&gt;</summary>
    
    
    
    <category term="或许用得到的tips" scheme="https://atffang.github.io/categories/%E6%88%96%E8%AE%B8%E7%94%A8%E5%BE%97%E5%88%B0%E7%9A%84tips/"/>
    
    
  </entry>
  
</feed>
