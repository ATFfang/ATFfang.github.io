<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ATField&#39; s BLOG</title>
  
  <subtitle>ATField</subtitle>
  <link href="https://atffang.github.io/atom.xml" rel="self"/>
  
  <link href="https://atffang.github.io/"/>
  <updated>2025-05-29T15:43:56.554Z</updated>
  <id>https://atffang.github.io/</id>
  
  <author>
    <name>FangTianYao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>继续聊聊异步</title>
    <link href="https://atffang.github.io/2025/05/29/%E7%BB%A7%E7%BB%AD%E8%81%8A%E8%81%8A%E5%BC%82%E6%AD%A5/"/>
    <id>https://atffang.github.io/2025/05/29/%E7%BB%A7%E7%BB%AD%E8%81%8A%E8%81%8A%E5%BC%82%E6%AD%A5/</id>
    <published>2025-05-29T15:39:59.000Z</published>
    <updated>2025-05-29T15:43:56.554Z</updated>
    
    <content type="html"><![CDATA[<p>介绍一下最大似然</p><span id="more"></span><p>在之前的文章中（指路[<a href="https://atffang.github.io/2025/02/21/asyncio%E6%B5%85%E6%9E%90/#more">https://atffang.github.io/2025/02/21/asyncio浅析/#more</a>]），我们简单学习了python的asynicio机制，但当我回看这篇文章时，仍然觉得许多东西——特别是概念，没有讲清楚。因此有了这篇文章，我们将从底层机制开始介绍python中的异步操作。</p><h3 id="为什么要异步"><a class="markdownIt-Anchor" href="#为什么要异步"></a> 为什么要异步？</h3><p>中国人应该都听过华罗庚烧开水的故事。其中办法甲是洗好水壶，灌上凉水，放在火上；在等待水开的时间里，洗茶壶、洗茶杯、拿茶叶；等水开了，泡茶喝。等待某个事件完成（比如水开）时，如果一直干等，时间就被浪费了；如果能利用等待时间去做其他有意义的事情，效率就会更高。在程序设计中，也是如此：</p><p>当程序遇到“必须等待”的操作时，比如等待网络响应、磁盘读写、用户输入，如果我们像传统方式那样干等，就会浪费大量宝贵时间。而如果我们能在等待的间隙去做别的事情，整体运行效率就能大幅提升。</p><p>这就是 <strong>异步编程（Asynchronous Programming）</strong> 的核心思想。异步编程是一种程序设计方式，它允许程序在遇到耗时操作时“暂时挂起当前任务”，去执行其他任务，待耗时操作完成后再回来继续执行。这样，程序不会因为等待某个操作而“卡死”或闲置，特别适合处理大量 I/O 操作的场景。</p><h3 id="协程"><a class="markdownIt-Anchor" href="#协程"></a> 协程</h3><p>协程（Coroutine）是一种程序结构，允许函数在执行过程中暂停（挂起）并在未来某个时间恢复执行。它是一种“可暂停的函数”，实现了非抢占式的多任务协作。通俗来说，协程可以在执行中途“让出控制权”，让其他协程运行，等到时机合适再“继续执行”，而不是像线程那样被操作系统抢占。</p><p>Python中的协程，特别是用 async def 定义的异步协程，实际上是基于<strong>生成器（generator）</strong> 机制演化而来的。生成器是一种特殊的迭代器，它可以在执行过程中暂停，并在需要时恢复执行。生成器函数使用 yield 关键字来生成值，每次调用 yield 时，函数会暂停执行，并返回一个值给调用者。下次调用生成器时，函数会从上次暂停的地方继续执行。这种暂停等待执行的状态成为<strong>挂起</strong>，传统函数调用有自己的调用栈，调用结束后栈帧销毁，而挂起状态的函数并不会销毁内部变量和参数。</p><p>Python中，每次函数调用都会创建一个 帧对象（PyFrameObject，C语言结构体），它包含了函数执行的所有上下文信息：</p><ul><li>当前指令指针（程序计数器，PC），指示下一条要执行的字节码位置</li><li>局部变量和参数</li><li>操作数栈状态</li><li>代码对象引用</li></ul><p>生成器和协程本质上也是函数调用，只不过在挂起时不会销毁帧对象，而是把它冻结保存起来。当协程执行到await或者yield时，Python解释器暂停执行当前帧，保存当前指令指针位置（即当前字节码执行到哪一步了）。局部变量、操作栈以及执行环境的状态都保存在该帧对象内，这个帧对象作为生成器/协程对象的内部状态，存活在内存中。当事件循环或调度器认为条件满足（比如等待的异步I/O完成），它会调用生成器/协程的 <code>.send()</code> 或 <code>.__await__()</code> 方法，让Python解释器加载之前保存的帧对象状态，从断点处继续执行字节码。</p><h3 id="事件循环"><a class="markdownIt-Anchor" href="#事件循环"></a> 事件循环</h3><p><strong>事件循环（Event Loop）</strong> 是异步编程的核心调度机制，它不断循环监视“任务队列”或“事件源”，并在任务准备好执行时唤醒它们。我们在之前的文章中已经提到，协程对象执行到 <code>await</code> 会挂起并返回控制权，而要继续执行，就必须有一个机制来等待 <code>await</code> 的异步任务完成，再恢复暂停的协程。这个“等待+恢复”的过程，由事件循环自动调度完成。事件循环由下面四个关键部分组成：</p><ul><li><p><strong>Task 队列（任务队列）</strong><br />一个 Task 是对协程的封装，用于注册到事件循环中，并自动驱动协程的执行流程。协程对象会被封装为 asyncio.Task 对象，并加入事件循环管理的队列。</p></li><li><p><strong>Future 对象</strong><br />表示一个尚未完成的异步操作，类似于 JavaScript 的 Promise。Future是Task的父类，而await 的结果通常是 Future。</p></li><li><p><strong>IO 多路复用器</strong><br />使用操作系统的 select/epoll/kqueue/IOCP 来等待 I/O 事件。每个 await 的对象会注册一个 I/O 事件（如 socket 可读、定时器到期），这些事件会被提交到 selector，操作系统会在事件准备好时通知事件循环，事件循环再调用回调函数恢复协程。</p></li><li><p><strong>调度器</strong><br />调度器是事件循环的大脑，它控制协程的暂停与恢复。协程本质是生成器（generator）的拓展，调度行为是调用其 <code>send()</code> 或 <code>throw()</code> 方法。协程首次执行相当于 <code>coro.send(None)</code>，遇到 <code>await</code> 时将控制权交还给事件循环，并返回一个 <code>Future</code> 对象。事件循环等待 <code>Future</code> 对象完成，然后调用 <code>task._step()</code> 方法，执行 <code>coro.send(result)</code> ，恢复协程执行直到下一个 <code>await</code> 或结束。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+---------------------------+</span><br><span class="line">| asyncio.Task |</span><br><span class="line">| - 包含一个协程对象 |</span><br><span class="line">+---------------------------+</span><br><span class="line">↓</span><br><span class="line">初始执行 coro.send(<span class="literal">None</span>)</span><br><span class="line">↓</span><br><span class="line">协程执行 → 遇到 <span class="keyword">await</span></span><br><span class="line">↓</span><br><span class="line">返回 Future，挂起协程</span><br><span class="line">↓</span><br><span class="line">Future 注册到底层 IO selector</span><br><span class="line">↓</span><br><span class="line">事件完成 → Future 被标记为 done</span><br><span class="line">↓</span><br><span class="line">唤醒 Task → 再次执行 coro.send(result)</span><br><span class="line">↓</span><br><span class="line">直至结束</span><br></pre></td></tr></table></figure><h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h3><h4 id="爬虫"><a class="markdownIt-Anchor" href="#爬虫"></a> 爬虫</h4><p>任务目标：我们有 5 个网页，要同时请求它们的内容并提取标题。我们希望在不阻塞主线程的情况下完成所有请求。如果使用串行执行的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">  </span><br><span class="line">urls = [</span><br><span class="line"><span class="string">&quot;https://1.com&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://2.com&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://3.com&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://4.com&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://5.com&quot;</span></span><br><span class="line">] </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_title</span>(<span class="params">url</span>):</span><br><span class="line">response = requests.get(url)</span><br><span class="line"><span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;url&#125;</span> - status: <span class="subst">&#123;response.status_code&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line"><span class="built_in">print</span>(get_title(url))</span><br></pre></td></tr></table></figure><p>所有请求会一个接一个等。<br />如果使用异步方式（并发请求，非阻塞）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_title</span>(<span class="params">session, url</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">        text = <span class="keyword">await</span> response.text()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;url&#125;</span> - status: <span class="subst">&#123;response.status&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        tasks = [get_title(session, url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">        results = <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> results:</span><br><span class="line">            <span class="built_in">print</span>(r)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><h4 id="处理大量文件上传"><a class="markdownIt-Anchor" href="#处理大量文件上传"></a> 处理大量文件上传</h4><p>你在做一个网站，有很多用户同时上传文件（比如照片），你需要接收上传请求/将文件保存到磁盘或对象存储/同时记录用户上传日志（如用户名、时间、文件名）到数据库或日志文件中。<br />如果使用同步方式，所有请求会一个接一个等，用户上传文件时，其他用户只能等待:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_file</span>(<span class="params">user, file_name</span>):</span><br><span class="line">    time.sleep(<span class="number">2</span>)  <span class="comment"># 模拟写文件</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[保存] 用户 <span class="subst">&#123;user&#125;</span> 上传了 <span class="subst">&#123;file_name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log_upload</span>(<span class="params">user, file_name</span>):</span><br><span class="line">    time.sleep(<span class="number">1</span>)  <span class="comment"># 模拟写日志</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[日志] 记录 <span class="subst">&#123;user&#125;</span> 上传了 <span class="subst">&#123;file_name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_upload</span>(<span class="params">user, file_name</span>):</span><br><span class="line">    save_file(user, file_name)</span><br><span class="line">    log_upload(user, file_name)</span><br><span class="line"></span><br><span class="line">users = [(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;a.png&quot;</span>), (<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;b.jpg&quot;</span>), (<span class="string">&quot;Carol&quot;</span>, <span class="string">&quot;c.docx&quot;</span>)]</span><br><span class="line"><span class="keyword">for</span> user, file <span class="keyword">in</span> users:</span><br><span class="line">    handle_upload(user, file)</span><br></pre></td></tr></table></figure><p>如果使用异步方式，所有请求可以同时处理，用户上传文件时，其他用户可以继续上传。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">save_file</span>(<span class="params">user, file_name</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)  <span class="comment"># 模拟异步写文件</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[保存] 用户 <span class="subst">&#123;user&#125;</span> 上传了 <span class="subst">&#123;file_name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">log_upload</span>(<span class="params">user, file_name</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)  <span class="comment"># 模拟异步写日志</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[日志] 记录 <span class="subst">&#123;user&#125;</span> 上传了 <span class="subst">&#123;file_name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_upload</span>(<span class="params">user, file_name</span>):</span><br><span class="line">    <span class="keyword">await</span> save_file(user, file_name)</span><br><span class="line">    <span class="keyword">await</span> log_upload(user, file_name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    users = [(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;a.png&quot;</span>), (<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;b.jpg&quot;</span>), (<span class="string">&quot;Carol&quot;</span>, <span class="string">&quot;c.docx&quot;</span>)]</span><br><span class="line">    tasks = [handle_upload(user, file) <span class="keyword">for</span> user, file <span class="keyword">in</span> users]</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍一下最大似然&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>重返统计学1：从最大似然开始</title>
    <link href="https://atffang.github.io/2025/05/28/%E9%87%8D%E8%BF%94%E7%BB%9F%E8%AE%A1%E5%AD%A62%E4%BB%8E%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E5%BC%80%E5%A7%8B/"/>
    <id>https://atffang.github.io/2025/05/28/%E9%87%8D%E8%BF%94%E7%BB%9F%E8%AE%A1%E5%AD%A62%E4%BB%8E%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E5%BC%80%E5%A7%8B/</id>
    <published>2025-05-28T14:24:16.000Z</published>
    <updated>2025-05-28T14:28:10.645Z</updated>
    
    <content type="html"><![CDATA[<p>介绍一下最大似然</p><span id="more"></span><img src="https://atffang.github.io/2025/05/28/重返统计学2从最大似然开始/MLE.png"/>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍一下最大似然&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>重返统计学0：绪论</title>
    <link href="https://atffang.github.io/2025/05/27/%E9%87%8D%E8%BF%94%E7%BB%9F%E8%AE%A1%E5%AD%A60%E7%BB%AA%E8%AE%BA/"/>
    <id>https://atffang.github.io/2025/05/27/%E9%87%8D%E8%BF%94%E7%BB%9F%E8%AE%A1%E5%AD%A60%E7%BB%AA%E8%AE%BA/</id>
    <published>2025-05-27T12:20:35.000Z</published>
    <updated>2025-05-27T12:21:22.983Z</updated>
    
    <content type="html"><![CDATA[<p>挖个坑</p><span id="more"></span><p>作为一个地理系的学生，诚实的说，我对数学与统计学的认识十分有限而肤浅。唯一的训练是在本科时的基础课程概率论课上，那时正值南京新冠最严重的22年年初，多数的课通过网课的形式完成，或许这里面一多半时间还在睡梦中。在此之后，除了零零碎碎接触的知识，再也没系统性的学习过统计学，以至于现在总是力不从心。因此，打算新开一个坑，从一个小白的角度重新学习面向机器学习与地理的统计学知识，共勉！</p><p>统计学（Statistics）一词源自拉丁语 status（意为“国家事务”），最早在17世纪的德意志地区，用于指代关于国家人口、土地、税收的系统性数据收集与描述，被称为“政治算术”（Political Arithmetic）。随着时代发展，它逐渐脱离行政统计的原始功能，<strong>成为一门研究不确定性、分析数据规律、从样本推断总体的科学</strong>。</p><p>统计学的形成并非一蹴而就，而是在长期应对不确定性与社会复杂性的历史进程中逐步建立起来的。最初，17世纪的“政治算术”是统计思想的雏形，约翰·格朗特与威廉·配第通过对伦敦死亡票据的分析，首次尝试利用数据揭示人口规律，这种自国家行政管理中抽离出的数量思维，构成了统计学最早的社会实践背景。18世纪，雅各布·伯努利提出了大数定律，强调了样本频率与真实概率之间的趋同关系，拉开了从经验总结向概率理论过渡的序幕。同一时期，贝叶斯定理的提出标志着另一种思维路径的诞生，即将先验知识与数据更新相结合，探索对不确定现象进行概率建模的可能性</p><p>进入19世纪，随着数学分析的发展，统计学逐渐获得更加严密的形式化基础。高斯在误差理论中提出正态分布和最小二乘估计，拉普拉斯则将概率方法应用于天体运动分析，他们的工作将统计方法首次嵌入自然科学建模之中，也开启了参数估计与模型拟合的时代。到20世纪，统计学迎来了系统化的理论建构。罗纳德·费雪被广泛认为是现代统计学的奠基者之一，他不仅提出了极大似然估计、方差分析、设计实验等核心概念，还在哲学上确立了频率派立场，主张在重复试验中定义概率，并强调统计推断的客观性。与之并立的则是以杰弗里斯和萨维奇为代表的贝叶斯学派，强调知识的不确定性来源于认知主体本身，通过主观先验与后验更新，实现具有解释力的模型推理。这一“客观 vs 主观”、“频率 vs 信念”的思想分歧，至今仍构成统计方法论上的根本张力。</p><p>到了21世纪，随着计算能力的跃升与数据体量的激增，统计学与人工智能、机器学习逐步融合，形成了以预测精度、模型泛化能力为导向的新范式。在这一背景下，统计学习理论、正则化方法、贝叶斯推理和高维建模成为主流应用技术的理论支柱。统计模型不再仅仅用于科学实验与假设检验，而广泛应用于图像识别、自然语言处理、医疗诊断、政策评估等复杂系统的建模中，进一步模糊了“推断”与“预测”的边界。</p><p><strong>统计学的核心使命，是在面对不确定性和变异性的现实世界中，从有限样本中提取信息、推断总体特征，建立描述或解释变量间关系的模型</strong>。</p><p>频率与概率的区别，是统计学中一个根本而经典的问题，也正是区分统计学两大主要流派——频率派（Frequentist）和贝叶斯派（Bayesian）的核心所在。</p><p>在频率派统计学中，概率被严格定义为在大量重复独立试验中某事件发生的相对频率的极限。也就是说，概率是一个长期稳定出现的频率值，它是客观存在且可通过反复实验验证的数值。例如，抛硬币时正面朝上的概率是0.5，是在无限次抛掷中正面次数与总次数的比值趋近的极限。这种定义强调概率的客观性和实验可重复性，概率不存在于单次试验，而是长期统计规律的体现。</p><p>而在贝叶斯派中，概率则被解释为个体对某一事件发生不确定性的主观信念程度。概率是描述“知识状态”或“信息”的工具，可以用来表达对单个事件的可信度。贝叶斯概率不需要重复试验的物理基础，而是通过先验知识与新观测的结合，利用贝叶斯定理动态更新。比如，你对某个病人患病概率的估计，既包含医学知识，也包含个人观察结果，这种概率更像是“信念”的度量。</p><p>总结而言，频率派认为，参数是自然界固定的未知常数，数据是随机变量。统计推断的目标是利用样本数据来估计这些固定参数。而贝叶斯派则认为，参数本身就是随机变量，参数的不确定性通过一个先验分布来描述。在下一章中，我们将首先对这两个概念进行介绍，作为整个系列的引子。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;挖个坑&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>typing：规范友好的代码</title>
    <link href="https://atffang.github.io/2025/05/23/typing%E8%A7%84%E8%8C%83%E5%8F%8B%E5%A5%BD%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
    <id>https://atffang.github.io/2025/05/23/typing%E8%A7%84%E8%8C%83%E5%8F%8B%E5%A5%BD%E7%9A%84%E4%BB%A3%E7%A0%81/</id>
    <published>2025-05-23T02:27:49.000Z</published>
    <updated>2025-05-23T03:03:31.548Z</updated>
    
    <content type="html"><![CDATA[<p>使用typing增强Python代码的可读性、可维护性，并帮助静态分析工具进行错误检查。</p><span id="more"></span><p>Python 的 typing 模块是用于 <strong>类型注解和静态类型检查</strong> 的标准库工具。它为你编写类型安全、可读性强的大型代码提供了支持。</p><h3 id="基础类型和泛型容器类型"><a class="markdownIt-Anchor" href="#基础类型和泛型容器类型"></a> 基础类型和泛型容器类型</h3><p><strong>基础类型注解</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>, <span class="built_in">float</span>, <span class="built_in">str</span>, <span class="built_in">bool</span>, <span class="built_in">bytes</span></span><br></pre></td></tr></table></figure><ul><li>Python 内置类型就可以直接用作注解</li></ul><p><strong>泛型容器类型</strong></p><table><thead><tr><th><strong>类型</strong></th><th><strong>用法示例</strong></th></tr></thead><tbody><tr><td>List</td><td>List[int] — 整数列表</td></tr><tr><td>Dict</td><td>Dict[str, float] — 键为字符串，值为浮点数</td></tr><tr><td>Tuple</td><td>Tuple[int, str] — 二元组</td></tr><tr><td>Set</td><td>Set[int]</td></tr><tr><td>FrozenSet</td><td>FrozenSet[str]</td></tr></tbody></table><ul><li>Python 3.9+ 支持原生写法，如 <code>list[int]</code>替代 <code>List[int]</code>。<br />例如：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">average</span>(<span class="params">scores: <span class="type">List</span>[<span class="built_in">float</span>]</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(scores) / <span class="built_in">len</span>(scores)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(average([<span class="number">90.0</span>, <span class="number">85.5</span>, <span class="number">78.0</span>]))  <span class="comment"># 输出：84.5</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_student_score</span>(<span class="params">name: <span class="built_in">str</span>, records: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">float</span>]</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">    <span class="keyword">return</span> records[name]</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&quot;Alice&quot;</span>: <span class="number">91.5</span>, <span class="string">&quot;Bob&quot;</span>: <span class="number">88.0</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(get_student_score(<span class="string">&quot;Alice&quot;</span>, data))  <span class="comment"># 输出：91.5</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Tuple</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_student_info</span>() -&gt; <span class="type">Tuple</span>[<span class="built_in">str</span>, <span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">&quot;Alice&quot;</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">name, age = get_student_info()</span><br><span class="line"><span class="built_in">print</span>(name, age)  <span class="comment"># 输出：Alice 20</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span>, <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">total_scores</span>(<span class="params">data: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">return</span> &#123;name: <span class="built_in">sum</span>(scores) <span class="keyword">for</span> name, scores <span class="keyword">in</span> data.items()&#125;</span><br><span class="line"></span><br><span class="line">records = &#123;</span><br><span class="line">    <span class="string">&quot;Alice&quot;</span>: [<span class="number">90</span>, <span class="number">85</span>, <span class="number">92</span>],</span><br><span class="line">    <span class="string">&quot;Bob&quot;</span>: [<span class="number">78</span>, <span class="number">80</span>, <span class="number">74</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(total_scores(records))  <span class="comment"># 输出：&#123;&#x27;Alice&#x27;: 267, &#x27;Bob&#x27;: 232&#125;</span></span><br></pre></td></tr></table></figure><h3 id="通用类型工具"><a class="markdownIt-Anchor" href="#通用类型工具"></a> 通用类型工具</h3><table><thead><tr><th><strong>工具</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Any</td><td>任意类型</td></tr><tr><td>Union</td><td>多种类型之一，例如 Union[int, str]</td></tr><tr><td>Optional</td><td>可以是某种类型或 None，等价于 Union[T, None]</td></tr><tr><td>Callable</td><td>函数类型，例如 Callable[[int, int], str] 表示接受两个 int 返回 str 的函数</td></tr><tr><td>Literal</td><td>指定字面值，例如 Literal[‘yes’, ‘no’]</td></tr><tr><td>TypeVar</td><td>泛型类型变量（定义泛型函数或类时使用）</td></tr><tr><td>Generic</td><td>创建自定义泛型类时用</td></tr><tr><td>Final</td><td>声明不能被重写或赋值的变量/属性</td></tr><tr><td>ClassVar</td><td>用于声明类变量，而非实例变量</td></tr><tr><td>例如：</td><td></td></tr></tbody></table><h4 id="typevar"><a class="markdownIt-Anchor" href="#typevar"></a> TypeVar</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar, <span class="type">Tuple</span></span><br><span class="line"></span><br><span class="line">T = TypeVar(<span class="string">&#x27;T&#x27;</span>)  <span class="comment"># 声明一个通用类型变量 T</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">a: T, b: T</span>) -&gt; <span class="type">Tuple</span>[T, T]:</span><br><span class="line">    <span class="keyword">return</span> b, a</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(swap(<span class="number">1</span>, <span class="number">2</span>))          <span class="comment"># 输出: (2, 1)  —— T 被推断为 int</span></span><br><span class="line"><span class="built_in">print</span>(swap(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;bye&quot;</span>))   <span class="comment"># 输出: (&#x27;bye&#x27;, &#x27;hi&#x27;)  —— T 被推断为 str</span></span><br></pre></td></tr></table></figure><ul><li>T 可以是任何类型（int、str、float…）</li></ul><h4 id="generic"><a class="markdownIt-Anchor" href="#generic"></a> Generic</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar, <span class="type">Generic</span></span><br><span class="line"></span><br><span class="line">T = TypeVar(<span class="string">&#x27;T&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>(<span class="type">Generic</span>[T]):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, content: T</span>):</span><br><span class="line">        self.content = content</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>) -&gt; T:</span><br><span class="line">        <span class="keyword">return</span> self.content</span><br><span class="line"></span><br><span class="line">int_box = Box </span><br><span class="line"><span class="built_in">print</span>(int_box.get())  <span class="comment"># 输出: 123</span></span><br><span class="line"></span><br><span class="line">str_box = Box[<span class="built_in">str</span>](<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str_box.get())  <span class="comment"># 输出: hello</span></span><br></pre></td></tr></table></figure><ul><li><code>Box[T]</code> 表示这是一个“存放任意类型 T 的盒子”</li><li><code>Generic[T]</code> 表示类是“泛型类”</li></ul><h4 id="any"><a class="markdownIt-Anchor" href="#any"></a> Any</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Any</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_anything</span>(<span class="params">x: <span class="type">Any</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Received: <span class="subst">&#123;x&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">print_anything(<span class="number">42</span>)            <span class="comment"># int</span></span><br><span class="line">print_anything(<span class="string">&quot;hello&quot;</span>)       <span class="comment"># str</span></span><br><span class="line">print_anything([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])     <span class="comment"># list</span></span><br></pre></td></tr></table></figure><ul><li>Any 表示函数接受任何类型的数据</li></ul><h3 id="结构化和协议"><a class="markdownIt-Anchor" href="#结构化和协议"></a> 结构化和协议</h3><table><thead><tr><th><strong>类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Protocol</td><td>定义接口或行为协议（Python 3.8+）</td></tr><tr><td>TypedDict</td><td>类似 dict 的结构化类型注解</td></tr><tr><td>NamedTuple</td><td>类型注解版本的命名元组</td></tr><tr><td>dataclass</td><td>与 @dataclass 一起使用可以加注解</td></tr><tr><td>例如：</td><td></td></tr></tbody></table><h4 id="typeddict"><a class="markdownIt-Anchor" href="#typeddict"></a> TypedDict</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypedDict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">TypedDict</span>):</span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    is_active: <span class="built_in">bool</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">user: User</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Hello, <span class="subst">&#123;user[<span class="string">&#x27;name&#x27;</span>]&#125;</span>!&quot;</span></span><br><span class="line"></span><br><span class="line">u = &#123;<span class="string">&quot;id&quot;</span>: <span class="number">1</span>, <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;is_active&quot;</span>: <span class="literal">True</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(greet(u))  <span class="comment"># 输出: Hello, Alice!</span></span><br></pre></td></tr></table></figure><ul><li>明确了 user 必须包含哪些字段</li><li>静态检查工具（如 mypy）可以发现拼写错误或字段缺失</li></ul><h4 id="protocol"><a class="markdownIt-Anchor" href="#protocol"></a> Protocol</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Protocol</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reader</span>(<span class="title class_ inherited__">Protocol</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileReader</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;data from file&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dummy</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test data&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load</span>(<span class="params">r: Reader</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> r.read()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(load(FileReader()))  <span class="comment"># 输出: data from file</span></span><br><span class="line"><span class="built_in">print</span>(load(Dummy()))       <span class="comment"># 输出: test data</span></span><br></pre></td></tr></table></figure><p>当你只关心某个对象是否有某些方法或属性（而不是它的具体类型），使用 Protocol 可以定义“接口”，实现 Python 的“结构子类型检查”。</p><ul><li>load() 不关心对象的真实类型，只要有 .read() 方法就行</li><li>非侵入式，“只要像鸭子，它就能飞”（典型的 duck typing）</li></ul><h4 id="dataclasses"><a class="markdownIt-Anchor" href="#dataclasses"></a> dataclasses</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    is_active: <span class="built_in">bool</span> = <span class="literal">True</span>  <span class="comment"># 可以设置默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">u = User(<span class="built_in">id</span>=<span class="number">1</span>, name=<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(u)  <span class="comment"># 输出: User(id=1, name=&#x27;Alice&#x27;, is_active=True)</span></span><br></pre></td></tr></table></figure><ul><li>自动生成了 <strong>init</strong>() 方法</li><li>自动实现了 <strong>repr</strong>() 和 <strong>eq</strong>() 等方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass(<span class="params">order=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span>:</span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line">p1 = Product(<span class="number">19.9</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">p2 = Product(<span class="number">29.9</span>, <span class="string">&quot;B&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p1 &lt; p2)  <span class="comment"># True，按字段顺序比较（先比 price）</span></span><br></pre></td></tr></table></figure><ul><li>支持比较大小</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass, field</span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Token</span>:</span><br><span class="line">    value: <span class="built_in">str</span></span><br><span class="line">    secret: <span class="built_in">str</span> = field(<span class="built_in">repr</span>=<span class="literal">False</span>, compare=<span class="literal">False</span>)  <span class="comment"># 不显示、也不参与比较</span></span><br><span class="line"></span><br><span class="line">t1 = Token(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;secret123&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(t1)  <span class="comment"># 输出: Token(value=&#x27;abc&#x27;)</span></span><br></pre></td></tr></table></figure><p>忽略某个字段：field(repr=False, compare=False, default=…)</p><h3 id="特殊类型工具"><a class="markdownIt-Anchor" href="#特殊类型工具"></a> 特殊类型工具</h3><table><thead><tr><th><strong>类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>NewType</td><td>定义新的类型别名，例如：UserId = NewType(‘UserId’, int)</td></tr><tr><td>Type</td><td>类对象的类型，例如 Type[BaseClass]</td></tr><tr><td>Self</td><td>指代自身（Python 3.11+）</td></tr><tr><td>例如：</td><td></td></tr></tbody></table><h4 id="newtype"><a class="markdownIt-Anchor" href="#newtype"></a> NewType</h4><p>创建“伪新类型”，用于静态类型区分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> NewType</span><br><span class="line"></span><br><span class="line">UserId = NewType(<span class="string">&#x27;UserId&#x27;</span>, <span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_user_name</span>(<span class="params">user_id: UserId</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;User#<span class="subst">&#123;user_id&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">get_user_name(UserId(<span class="number">123</span>))  <span class="comment"># ✅ 正确</span></span><br><span class="line"><span class="comment"># get_user_name(123)        # ❌ mypy 会报错：需要 UserId，而不是 int</span></span><br></pre></td></tr></table></figure><h4 id="type"><a class="markdownIt-Anchor" href="#type"></a> Type</h4><p><code>Type[T]</code> 接收一个类对象（而不是实例）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Type</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Woof!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_animal</span>(<span class="params">animal_cls: <span class="type">Type</span>[Animal]</span>) -&gt; Animal:</span><br><span class="line">    <span class="keyword">return</span> animal_cls()</span><br><span class="line"></span><br><span class="line">a = make_animal(Dog)  <span class="comment"># ✅ 传类不是传对象</span></span><br><span class="line"><span class="built_in">print</span>(a.speak())      <span class="comment"># Woof!</span></span><br></pre></td></tr></table></figure><ul><li><code>Type[Animal]</code> 表示“Animal 的子类”，不是实例。</li></ul><h4 id="selfpython-311"><a class="markdownIt-Anchor" href="#selfpython-311"></a> Self(Python 3.11+)</h4><p>用于方法返回当前类类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Self</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Builder</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_name</span>(<span class="params">self, name: <span class="built_in">str</span></span>) -&gt; Self:</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_age</span>(<span class="params">self, age: <span class="built_in">int</span></span>) -&gt; Self:</span><br><span class="line">        self.age = age</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">b = Builder().set_name(<span class="string">&quot;Alice&quot;</span>).set_age(<span class="number">30</span>)</span><br></pre></td></tr></table></figure><ul><li>Self 解决了链式调用返回类型难以表达的问题。</li><li>自动适配子类返回自身，无需硬编码类名。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用typing增强Python代码的可读性、可维护性，并帮助静态分析工具进行错误检查。&lt;/p&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
  <entry>
    <title>不要用危险的字符拼接sql查询</title>
    <link href="https://atffang.github.io/2025/05/16/%E4%B8%8D%E8%A6%81%E7%94%A8%E5%8D%B1%E9%99%A9%E7%9A%84%E5%AD%97%E7%AC%A6%E6%8B%BC%E6%8E%A5sql%E6%9F%A5%E8%AF%A2/"/>
    <id>https://atffang.github.io/2025/05/16/%E4%B8%8D%E8%A6%81%E7%94%A8%E5%8D%B1%E9%99%A9%E7%9A%84%E5%AD%97%E7%AC%A6%E6%8B%BC%E6%8E%A5sql%E6%9F%A5%E8%AF%A2/</id>
    <published>2025-05-16T02:38:11.000Z</published>
    <updated>2025-05-16T02:49:44.281Z</updated>
    
    <content type="html"><![CDATA[<p>解决 SQL 注入问题，在于不去拼接字符串构造 SQL，而是使用“预编译 + 参数绑定”的方式（即参数化查询）来处理 SQL 请求。抑或是使用ORM。</p><span id="more"></span><p><strong>什么是 SQL 注入？</strong></p><p>SQL 注入（SQL Injection）是指攻击者通过构造恶意输入，插入到 SQL 查询语句中，从而<strong>操控数据库</strong>执行非预期的操作，如绕过登录、删除数据等。<br />例如：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名：&quot;</span>)</span><br><span class="line">sql = <span class="string">&quot;SELECT * FROM users WHERE username = &#x27;&quot;</span> + username + <span class="string">&quot;&#x27;;&quot;</span></span><br></pre></td></tr></table></figure><p>当用户输入 <code>admin' OR '1'='1</code> 时，SQL 变成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE username = <span class="string">&#x27;admin&#x27;</span> OR <span class="string">&#x27;1&#x27;</span>=<span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这会导致永远为真，绕过认证。</p><h3 id="解决方案1预编译参数绑定prepared-statements"><a class="markdownIt-Anchor" href="#解决方案1预编译参数绑定prepared-statements"></a> 解决方案1：预编译+参数绑定（Prepared Statements）</h3><p>将 SQL 语句结构提前固定好，<strong>只在后续绑定参数，而不是拼接字符串</strong>，数据库系统会提前“准备”好 SQL 的执行计划。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> psycopg2</span><br><span class="line"></span><br><span class="line">conn = psycopg2.connect(database=<span class="string">&quot;testdb&quot;</span>, user=<span class="string">&quot;postgres&quot;</span>, password=<span class="string">&quot;yourpassword&quot;</span>)</span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户输入</span></span><br><span class="line">username = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名：&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 安全的方式：参数化查询，防止SQL注入</span></span><br><span class="line">sql = <span class="string">&quot;SELECT * FROM users WHERE username = %s;&quot;</span></span><br><span class="line">cursor.execute(sql, (username,))  <span class="comment"># 第二个参数是 tuple，即使用户输入恶意内容也不会被执行为SQL代码</span></span><br><span class="line"></span><br><span class="line">rows = cursor.fetchall()</span><br><span class="line"><span class="built_in">print</span>(rows)</span><br></pre></td></tr></table></figure><p>这里的 %s 是占位符，(username,) 是绑定参数。<strong>PostgreSQL 会自动对输入内容进行转义和类型处理</strong>，用户输入的内容只会当作“数据”，不会被解释为 SQL 代码。</p><h3 id="解决方案2-ormobject-relational-mapping"><a class="markdownIt-Anchor" href="#解决方案2-ormobject-relational-mapping"></a> 解决方案2: ORM（Object-Relational Mapping）</h3><p><strong>ORM 是一种将数据库表映射为程序中的对象</strong> 的工具，它允许你用“面向对象的方式”来操作数据库，而不是手写 SQL。</p><p>优点包括：</p><ul><li>代码更简洁、抽象</li><li>更容易维护和迁移数据库</li><li>内置 <strong>参数化查询机制</strong>，天然避免 SQL 注入</li></ul><p>一个python+postgresql的简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine, Column, Integer, String</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker, declarative_base</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据库连接</span></span><br><span class="line">engine = create_engine(<span class="string">&quot;postgresql://postgres:yourpassword@localhost/testdb&quot;</span>)</span><br><span class="line">Session = sessionmaker(bind=engine)</span><br><span class="line">session = Session()</span><br><span class="line"></span><br><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个 User 模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    __tablename__ = <span class="string">&#x27;users&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    username = Column(String)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询一个用户（安全）</span></span><br><span class="line">username_input = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名：&quot;</span>)</span><br><span class="line">user = session.query(User).<span class="built_in">filter</span>(User.username == username_input).first()</span><br><span class="line"><span class="built_in">print</span>(user)</span><br></pre></td></tr></table></figure><p>当然，orm实际上更有益于我们进行数据库控制，即增删改查等操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine, Column, Integer, String</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker, declarative_base</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库连接设置（请修改为你的实际用户名、密码和数据库名）</span></span><br><span class="line">engine = create_engine(<span class="string">&quot;postgresql://postgres:yourpassword@localhost/testdb&quot;</span>)</span><br><span class="line">Session = sessionmaker(bind=engine)</span><br><span class="line">session = Session()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 ORM 基类</span></span><br><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 User 模型（对应 users 表）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    __tablename__ = <span class="string">&#x27;users&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    username = Column(String)</span><br><span class="line">    email = Column(String)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建表（如果尚不存在）</span></span><br><span class="line">Base.metadata.create_all(engine)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------- 增（Insert） ----------</span></span><br><span class="line">new_user = User(username=<span class="string">&quot;alice&quot;</span>, email=<span class="string">&quot;alice@example.com&quot;</span>)</span><br><span class="line">session.add(new_user)</span><br><span class="line">session.commit()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;插入用户 ID：<span class="subst">&#123;new_user.<span class="built_in">id</span>&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------- 查（Query） ----------</span></span><br><span class="line"><span class="comment"># 查询所有用户</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;所有用户：&quot;</span>)</span><br><span class="line">users = session.query(User).<span class="built_in">all</span>()</span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> users:</span><br><span class="line">    <span class="built_in">print</span>(user.<span class="built_in">id</span>, user.username, user.email)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询特定用户</span></span><br><span class="line">user = session.query(User).<span class="built_in">filter</span>(User.username == <span class="string">&quot;alice&quot;</span>).first()</span><br><span class="line"><span class="keyword">if</span> user:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;找到用户：&quot;</span>, user.username, user.email)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------- 改（Update） ----------</span></span><br><span class="line"><span class="keyword">if</span> user:</span><br><span class="line">    user.email = <span class="string">&quot;alice_updated@example.com&quot;</span></span><br><span class="line">    session.commit()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;已更新用户邮箱：&quot;</span>, user.email)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------- 删（Delete） ----------</span></span><br><span class="line"><span class="keyword">if</span> user:</span><br><span class="line">    session.delete(user)</span><br><span class="line">    session.commit()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;已删除用户：&quot;</span>, user.username)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------- 关闭会话 ----------</span></span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;解决 SQL 注入问题，在于不去拼接字符串构造 SQL，而是使用“预编译 + 参数绑定”的方式（即参数化查询）来处理 SQL 请求。抑或是使用ORM。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>geohash与geotree</title>
    <link href="https://atffang.github.io/2025/05/10/geohash%E4%B8%8Egeotree/"/>
    <id>https://atffang.github.io/2025/05/10/geohash%E4%B8%8Egeotree/</id>
    <published>2025-05-10T15:50:09.000Z</published>
    <updated>2025-05-11T14:32:48.908Z</updated>
    
    <content type="html"><![CDATA[<p>介绍一下geohash与geotree</p><span id="more"></span><h3 id="geohash"><a class="markdownIt-Anchor" href="#geohash"></a> Geohash</h3><p><strong>Geohash</strong> 是一种将二维地理坐标（经度 Longitude 和 纬度 Latitude）编码为一个可排序的字符串的空间索引方法。由 Gustavo Niemeyer 于 2008 年提出，并被广泛用于分布式地理数据索引、近邻搜索、区域聚合等场景。</p><p>核心特征为：</p><ul><li>编码结果是<strong>Base32 字符串</strong></li><li>字符越多，<strong>空间精度越高</strong></li><li>相近位置编码字符串有<strong>公共前缀</strong></li></ul><h4 id="geohash-编码原理"><a class="markdownIt-Anchor" href="#geohash-编码原理"></a> Geohash 编码原理</h4><p>Geohash 使用<strong>经纬度交替二分</strong>的方式，将整个地球的经纬度范围不断缩小，直到定位到目标点。过程主要分为以下 4 步：</p><p><strong>步骤 1：初始化经纬度范围</strong></p><ul><li>经度范围 lon_range = [-180, 180]</li><li>纬度范围 lat_range = [-90, 90]</li></ul><p><strong>步骤 2：交替二分编码，生成二进制序列</strong><br />使用**二分法（Binary Search）**编码纬度和经度：</p><ul><li>从经度开始（偶数位处理经度，奇数位处理纬度）</li><li>每次比较当前坐标是否大于区间中点，如果是，记为 1，否则为 0</li><li>并更新范围（左/右半区）<br />这个过程交替进行直到你得到足够数量的位，比如 5 位 * 7 字符 = 35 位。</li></ul><p><strong>步骤 3：每 5 位为一组，转为十进制索引</strong><br />将所得的长二进制串，<strong>每 5 位一组</strong>，转为十进制，然后用 Base32 映射表替换。</p><p><strong>步骤 4：生成最终字符串</strong><br />每 5 位 → 1 个字符，共 n 个字符（通常精度为 6~9 个字符）。</p><h4 id="geohash优点"><a class="markdownIt-Anchor" href="#geohash优点"></a> Geohash优点</h4><p><strong>1.</strong> <strong>支持空间邻近查询</strong></p><ul><li>Geohash 编码相邻的区域通常具有<strong>相似前缀</strong>，适合使用前缀匹配（如 LIKE ‘wx4g0%’）实现快速范围查询。</li><li>特别适合在数据库中对空间对象做索引。</li></ul><p><strong>2.</strong>  <strong>分级精度（多级网格）</strong></p><ul><li>编码长度越长，表示区域越小，精度越高。</li><li>可动态控制精度，适合不同缩放层级的空间分析。</li></ul><p><strong>3.</strong>  <strong>文本存储，易于索引</strong></p><ul><li>Geohash 是字符串格式，便于存储、索引（B-Tree、Trie）、压缩和分布式传输。</li></ul><p><strong>4.</strong> <strong>无依赖的数据结构</strong></p><ul><li>不依赖复杂的空间数据结构（如 R-Tree、QuadTree），适用于轻量级地理索引服务。</li></ul><p><strong>5.</strong> <strong>适合分布式系统</strong></p><ul><li>Geohash 可直接用于 Sharding，例如前缀作为分片 key，天然适配大数据平台如 HBase、Elasticsearch。</li></ul><h4 id="geohash的不足"><a class="markdownIt-Anchor" href="#geohash的不足"></a> Geohash的不足</h4><p><strong>1.</strong> <strong>经纬度不均匀映射</strong></p><ul><li>纬度范围 [-90, 90]，经度 [-180, 180]，导致赤道附近一个 Geohash 单元的面积大于极地。</li><li>地球是球体，Geohash 假设平面映射，有畸变。</li></ul><p><strong>2.</strong>  <strong>边界误差问题</strong></p><ul><li>相邻的两个地理位置如果落在不同的 Geohash 网格单元中，会出现<strong>编码前缀差异</strong>，影响邻近判断。</li><li>需要额外处理“邻居格子”。</li></ul><p><strong>3.</strong> <strong>形状不规则</strong></p><ul><li>Geohash 网格在地图上是<strong>长方形</strong>而非正方形，且每一级的比例不均一，查询时常需额外扩大范围。</li></ul><p><strong>4.</strong>  <strong>二维信息压缩成一维有信息损失</strong></p><ul><li>经纬度交替合并会丢失部分空间关系（例如正方形邻域判断更复杂）。</li></ul><p><strong>5.</strong> <strong>精度和效率权衡</strong></p><ul><li>长 Geohash 字符串意味着更高精度，但也带来索引增长和性能损耗问题。</li></ul><p>总的来说，Geohash 是一种优雅的地理编码方案，它以轻量、易索引的方式，在现代数据库和分布式系统中广泛应用。然而，在面对高精度、复杂空间关系时，它也暴露出一定的局限性。因此，在实际使用中，应结合业务需求，评估其合适性，并配合如邻接格补全、R-Tree 等技术优化空间查询性能。</p><h3 id="geotree"><a class="markdownIt-Anchor" href="#geotree"></a> GeoTree</h3><p><strong>GeoTree</strong> 是一种基于空间层级划分的地理编码体系，它将地球表面按不同层级进行规则划分，并通过编码的方式表达空间单元的层级和位置关系。相比 Geohash 等网格编码，GeoTree 更强调“树结构”和“地理拓扑”的结合，适用于需要空间聚合、路径查询、空间层次建模的应用场景。</p><p>GeoTree 的思想与四叉树（QuadTree）类似，但更灵活，支持<strong>多尺度编码</strong>与<strong>空间父子继承关系表达</strong>，广泛用于如地空一体化管理、空域划分、地理分区治理等空间应用。</p><h4 id="核心特征"><a class="markdownIt-Anchor" href="#核心特征"></a> <strong>核心特征：</strong></h4><ul><li>每个节点表示一个空间区域，节点 ID 为<strong>可排序的字符串或整数</strong></li><li>子区域编码在父编码基础上扩展（<strong>继承性编码</strong>）</li><li>层级结构清晰，便于表示“包含关系”和<strong>层次聚合</strong></li><li>支持<strong>三维空间索引</strong>（经度、纬度、高度）</li></ul><h4 id="geotree-编码原理"><a class="markdownIt-Anchor" href="#geotree-编码原理"></a> <strong>GeoTree 编码原理</strong></h4><p>GeoTree 并非采用经纬度交替压缩为二进制，而是按照空间网格划分规则，分层递归构建编码。过程一般如下：<br /><strong>步骤 1：定义根层空间范围（Level 0）</strong></p><ul><li>将地球划分为若干大格（如全球 8 区或全球 6 面体）</li><li>每个大格分配一个唯一编码（如 “1”、“A”、“R0”）</li></ul><p><strong>步骤 2：递归划分子区域（Level 1~n）</strong></p><ul><li>每个区域根据固定或可变规则继续划分为子区域（如 4 等分、9 等分、3D 立方等）</li><li>子区域编码在父编码基础上追加子代标识（如 “1-3” 表示根节点 1 的第 3 个子区）</li></ul><p><strong>步骤 3：形成空间编码树</strong></p><ul><li>所有区域构成一棵空间树：根为地球、分支为区域、叶子为最小单元</li><li>编码如 A-1-2-0 表示：区域 A → 子区 1 → 子区 2 → 子区 0</li></ul><p><strong>步骤 4：支持三维编码（可选）</strong></p><ul><li>对于需要高空建模的场景，每层子区可增加“高度切分”，编码如：A-1-2-0-H2</li></ul><h4 id="geotree-的优势"><a class="markdownIt-Anchor" href="#geotree-的优势"></a> <strong>GeoTree 的优势</strong></h4><p><strong>1.</strong>  <strong>天然支持空间层次结构</strong></p><ul><li>每个编码天然携带层级信息，如 A-2-3 表示第 2 层、第 3 区</li><li>支持区域归属、包含、父子导航等空间树操作</li></ul><p><strong>2.</strong> <strong>邻接关系明确，便于空间合并</strong></p><ul><li>可快速判断相邻区域是否有共同父节点，从而实现区域合并、聚合分析</li></ul><p><strong>3.</strong> <strong>便于多尺度查询</strong></p><ul><li>查询精度可控制在某一层级，例如只查询第 3 层的所有编码</li></ul><p><strong>4.</strong> <strong>编码形式灵活</strong></p><ul><li>可以使用字符串（如 “E-3-1”）或整型编码（如位运算 0b010101）支持高效索引</li></ul><p><strong>5.</strong> <strong>支持三维空间编码</strong></p><ul><li>除经纬度之外，GeoTree 可扩展高度维度，适用于低空空域、建筑分层、空间管网等场景</li></ul><p><strong>6.</strong> <strong>更强的空间拓扑表达能力</strong></p><ul><li>相比 Geohash 的“前缀相似”，GeoTree 明确建模空间父子关系，有助于空间推理和规划控制</li></ul><h4 id="geotree-的不足"><a class="markdownIt-Anchor" href="#geotree-的不足"></a> <strong>GeoTree 的不足</strong></h4><p><strong>1.</strong> <strong>空间分区规则需自定义</strong></p><ul><li>没有标准化的编码划分规则，不同业务可能用不同树型划分方式</li></ul><p><strong>2.</strong> <strong>区域形状不规则</strong></p><ul><li>编码背后代表的空间单元可能非正方形（视分割策略），可能导致某些计算复杂</li></ul><p><strong>3.</strong> <strong>实现成本略高</strong></p><ul><li>相比 Geohash 纯字符串压缩，GeoTree 需要维护树结构、支持路径解析和层级操作</li></ul><p><strong>4.</strong> <strong>邻接格查找略繁琐</strong></p><ul><li>查找空间邻居不像 Geohash 可以通过简单变换字符实现，而需要访问同层兄弟节点</li></ul><p>GeoTree 是一种<strong>结构化、层级化、拓扑清晰的地理编码体系</strong>，它从空间组织结构出发，更适合表达“地理分区与归属”这一类场景。在复杂区域管理、空间权限控制、多尺度数据建模等领域，比 Geohash 更具表达力。<br />然而，由于 GeoTree 没有统一标准实现，初始设计需结合业务规则规划编码体系。在面向大规模分布式查询的场景下，GeoTree 可与 Geohash 等轻量编码联合使用，取长补短，实现高效、结构清晰的空间信息处理。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍一下geohash与geotree&lt;/p&gt;</summary>
    
    
    
    <category term="空间分析与GIS算法" scheme="https://atffang.github.io/categories/%E7%A9%BA%E9%97%B4%E5%88%86%E6%9E%90%E4%B8%8EGIS%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Python中的闭包</title>
    <link href="https://atffang.github.io/2025/05/09/Python%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/"/>
    <id>https://atffang.github.io/2025/05/09/Python%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/</id>
    <published>2025-05-09T02:39:33.000Z</published>
    <updated>2025-05-09T03:06:18.554Z</updated>
    
    <content type="html"><![CDATA[<p>Python中的闭包机制简介</p><span id="more"></span><h3 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h3><p>闭包（<strong>Closure</strong>）是 Python 中一个非常重要且常用的概念，它是函数式编程的核心特性之一。闭包是一个函数，它“记住”了它被创建时的环境，即使在其环境之外被调用，这些变量仍然可用。换句话说：<strong>一个函数返回了另一个函数，这个返回的函数引用了其外部函数的变量</strong>，这个内部函数就是一个闭包。</p><p><strong>闭包的三个必要条件</strong>：</p><ol><li><strong>嵌套函数</strong>：函数内部定义了另一个函数；</li><li><strong>内部函数引用了外部函数的变量（自由变量）</strong>；</li><li><strong>外部函数返回了内部函数</strong>。</li></ol><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">y</span>):</span><br><span class="line">        <span class="keyword">return</span> x + y  <span class="comment"># inner 使用了 outer 的变量 x</span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">f = outer(<span class="number">10</span>)  <span class="comment"># outer 返回了 inner 函数</span></span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">5</span>))    <span class="comment"># 输出 15，等于 10 + 5</span></span><br></pre></td></tr></table></figure><p>每当函数内部引用了外部作用域的变量时，Python 会将这些变量“捕获”并保存在闭包中。<br />我们可以用函数的 <strong>closure</strong> 属性查看闭包中存储的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(f.__closure__[<span class="number">0</span>].cell_contents)  <span class="comment"># 输出 10</span></span><br></pre></td></tr></table></figure><h3 id="usage"><a class="markdownIt-Anchor" href="#usage"></a> Usage</h3><h4 id="数据隐藏类似于私有变量"><a class="markdownIt-Anchor" href="#数据隐藏类似于私有变量"></a> 数据隐藏（类似于私有变量）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_counter</span>():</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">counter</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> count</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line"></span><br><span class="line">c1 = make_counter()</span><br><span class="line"><span class="built_in">print</span>(c1())  <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(c1())  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">c2 = make_counter()</span><br><span class="line"><span class="built_in">print</span>(c2())  <span class="comment"># 1（新的闭包）</span></span><br></pre></td></tr></table></figure><p>如果你在一个函数内定义了另一个函数（形成闭包），而你想<strong>在内部函数中修改外部函数的变量</strong>，就需要用 nonlocal 来声明这个变量。nonlocal 是 Python 3 中引入的一个关键字，用于在<strong>嵌套函数中声明一个变量不是局部变量</strong>，而是来自于<strong>最近一层的外部（非全局）作用域</strong>。</p><h4 id="回调函数"><a class="markdownIt-Anchor" href="#回调函数"></a> 回调函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_multiplier</span>(<span class="params">factor</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">multiply</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="keyword">return</span> n * factor</span><br><span class="line">    <span class="keyword">return</span> multiply</span><br><span class="line"></span><br><span class="line">double = make_multiplier(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(double(<span class="number">10</span>))  <span class="comment"># 20</span></span><br></pre></td></tr></table></figure><h4 id="函数工厂"><a class="markdownIt-Anchor" href="#函数工厂"></a> 函数工厂</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">power_factory</span>(<span class="params">exp</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> x ** exp</span><br><span class="line">    <span class="keyword">return</span> power</span><br><span class="line"></span><br><span class="line">square = power_factory(<span class="number">2</span>)</span><br><span class="line">cube = power_factory(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(square(<span class="number">5</span>))  <span class="comment"># 25</span></span><br><span class="line"><span class="built_in">print</span>(cube(<span class="number">2</span>))    <span class="comment"># 8</span></span><br></pre></td></tr></table></figure><h4 id="装饰器的本质也是闭包"><a class="markdownIt-Anchor" href="#装饰器的本质也是闭包"></a> 装饰器的本质也是闭包！</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Before function call&quot;</span>)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;After function call&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@my_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">greet(<span class="string">&quot;Alice&quot;</span>)</span><br></pre></td></tr></table></figure><p>进一步的，我们可以使用装饰器来为函数计时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start = time.time()  <span class="comment"># 开始时间</span></span><br><span class="line">        result = func(*args, **kwargs)  <span class="comment"># 调用被装饰的函数</span></span><br><span class="line">        end = time.time()  <span class="comment"># 结束时间</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;函数 `<span class="subst">&#123;func.__name__&#125;</span>` 运行耗时：<span class="subst">&#123;end - start:<span class="number">.6</span>f&#125;</span> 秒&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">slow_function</span>():</span><br><span class="line">    time.sleep(<span class="number">2</span>)  <span class="comment"># 模拟耗时操作</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务完成&quot;</span>)</span><br><span class="line"></span><br><span class="line">slow_function()</span><br></pre></td></tr></table></figure><p>再进一步的，我们对装饰器进行增强，使其能够同时实现：</p><ul><li>✅ 打印日志（函数名称和参数）</li><li>⏱ 计时执行时间</li><li>⚠️ 自动捕获异常并打印错误信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log_timer_exception</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[LOG] 正在调用函数 `<span class="subst">&#123;func.__name__&#125;</span>`&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[LOG] 参数: args=<span class="subst">&#123;args&#125;</span>, kwargs=<span class="subst">&#123;kwargs&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        start_time = time.time()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            result = func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[ERROR] 函数 `<span class="subst">&#123;func.__name__&#125;</span>` 执行出错: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            traceback.print_exc()</span><br><span class="line">            result = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[LOG] 函数 `<span class="subst">&#123;func.__name__&#125;</span>` 返回结果: <span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            end_time = time.time()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[TIME] 函数 `<span class="subst">&#123;func.__name__&#125;</span>` 执行耗时: <span class="subst">&#123;end_time - start_time:<span class="number">.6</span>f&#125;</span> 秒\n&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@log_timer_exception</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br><span class="line"></span><br><span class="line"><span class="meta">@log_timer_exception</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sleep_task</span>(<span class="params">seconds</span>):</span><br><span class="line">    time.sleep(seconds)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;休眠 <span class="subst">&#123;seconds&#125;</span> 秒完成&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">divide(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">divide(<span class="number">10</span>, <span class="number">0</span>)  <span class="comment"># 除零错误</span></span><br><span class="line"></span><br><span class="line">sleep_task(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[LOG] 正在调用函数 `divide`</span><br><span class="line">[LOG] 参数: args=(10, 2), kwargs=&#123;&#125;</span><br><span class="line">[LOG] 函数 `divide` 返回结果: 5.0</span><br><span class="line">[TIME] 函数 `divide` 执行耗时: 0.000002 秒</span><br><span class="line"></span><br><span class="line">[LOG] 正在调用函数 `divide`</span><br><span class="line">[LOG] 参数: args=(10, 0), kwargs=&#123;&#125;</span><br><span class="line">[ERROR] 函数 `divide` 执行出错: division by zero</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line">[TIME] 函数 `divide` 执行耗时: 0.000004 秒</span><br></pre></td></tr></table></figure><h4 id="闭包lamba表达式"><a class="markdownIt-Anchor" href="#闭包lamba表达式"></a> 闭包+lamba表达式</h4><p>lambda 常用于创建简单闭包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_adder</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> y: x + y</span><br><span class="line"></span><br><span class="line">add5 = make_adder(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(add5(<span class="number">3</span>))  <span class="comment"># 8</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Python中的闭包机制简介&lt;/p&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
  <entry>
    <title>工厂函数与工厂方法</title>
    <link href="https://atffang.github.io/2025/05/09/%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0/"/>
    <id>https://atffang.github.io/2025/05/09/%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0/</id>
    <published>2025-05-09T01:51:56.000Z</published>
    <updated>2025-05-09T03:16:35.605Z</updated>
    
    <content type="html"><![CDATA[<p>本文以python为例，简单介绍工厂函数。</p><span id="more"></span><h3 id="工厂函数"><a class="markdownIt-Anchor" href="#工厂函数"></a> 工厂函数</h3><p>工厂函数（Factory Function）是一种常见的设计模式，尤其适用于面向对象编程和函数式编程场景中，用来 <strong>动态创建对象</strong> 或 <strong>封装复杂初始化逻辑</strong>。</p><h4 id="definition"><a class="markdownIt-Anchor" href="#definition"></a> Definition</h4><p>工厂函数本质上是一个<strong>返回对象的函数</strong>，而不是类的构造函数（<strong>init</strong>）。它根据传入的参数决定返回什么类型或配置的对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">animal_factory</span>(<span class="params">animal_type</span>):</span><br><span class="line">    <span class="keyword">if</span> animal_type == <span class="string">&quot;dog&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> Dog()</span><br><span class="line">    <span class="keyword">elif</span> animal_type == <span class="string">&quot;cat&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> Cat()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Unknown animal type&quot;</span>)</span><br></pre></td></tr></table></figure><p>工厂函数的优势在于：</p><ol><li><strong>封装复杂逻辑</strong>：隐藏创建对象所需的复杂初始化步骤；</li><li><strong>运行时类型决定</strong>：可以在运行时根据参数决定返回何种子类；</li><li><strong>返回同一类的多个变种</strong>：支持不同配置、不同状态的实例；</li><li><strong>替代类继承</strong>：在某些函数式编程场景中，不用类继承，也可以通过工厂函数生成封装好的行为；</li><li><strong>支持缓存或单例</strong>：结合缓存机制（比如字典）可复用实例。</li></ol><h4 id="usage"><a class="markdownIt-Anchor" href="#usage"></a> Usage</h4><p>数据库连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MySQLConnection</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MySQL connected&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PostgreSQLConnection</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;PostgreSQL connected&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">db_connection_factory</span>(<span class="params">db_type</span>):</span><br><span class="line">    <span class="keyword">if</span> db_type == <span class="string">&quot;mysql&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> MySQLConnection()</span><br><span class="line">    <span class="keyword">elif</span> db_type == <span class="string">&quot;postgres&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> PostgreSQLConnection()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Unsupported DB type&quot;</span>)</span><br><span class="line"></span><br><span class="line">conn = db_connection_factory(<span class="string">&quot;mysql&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(conn.connect())  <span class="comment"># 输出: MySQL connected</span></span><br></pre></td></tr></table></figure><p>工厂函数封装初始化参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_logger</span>(<span class="params">log_type=<span class="string">&quot;file&quot;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> log_type == <span class="string">&quot;file&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span> msg: <span class="built_in">print</span>(<span class="string">f&quot;[FILE] <span class="subst">&#123;datetime.now()&#125;</span>: <span class="subst">&#123;msg&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> log_type == <span class="string">&quot;console&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span> msg: <span class="built_in">print</span>(<span class="string">f&quot;[CONSOLE] <span class="subst">&#123;datetime.now()&#125;</span>: <span class="subst">&#123;msg&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Unknown log type&quot;</span>)</span><br><span class="line"></span><br><span class="line">logger = create_logger(<span class="string">&quot;console&quot;</span>)</span><br><span class="line">logger(<span class="string">&quot;Something happened&quot;</span>)  <span class="comment"># 输出: [CONSOLE] 时间: Something happened</span></span><br></pre></td></tr></table></figure><p>结合缓存，返回单例或共享对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">_instances = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">singleton_factory</span>(<span class="params">cls</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_instance</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> _instances:</span><br><span class="line">            _instances[cls] = cls(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> _instances[cls]</span><br><span class="line">    <span class="keyword">return</span> get_instance</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton_factory</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Configuration</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.settings = &#123;&#125;</span><br><span class="line"></span><br><span class="line">config1 = Configuration()</span><br><span class="line">config2 = Configuration()</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> config1 <span class="keyword">is</span> config2</span><br></pre></td></tr></table></figure><h4 id="在类中使用工厂函数"><a class="markdownIt-Anchor" href="#在类中使用工厂函数"></a> 在类中使用工厂函数</h4><p>现在有一需求，我们想为每个宠物自动分配一个出生时间，给它一个独立的玩具箱（字典），这些值在每次创建时应该不同。<br />✅ 正确做法：使用<strong>default_factory</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass, field</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pet</span>:</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    kind: <span class="built_in">str</span>  <span class="comment"># &quot;cat&quot; or &quot;dog&quot;</span></span><br><span class="line">    born_time: datetime = field(default_factory=datetime.now)</span><br><span class="line">    toys: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">int</span>] = field(default_factory=<span class="built_in">dict</span>)  <span class="comment"># 玩具名 -&gt; 数量</span></span><br></pre></td></tr></table></figure><p><strong>field函数</strong>: 使用 field(default_factory=datetime.now) 表示：每次创建 Pet 实例时，都调用 datetime.now() 来自动生成时间戳（不是在类加载时就固定）。</p><p>field 是 Python dataclasses 模块中的一个函数，用来<strong>给类的属性定义更复杂的行为或默认值</strong>。default_factory 是 field() 函数的一个<strong>参数</strong>，它的作用是指定一个“工厂函数”，每次创建 dataclass 实例时调用它来生成字段的默认值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat = Pet(name=<span class="string">&quot;Mimi&quot;</span>, kind=<span class="string">&quot;cat&quot;</span>)</span><br><span class="line">dog = Pet(name=<span class="string">&quot;Doudou&quot;</span>, kind=<span class="string">&quot;dog&quot;</span>)</span><br><span class="line"></span><br><span class="line">cat.toys[<span class="string">&quot;ball&quot;</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cat.born_time)     <span class="comment"># 每个宠物自己的出生时间</span></span><br><span class="line"><span class="built_in">print</span>(dog.born_time)     <span class="comment"># 不同时间</span></span><br><span class="line"><span class="built_in">print</span>(dog.toys)          <span class="comment"># &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cat.toys <span class="keyword">is</span> dog.toys)  <span class="comment"># False ✅，玩具箱不共享</span></span><br></pre></td></tr></table></figure><p>❌ 错误示范：不使用default_factory，所有宠物共享玩具箱和出生时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BrokenPet</span>:</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    kind: <span class="built_in">str</span></span><br><span class="line">    born_time: datetime = datetime.now()  <span class="comment"># ❌ 类加载时固定</span></span><br><span class="line">    toys: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">int</span>] = &#123;&#125;             <span class="comment"># ❌ 所有宠物共享一套玩具</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat = BrokenPet(name=<span class="string">&quot;Mimi&quot;</span>, kind=<span class="string">&quot;cat&quot;</span>)</span><br><span class="line">dog = BrokenPet(name=<span class="string">&quot;Doudou&quot;</span>, kind=<span class="string">&quot;dog&quot;</span>)</span><br><span class="line"></span><br><span class="line">cat.toys[<span class="string">&quot;fish&quot;</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dog.toys)  <span class="comment"># ❌ &#123;&#x27;fish&#x27;: 1&#125;，狗和猫共用玩具箱</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cat.born_time == dog.born_time)  <span class="comment"># True ❌，出生时间完全相同</span></span><br></pre></td></tr></table></figure><p>有时人们会混淆<strong>类属性</strong>和<strong>实例属性</strong>，导致共享值错误！！！！</p><h3 id="工厂方法"><a class="markdownIt-Anchor" href="#工厂方法"></a> 工厂方法</h3><p><strong>厂方法模式（Factory Method Pattern</strong>本质是定义一个接口（抽象方法），让子类决定要实例化的类：</p><ul><li>是 GoF 的正式设计模式之一；</li><li>基于类继承；</li><li>通常用在面向对象的架构中；</li><li>Python中可以用 abc（抽象基类）来实现。</li></ul><p>一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Woof&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Meow&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 工厂方法基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnimalFactory</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_animal</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogFactory</span>(<span class="title class_ inherited__">AnimalFactory</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_animal</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> Dog()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CatFactory</span>(<span class="title class_ inherited__">AnimalFactory</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_animal</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> Cat()</span><br><span class="line"></span><br><span class="line">factory = DogFactory()</span><br><span class="line">animal = factory.create_animal()</span><br><span class="line"><span class="built_in">print</span>(animal.speak())  <span class="comment"># 输出：Woof</span></span><br></pre></td></tr></table></figure><p>DogFactory 和 CatFactory 继承了 AnimalFactory，并各自实现了创建逻辑。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文以python为例，简单介绍工厂函数。&lt;/p&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
  <entry>
    <title>详解Python类的装饰器和魔法方法</title>
    <link href="https://atffang.github.io/2025/03/30/%E8%AF%A6%E8%A7%A3Python%E7%B1%BB%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"/>
    <id>https://atffang.github.io/2025/03/30/%E8%AF%A6%E8%A7%A3Python%E7%B1%BB%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/</id>
    <published>2025-03-30T07:51:52.000Z</published>
    <updated>2025-03-30T07:55:53.030Z</updated>
    
    <content type="html"><![CDATA[<p>介绍一下Python类的装饰器和魔法方法，以及参数的下划线前缀</p><span id="more"></span><p>一个记性并不好的人将在工作中学习到的碎片化的知识统筹起来必须要依靠记录，非常不幸的是鄙人在记忆力不强的前提下依然没有良好的记录习惯，加之跑通万岁的实用主义，使得写的代码总是看起来比较低级而缺乏优雅的气息，与本人气质强烈不符。痛定思痛，痛改前非，先从一个相对基础但极其重要的机制开始记起：Python中类的装饰器与魔法方法。</p><h3 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h3><h4 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h4><p>在 Python 中，类是面向对象编程（OOP）的核心概念，它用于定义对象的蓝图。类封装了数据（属性）和行为（方法），通过类可以创建多个具有相同结构的实例对象。通过使用类，代码可以更具组织性和模块化，易于扩展和维护。</p><p>在 Python 中定义一个基本的类非常简单，使用关键字 <code>class</code> 进行定义。以下是一个简单的类定义的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="comment"># 这是一个类属性</span></span><br><span class="line">    class_variable = <span class="string">&quot;I am a class variable&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这是初始化方法（构造函数），当类实例化时会自动调用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="comment"># 这是实例属性</span></span><br><span class="line">        self.instance_variable = value</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这是一个实例方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">instance_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;This is an instance method and instance_variable is: <span class="subst">&#123;self.instance_variable&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这是一个类方法，使用 @classmethod 装饰器定义</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">class_method</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;This is a class method and class_variable is: <span class="subst">&#123;cls.class_variable&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这是一个静态方法，使用 @staticmethod 装饰器定义</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">static_method</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;This is a static method&quot;</span></span><br></pre></td></tr></table></figure><p>在上述代码中，展现了类的各个组成部分为：</p><ul><li><p><strong>类属性</strong>：</p><ul><li>类属性是类级别的属性，它们对于所有实例都是共享的。类属性通常定义在类体中，独立于任何方法。</li><li>在上例中，<code>class_variable</code> 就是一个类属性，所有对象共享同一个值。</li></ul></li><li><p><strong>实例属性</strong>：</p><ul><li>实例属性是在类的实例化过程中通过 <code>__init__()</code> 方法（也叫构造函数）动态创建的，每个实例有独立的属性值。</li><li>通过 <code>self.instance_variable = value</code>，我们为每个实例赋予不同的 <code>instance_variable</code> 值。</li></ul></li><li><p><strong>实例方法</strong>：</p><ul><li>实例方法是类中定义的普通方法，它们操作实例属性，且必须接受参数 <code>self</code>，<code>self</code> 代表的是实例本身。</li><li>实例方法通常用于定义对象的行为。</li></ul></li><li><p><strong>类方法</strong>：</p><ul><li>类方法是作用于类本身的方法，使用 <code>@classmethod</code> 装饰器定义。它接收 <code>cls</code> 参数，表示类对象，而不是实例对象。</li><li>类方法可以访问和修改类属性。</li></ul></li><li><p><strong>静态方法</strong>：</p><ul><li>静态方法是类中的方法，但它既不依赖类属性也不依赖实例属性。静态方法使用<code>@staticmethod</code> 装饰器定义，通常用于执行与类相关但不需要访问类或实例的逻辑。</li></ul></li></ul><p>通过实例化类，可以获得对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实例化类，创建对象</span></span><br><span class="line">obj1 = MyClass(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">obj2 = MyClass(<span class="string">&quot;World&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>类</strong> 是抽象的模板，用于创建对象，它定义了对象的属性和行为。</li><li><strong>对象</strong> 是类的实例，每个对象都有自己独立的属性值和行为表现。</li></ul><h4 id="类的继承inheritance"><a class="markdownIt-Anchor" href="#类的继承inheritance"></a> 类的继承（Inheritance）</h4><p>继承是面向对象编程的核心概念之一，它允许一个类继承另一个类的属性和方法，从而避免代码重复，并能够对现有的类进行扩展。被继承的类称为<strong>父类（基类或超类）</strong>，继承的类称为<strong>子类（派生类）</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> makes a sound.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义子类，继承父类 Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> barks.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> meows.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化子类</span></span><br><span class="line">dog = Dog(<span class="string">&quot;Buddy&quot;</span>)</span><br><span class="line">cat = Cat(<span class="string">&quot;Whiskers&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dog.speak())  <span class="comment"># 输出: Buddy barks.</span></span><br><span class="line"><span class="built_in">print</span>(cat.speak())  <span class="comment"># 输出: Whiskers meows.</span></span><br></pre></td></tr></table></figure><p>继承的特点：</p><ul><li>子类继承父类的所有属性和方法，并且可以<strong>重写</strong>（override）父类的方法。</li><li>可以通过 <code>super()</code> 调用父类的方法。</li><li>支持多重继承，子类可以从多个父类继承。</li></ul><h4 id="类的多态polymorphism"><a class="markdownIt-Anchor" href="#类的多态polymorphism"></a> 类的多态（Polymorphism）</h4><p>多态允许不同的类实现相同的方法，而表现出不同的行为。它是一种编程能力，能够让相同的接口对不同的数据类型做出不同的响应，具体行为由具体的对象来决定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&quot;Subclass must implement this method.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Woof!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Meow!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">animal_sound</span>(<span class="params">animal</span>):</span><br><span class="line">    <span class="built_in">print</span>(animal.speak())</span><br><span class="line"></span><br><span class="line">dog = Dog()</span><br><span class="line">cat = Cat()</span><br><span class="line"></span><br><span class="line">animal_sound(dog)  <span class="comment"># 输出: Woof!</span></span><br><span class="line">animal_sound(cat)  <span class="comment"># 输出: Meow!</span></span><br></pre></td></tr></table></figure><h4 id="抽象类abstract-class"><a class="markdownIt-Anchor" href="#抽象类abstract-class"></a> 抽象类（Abstract Class）</h4><p>抽象类是不能被实例化的类，它用于定义方法的模板，而子类必须实现这些方法。Python 通过 <code>abc</code> 模块中的 <code>ABC</code> 类和 <code>abstractmethod</code> 装饰器来实现抽象类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Woof!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Meow!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># animal = Animal()  # 这会抛出错误，因为抽象类不能实例化</span></span><br><span class="line">dog = Dog()</span><br><span class="line"><span class="built_in">print</span>(dog.speak())  <span class="comment"># 输出: Woof!</span></span><br></pre></td></tr></table></figure><ul><li>抽象类定义了抽象方法，子类必须实现这些抽象方法。</li><li>抽象类提供了代码结构的基础框架，具体实现由子类负责。</li></ul><h4 id="组合composition"><a class="markdownIt-Anchor" href="#组合composition"></a> 组合（Composition）</h4><p>组合是一种设计原则，通过将对象的实例作为其他类的属性来实现。这种方法允许类之间的松散耦合。相比继承，组合通常提供了更大的灵活性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Engine started&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.engine = Engine()  <span class="comment"># 将 Engine 类实例作为 Car 的属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.engine.start()</span><br><span class="line"></span><br><span class="line">car = Car()</span><br><span class="line"><span class="built_in">print</span>(car.start())  <span class="comment"># 输出: Engine started</span></span><br></pre></td></tr></table></figure><h3 id="装饰器"><a class="markdownIt-Anchor" href="#装饰器"></a> 装饰器</h3><h4 id="装饰器的定义"><a class="markdownIt-Anchor" href="#装饰器的定义"></a> 装饰器的定义</h4><p>在 Python 中，<strong>装饰器</strong>（Decorator）是一种函数，允许你在不修改原有函数代码的情况下，动态地增加或修改该函数的功能。简单来说，装饰器是用来&quot;包装&quot;其他函数的函数，它允许你在运行时增加函数的功能，通常用于日志记录、权限检查、缓存、计时等功能。</p><p>装饰器本质上是一个函数，它接受一个函数作为输入，并返回一个新的函数（通常是原函数的增强版本）。这种方式可以帮助我们在不改变原函数代码的前提下，对其进行修改或扩展。</p><p>在 Python 中，装饰器使用 <code>@decorator_name</code> 语法应用到一个函数上。这个语法等价于调用装饰器函数并将目标函数作为参数传递给它。</p><p>下面是一系列针对装饰器的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个装饰器函数decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="comment"># 我们用函数wrapper来代表被装饰后的func函数，最后返回wrapper</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;end_time - start_time&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面这段代码在wrapper函数外面包裹了一个装饰器函数decorator，</span></span><br><span class="line"><span class="comment"># 使得wrapper函数的运行时间可以被检测。(*args, **kwargs)这两个参数可以代表传入的一切参数。</span></span><br><span class="line"><span class="comment"># 我们来看看如何使用它：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先定义一个square函数：</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span>  a*b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随后，使用装饰器装饰他，生成一个新的函数</span></span><br><span class="line">decorated_square = decorator(square)</span><br><span class="line"><span class="comment">#print(decorated_square(10,10))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际上，python提供了一个更简单的方法：</span></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span>  a*b</span><br><span class="line"><span class="comment"># 这样，直接执行square(10,10)，就能输出运行的时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然，我们也可以定义一个装饰器生成器:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">threshold</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="comment"># 这是一个python中自带的装饰器，可以使得wrapper函数继承func的名字等</span></span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            start_time = time.time()</span><br><span class="line">            result = func(*args, **kwargs)</span><br><span class="line">            end_time = time.time()</span><br><span class="line">            <span class="keyword">if</span> start_time - end_time &gt; threshold:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;超时&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰这个函数</span></span><br><span class="line"><span class="meta">@timer(<span class="params"><span class="number">0.1</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sleep_04</span>():</span><br><span class="line">    time.sleep(<span class="number">0.4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sleep_04()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者生成一个新函数</span></span><br><span class="line">sleep_04 = timer(<span class="number">0.1</span>)(sleep_04)</span><br><span class="line"><span class="built_in">print</span>(sleep_04.__name__)</span><br></pre></td></tr></table></figure><p>装饰器概念：用来装饰其他函数的，即为其他函数添加特定功能的函数 装饰器的基本原则：</p><ol><li>不能修改被装饰函数的源码</li><li>不能修改被装饰函数的调用方式</li></ol><h4 id="类中内置装饰器"><a class="markdownIt-Anchor" href="#类中内置装饰器"></a> 类中内置装饰器</h4><p>ython 类中自带的装饰器是一些内置的、专门用于修改类行为的装饰器。这些装饰器可以帮助你更方便地实现特定的类行为或功能扩展。常见的内置类装饰器包括 <code>@staticmethod</code>、<code>@classmethod</code>、<code>@property</code> 和 <code>@abstractmethod</code> 等。</p><h5 id="staticmethod"><a class="markdownIt-Anchor" href="#staticmethod"></a> @staticmethod</h5><p><code>@staticmethod</code> 装饰器用于将一个方法声明为静态方法。静态方法属于类本身，而不是类的实例。它不需要访问类实例或类本身，因此不需要传递 <code>self</code> 或 <code>cls</code> 参数。静态方法通常用于执行一些与类本身相关的任务，但不需要访问类的属性或实例数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用静态方法</span></span><br><span class="line">result = MyClass.add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出: 5</span></span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>静态方法不依赖于类的实例化。</li><li>可以通过类名或实例来调用静态方法，但通常通过类名调用。</li><li>适用于那些不需要访问实例或类属性的方法。</li></ul><h5 id="classmethod"><a class="markdownIt-Anchor" href="#classmethod"></a> @classmethod</h5><p><code>@classmethod</code> 装饰器用于将一个方法声明为类方法。类方法第一个参数是类本身（通常命名为 <code>cls</code>），而不是实例对象。类方法通常用于访问类属性或修改类状态，而不是实例状态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">increment_count</span>(<span class="params">cls</span>):</span><br><span class="line">        cls.count += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Count: <span class="subst">&#123;cls.count&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 调用类方法</span></span><br><span class="line">MyClass.increment_count()  <span class="comment"># 输出: Count: 1</span></span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>类方法不需要类的实例，可以通过类本身直接调用。</li><li>类方法第一个参数是类 <code>cls</code>，而不是实例 <code>self</code>。</li><li>类方法适用于操作类级别的数据或状态。</li></ul><h5 id="property"><a class="markdownIt-Anchor" href="#property"></a> @property</h5><p><code>@property</code> 装饰器用于将一个方法定义为属性。这意味着你可以像访问属性一样访问这个方法，而无需显式调用它。<code>@property</code> 是一种将类的方法转换为只读属性的方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, radius</span>):</span><br><span class="line">        self._radius = radius</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">radius</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._radius</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @radius.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">radius</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;Radius cannot be negative.&quot;</span>)</span><br><span class="line">        self._radius = value</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * self._radius * self._radius</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建圆对象</span></span><br><span class="line">circle = Circle(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(circle.area)  <span class="comment"># 输出: 78.5</span></span><br><span class="line">circle.radius = <span class="number">10</span>  <span class="comment"># 使用setter修改半径</span></span><br><span class="line"><span class="built_in">print</span>(circle.area)  <span class="comment"># 输出: 314.0</span></span><br></pre></td></tr></table></figure><p><strong>特点</strong></p><ul><li><code>@property</code> 使方法像属性一样访问。</li><li>可以使用 <code>@property</code> 和 <code>@property.setter</code> 来定义可读和可写的属性。</li><li>用于将计算逻辑封装成属性访问的形式。</li></ul><h5 id="abstractmethod"><a class="markdownIt-Anchor" href="#abstractmethod"></a> @abstractmethod</h5><p>详见上文</p><h3 id="魔法方法"><a class="markdownIt-Anchor" href="#魔法方法"></a> 魔法方法</h3><h4 id="重要的魔法方法"><a class="markdownIt-Anchor" href="#重要的魔法方法"></a> 重要的魔法方法</h4><p>在 Python 中，<strong>魔法方法</strong>（Magic Methods）又称为 <strong>特殊方法</strong>（Special Methods），是类中以双下划线 <code>__</code> 开头和结尾的方法。这些方法允许你对对象进行特定的操作或赋予对象特殊行为，从而让你可以定制 Python 对象的内建操作，比如加法、字符串表示、索引操作等。</p><p>魔法方法使得 Python 对象能够参与各种语言层面的操作，如算术运算、比较运算、类型转换、函数调用等，通常这些方法被 Python 内部调用，但你也可以自定义实现它们以修改对象行为。</p><p><strong><code>__new__(cls)</code></strong>：</p><ul><li>用于创建对象实例的方法。它通常与 <code>__init__</code> 一起使用，在实例化对象时首先被调用。<code>__new__</code> 返回一个新的对象实例，而 <code>__init__</code> 则用来初始化该实例。</li><li>当你继承 <code>__new__</code> 方法时，你可以控制对象创建的过程。</li></ul><p><strong><code>__init__(self, ...)</code></strong>：</p><ul><li>构造器，用于初始化对象实例。<code>__init__</code> 在 <code>__new__</code> 方法之后调用，并且在对象实例创建后立即执行。</li><li>它允许你在对象创建时设置初始属性。</li></ul><p><strong><code>__str__(self)</code></strong>：</p><ul><li>用于定义对象的字符串表示。当使用 <code>print()</code> 打印对象或使用 <code>str()</code> 函数时，<code>__str__</code> 方法被调用。</li><li>这个方法应该返回一个友好的、可读性强的字符串，用于展示对象的内容。</li></ul><p><strong><code>__getitem__(self, key)</code></strong>：</p><ul><li>用于定义对象的索引访问（例如 <code>obj[key]</code>）。<br /><strong><code>__setitem__(self, key, value)</code></strong>：</li><li>用于定义对象的索引赋值（例如 <code>obj[key] = value</code>）。<br /><strong><code>__delitem__(self, key)</code></strong>：</li><li>用于定义删除索引元素（例如 <code>del obj[key]</code>）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.data = data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data[index]</span><br><span class="line"></span><br><span class="line">my_list = MyList([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">1</span>])  <span class="comment"># 输出: 2</span></span><br></pre></td></tr></table></figure><p><strong><code>__call__(self, ...)</code></strong>：</p><ul><li>使对象成为可调用的（例如 <code>obj()</code>）。当对象像函数一样被调用时，Python 会调用 <code>obj.__call__()</code> 方法。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Adder</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> self.value + x</span><br><span class="line"></span><br><span class="line">add_five = Adder(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(add_five(<span class="number">3</span>))  <span class="comment"># 输出: 8</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>__enter__(self)</code></strong>：<ul><li>用于定义进入 <code>with</code> 语句时的行为。</li></ul></li><li><strong><code>__exit__(self, exc_type, exc_val, exc_tb)</code></strong>：<ul><li>用于定义退出 <code>with</code> 语句时的行为，处理异常等。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyContextManager</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Entering the context&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Exiting the context&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> exc_type:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Exception: <span class="subst">&#123;exc_val&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> MyContextManager():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Inside the context&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="类的参数下划线前缀"><a class="markdownIt-Anchor" href="#类的参数下划线前缀"></a> 类的参数下划线前缀</h3><h4 id="单下划线-_-前缀"><a class="markdownIt-Anchor" href="#单下划线-_-前缀"></a> 单下划线 <code>_</code> 前缀</h4><p>单下划线是 Python 的一种约定，用来标识一个变量或方法是“内部使用的”，即它不应该被外部直接访问。这种标识并不影响属性或方法的访问权限，但它是对其他开发者的一种提醒，告诉他们这些属性或方法是属于类的实现细节，应该尽量避免直接使用。</p><h4 id="双下划线-__-前缀"><a class="markdownIt-Anchor" href="#双下划线-__-前缀"></a> 双下划线 <code>__</code> 前缀</h4><p>双下划线前缀通常用于表示变量或方法是类的“私有”成员。它使得这些属性或方法不会被外部直接访问，而是通过名称修饰（name mangling）进行修改，使其在外部不可直接访问。这种命名约定旨在避免类的子类或外部代码意外覆盖或访问这些“私有”成员。</p><p><strong>用途：</strong></p><ul><li>强制私有化（name mangling）——Python 在名称前加上 <code>_ClassName</code>，使得外部不容易访问这些变量或方法。</li><li>通过这种方式，Python 希望防止类的外部代码直接访问和修改这些变量，但仍然允许子类通过继承来访问和修改这些变量。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__private_value = <span class="number">100</span>  <span class="comment"># 私有属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__private_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This is a private method.&quot;</span>)</span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line"><span class="built_in">print</span>(obj.__private_value)  <span class="comment"># 报错: AttributeError</span></span><br><span class="line">obj.__private_method()  <span class="comment"># 报错: AttributeError</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍一下Python类的装饰器和魔法方法，以及参数的下划线前缀&lt;/p&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
  <entry>
    <title>局域网访问服务器Docker下psql数据库的若干问题</title>
    <link href="https://atffang.github.io/2025/03/29/%E5%B1%80%E5%9F%9F%E7%BD%91%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8Docker%E4%B8%8Bpsql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/"/>
    <id>https://atffang.github.io/2025/03/29/%E5%B1%80%E5%9F%9F%E7%BD%91%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8Docker%E4%B8%8Bpsql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/</id>
    <published>2025-03-29T15:45:34.000Z</published>
    <updated>2025-03-30T01:41:37.613Z</updated>
    
    <content type="html"><![CDATA[<p>瞎捣鼓</p><span id="more"></span><p>最近有在实验室服务器的docker上部署服务的需求，将数据注入psql数据库并在docker环境中访问一切正常，然而在局域网下其他设备访问数据时，出现了一些问题，遂简单记录。</p><p>首先，由于postgresql数据库的默认端口为5432，然而docker仅仅预留了几个映射端口与外部通信，因此，需要修改psql的运行端口，这里我选择的映射端口为25002:2002。在 Docker 中，端口映射的格式通常是 host_port:container_port，即 宿主机端口:容器内端口。因此，首先需要修改psql的运行端口为2002。</p><p>找到<code>/etc/postgresql/14/main/postgresql.conf</code>配置文件，将<code>port = 5432</code>修改为制定端口，我这里为2002。</p><p>并添加：<code>listen_addresses = '*'</code>开启远程访问。</p><p>随后修改<code>/etc/postgresql/14/main/pg_hba.conf</code>来设置放行ip。设置规则为在实验室局域网下的ip全部放行，那么添加规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host    all             all             192.168.41.0/24          md5</span><br></pre></td></tr></table></figure><p>最后，重启服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/postgresql restart</span><br></pre></td></tr></table></figure><p>那么通过局域网下其他设备访问服务器的25002端口即可访问数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql -h 192.168.41.56 -p 25002 -U postgres -d shanghaipoidb</span><br></pre></td></tr></table></figure><p>尝试在命令行中远程连接，并未发生什么问题，但在pgadmin中连接却提示错误为一个172.x.x.x的ip被拒绝访问，如果出现这种情况，意味着 Docker 容器内的 PostgreSQL 服务绑定的是容器的内部网络 IP（例如 <code>172.x.x.x</code>），而不是宿主机的 IP 地址（例如 <code>192.x.x.x</code>）。当你使用 pgAdmin 连接时，pgAdmin 可能尝试直接连接容器的内部 IP 地址，而不是宿主机的地址，因此连接被拒绝。只需将改ip使用上面相同的方式加入放行ip即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;瞎捣鼓&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Entropy and Cross Entropy</title>
    <link href="https://atffang.github.io/2025/03/15/Entropy%20and%20Cross%20Entropy/"/>
    <id>https://atffang.github.io/2025/03/15/Entropy%20and%20Cross%20Entropy/</id>
    <published>2025-03-15T07:50:46.000Z</published>
    <updated>2025-03-15T07:54:54.142Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍一下熵与交叉熵</p><span id="more"></span><img src="https://atffang.github.io/2025/03/15/Entropy and Cross Entropy/Entropy and Cross Entropy.png"/>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单介绍一下熵与交叉熵&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>3D Guassian Splatting</title>
    <link href="https://atffang.github.io/2025/03/12/3D%20Guassian%20Splatting/"/>
    <id>https://atffang.github.io/2025/03/12/3D%20Guassian%20Splatting/</id>
    <published>2025-03-12T15:12:43.000Z</published>
    <updated>2025-03-14T14:20:08.440Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/graphdeco-inria/gaussian-splatting">https://github.com/graphdeco-inria/gaussian-splatting</a> 复现</p><span id="more"></span><h3 id="环境构建"><a class="markdownIt-Anchor" href="#环境构建"></a> 环境构建</h3><p>首先clone仓库<a href="https://github.com/graphdeco-inria/gaussian-splatting">https://github.com/graphdeco-inria/gaussian-splatting</a></p><p>理论上应该按照源码提供的environment.yml文件创建环境，即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env create --file environment.<span class="property">yml</span></span><br></pre></td></tr></table></figure><p>然而，实验室服务器CUDA版本为12.2，environment.yml中指定的python和pytorch版本过低，因此，选择自己配置环境python3.10, cuda12.1对应的pytorch（适用于12.2）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">conda create -n gaussian_splatting python=<span class="number">3.10</span></span><br><span class="line">conda activate gaussian_splatting</span><br><span class="line">pip3 install torch torchvision torchaudio --index-url <span class="attr">https</span>:<span class="comment">//download.pytorch.org/whl/cu121</span></span><br><span class="line"></span><br><span class="line">pip install submodules\diff-gaussian-rasterization</span><br><span class="line">pip install submodules\simple-knn</span><br><span class="line">pip install plyfile</span><br><span class="line">pip install tqdm</span><br><span class="line">pip install opencv-python</span><br><span class="line">pip install joblib</span><br></pre></td></tr></table></figure><h3 id="数据前期处理程序"><a class="markdownIt-Anchor" href="#数据前期处理程序"></a> 数据前期处理程序</h3><p>都是在Windows端下载。</p><p>下载ffmep <a href="http://www.gyan.dev/ffmpeg/builds/">www.gyan.dev/ffmpeg/builds/</a></p><p>将文件夹重命名为ffmep，将bin文件路径加入系统变量</p><p>下载COLMAP</p><p><a href="https://github.com/colmap/colmap/releases">https://github.com/colmap/colmap/releases</a></p><p>将文件夹重命名为COLMAP，将bin文件路径加入系统变量</p><p>下载ImageMagick</p><h3 id="训练流程"><a class="markdownIt-Anchor" href="#训练流程"></a> 训练流程</h3><ul><li>Step1：录制视频，使用ffmep进行抽帧</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.<span class="property">mp4</span> -vf <span class="string">&quot;setpts=0.2*PTS&quot;</span> input/input_%4d.<span class="property">jpg</span></span><br></pre></td></tr></table></figure><p>-i input.mp4：指定输入视频文件为 input.mp4。<br />-vf “setpts=0.2 PTS”：这是一个视频过滤器选项，其中 setpts 指令用来设置帧的时间戳（Presentation TimeStamps）。这里的表达式 0.2PTS 表示将当前帧的时间戳乘以0.2，这意味着抽取出来的帧之间的间隔被拉长了5倍，所以生成的图像序列将以视频原始速度的五分之一进行播放。<br />input/input_%4d.jpg：这是输出文件格式及路径，其中 %4d 是一个格式化占位符，它会被自增的整数所替换，确保每个输出文件名是唯一的。例如，输出的第一帧将会被保存为 input/input_0001.jpg，第二帧为 input/input_0002.jpg，依此类推。同时，输出目录被指定为 input/ 目录下。</p><ul><li>Step2：使用3D Guassian Splatting仓库中包含的convert.py完成图像数据转换。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python convert.<span class="property">py</span> -s &lt;location&gt; [--resize]</span><br></pre></td></tr></table></figure><p>location：代表需要转化的图像位置，图像必须被放在一个input文件夹下，location则为其父文件夹。<br />[–resize]：表示是否变化图像尺寸，可选</p><ul><li>Step3：将转换完成的图像，包括images和sparse两个文件夹，放在一个父文件夹下作为输入数据，进行训练。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train.py -s &lt;location&gt;</span><br></pre></td></tr></table></figure><p>location：代表数据路径</p><h3 id="结果预览"><a class="markdownIt-Anchor" href="#结果预览"></a> 结果预览</h3><p>拉取代码：<a href="https://github.com/kishimisu/Gaussian-Splatting-WebGL.git%EF%BC%8C%E5%9C%A8live">https://github.com/kishimisu/Gaussian-Splatting-WebGL.git，在live</a> server中打开网页，上传ply数据：<br /><img src="https://atffang.github.io/2025/03/12/3D Guassian Splatting/try.png"/></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/graphdeco-inria/gaussian-splatting&quot;&gt;https://github.com/graphdeco-inria/gaussian-splatting&lt;/a&gt; 复现&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>GNNWR</title>
    <link href="https://atffang.github.io/2025/03/06/GNNWR/"/>
    <id>https://atffang.github.io/2025/03/06/GNNWR/</id>
    <published>2025-03-06T06:47:14.000Z</published>
    <updated>2025-03-06T11:57:51.840Z</updated>
    
    <content type="html"><![CDATA[<p>Geographically neural network weighted regression for the accurate estimation of spatial non-stationarity</p><span id="more"></span><img src="https://atffang.github.io/2025/03/06/GNNWR/GNNWR.png">]]></content>
    
    
    <summary type="html">&lt;p&gt;Geographically neural network weighted regression for the accurate estimation of spatial non-stationarity&lt;/p&gt;</summary>
    
    
    
    <category term="空间分析与GIS算法" scheme="https://atffang.github.io/categories/%E7%A9%BA%E9%97%B4%E5%88%86%E6%9E%90%E4%B8%8EGIS%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>threading or multiprocessing?</title>
    <link href="https://atffang.github.io/2025/02/26/threading%20or%20multiprocessing/"/>
    <id>https://atffang.github.io/2025/02/26/threading%20or%20multiprocessing/</id>
    <published>2025-02-26T02:06:23.000Z</published>
    <updated>2025-05-09T02:35:29.499Z</updated>
    
    <content type="html"><![CDATA[<p>Python  两种并发机制</p><span id="more"></span><h4 id="threading"><a class="markdownIt-Anchor" href="#threading"></a> Threading</h4><p><strong>threading（线程编程）</strong> 是一种通过在程序中创建多个执行单元（线程），来实现并发执行的技术。线程共享同一个进程的内存空间，并且可以并行处理任务，因此能够更好地利用多核CPU资源。</p><p><strong>线程</strong>是进程中的一个轻量级执行单元，一个进程可以包含多个线程。这些线程共享相同的内存和资源（如文件句柄），但每个线程有自己的栈和指令指针。由于共享内存，线程间通信非常快速，但也更容易出现竞争条件、死锁等同步问题。</p><p><strong>threading经典应用场景</strong></p><ul><li><strong>I/O操作</strong>：在等待I/O操作完成（如文件读写、网络请求）时，其他线程可以继续执行任务，提高程序响应速度。</li><li><strong>并发任务</strong>：例如图形界面的响应式编程、并行数据处理。</li></ul><p><strong>An Example</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_data</span>(<span class="params">url</span>):</span><br><span class="line">response = request.get(url)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;response.status_code&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">urls = [url1, url2……]</span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">t = threading.Thread(target=fetch_data, args=(url,))</span><br><span class="line">threads.append(t)</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">t.join()</span><br></pre></td></tr></table></figure><p>多进程虽然能够处理并行任务，但每个进程的上下文切换会有额外的开销，这会影响程序的性能。因此，此类简单的请求工作更加适合使用多线程。</p><p><strong>optimize</strong>：<br />concurrent 是 Python 标准库中的一个模块，专门用于支持 <strong>并发编程</strong>。它提供了高层次的接口来管理多个任务的并发执行，主要包括线程和进程池的管理。<br />如果存在大量需要访问的url，可以使用concurrent.futures进行线程池创建。通过线程池，可以控制同时运行的线程数，避免一次性创建过多的线程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 任务函数：访问URL</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_data</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Finished download from: <span class="subst">&#123;url&#125;</span>, Status Code: <span class="subst">&#123;response.status_code&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> requests.RequestException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error downloading <span class="subst">&#123;url&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># URL列表（假设有1000个）</span></span><br><span class="line">urls = [<span class="string">&quot;http://example.com&quot;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用ThreadPoolExecutor</span></span><br><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">20</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    <span class="comment"># 提交所有任务</span></span><br><span class="line">    futures = [executor.submit(fetch_data, url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等待任务完成</span></span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> concurrent.futures.as_completed(futures):</span><br><span class="line">        future.result()  <span class="comment"># 可以获取返回结果，若不关心结果，可以省略这行</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;All downloads complete.&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="multiprocessing"><a class="markdownIt-Anchor" href="#multiprocessing"></a> Multiprocessing</h4><p><strong>multiprocessing（多进程编程）</strong> 是通过在程序中创建多个独立的进程，每个进程都有自己的内存空间、资源和执行单元，以实现并行处理。多进程能够避免线程竞争带来的问题，因为各个进程之间是独立的。</p><p><strong>进程</strong>是操作系统中资源分配的基本单位。每个进程都有自己的地址空间、文件句柄、栈、堆等资源。不同于线程，进程之间不共享内存，这意味着它们更加安全，但也需要更复杂的通信方式（如管道、消息队列）来进行数据交换。</p><p><strong>multiprocessing的典型应用场景：</strong></p><ul><li><strong>高可靠性任务</strong>：当某些任务必须完全隔离，不能因为其他任务的崩溃而被干扰时（如服务器进程、数据库进程等）。</li><li><strong>CPU密集型任务</strong>：需要大量的计算资源时（如图像处理、科学计算），使用多进程可以充分利用多核CPU的性能。</li></ul><p>关于multiprocessing的基础应用，在之前的文章《python并行运算》中做过大致介绍。<br /><strong>An Example</strong><br />并行矩阵运算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义矩阵计算任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">matrix_square</span>(<span class="params">matrix</span>):</span><br><span class="line">    <span class="keyword">return</span> np.dot(matrix, matrix)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 创建一个随机矩阵</span></span><br><span class="line">    matrices = [np.random.rand(<span class="number">1000</span>, <span class="number">1000</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用进程池进行并行计算</span></span><br><span class="line">    <span class="keyword">with</span> mp.Pool(processes=<span class="number">4</span>) <span class="keyword">as</span> pool:</span><br><span class="line">        results = pool.<span class="built_in">map</span>(matrix_square, matrices)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Matrix calculations completed.&quot;</span>)</span><br></pre></td></tr></table></figure><p>并行蒙特卡洛模拟：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义蒙特卡罗模拟任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">monte_carlo_pi</span>(<span class="params">num_samples</span>):</span><br><span class="line">    inside_circle = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_samples):</span><br><span class="line">        x, y = random.random(), random.random()</span><br><span class="line">        <span class="keyword">if</span> x**<span class="number">2</span> + y**<span class="number">2</span> &lt;= <span class="number">1</span>:</span><br><span class="line">            inside_circle += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> inside_circle / num_samples * <span class="number">4</span>  <span class="comment"># 估算π值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 每个进程处理100万次采样</span></span><br><span class="line">    num_samples = <span class="number">1000000</span></span><br><span class="line">    num_processes = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用进程池并行运行蒙特卡罗模拟</span></span><br><span class="line">    <span class="keyword">with</span> mp.Pool(processes=num_processes) <span class="keyword">as</span> pool:</span><br><span class="line">        pi_estimates = pool.<span class="built_in">map</span>(monte_carlo_pi, [num_samples] * num_processes)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算平均值</span></span><br><span class="line">    pi_average = <span class="built_in">sum</span>(pi_estimates) / num_processes</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Estimated Pi: <span class="subst">&#123;pi_average&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>optimize</strong>：<br />concurrent.futures的ProcessPoolExecutor ，类似于multiprocessing.Pool</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义蒙特卡罗模拟任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">monte_carlo_pi</span>(<span class="params">num_samples</span>):</span><br><span class="line">    inside_circle = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_samples):</span><br><span class="line">        x, y = random.random(), random.random()</span><br><span class="line">        <span class="keyword">if</span> x**<span class="number">2</span> + y**<span class="number">2</span> &lt;= <span class="number">1</span>:</span><br><span class="line">            inside_circle += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> inside_circle / num_samples * <span class="number">4</span>  <span class="comment"># 估算π值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    num_samples = <span class="number">1000000</span>  <span class="comment"># 每个进程采样的数量</span></span><br><span class="line">    num_processes = <span class="number">4</span>      <span class="comment"># 进程数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用 ProcessPoolExecutor 并行执行任务</span></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ProcessPoolExecutor(max_workers=num_processes) <span class="keyword">as</span> executor:</span><br><span class="line">        futures = [executor.submit(monte_carlo_pi, num_samples) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_processes)]</span><br><span class="line">        pi_estimates = [f.result() <span class="keyword">for</span> f <span class="keyword">in</span> concurrent.futures.as_completed(futures)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算平均估算值</span></span><br><span class="line">    pi_average = <span class="built_in">sum</span>(pi_estimates) / num_processes</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Estimated Pi: <span class="subst">&#123;pi_average&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="concurrentfeatures优势"><a class="markdownIt-Anchor" href="#concurrentfeatures优势"></a> concurrent.features优势</h4><ol><li><p><strong>统一接口</strong>：无论是使用 ThreadPoolExecutor 还是 ProcessPoolExecutor，它们的 API 是统一的，可以很方便地根据任务类型选择是使用线程还是进程。</p></li><li><p><strong>简化代码</strong>：相比 multiprocessing.Pool，concurrent.futures 提供了更高层的接口，如 submit() 和 as_completed()，减少了复杂度。</p></li><li><p><strong>Future 对象</strong>：submit() 方法返回 Future 对象，允许在任务完成后方便地获取结果、检查任务状态或处理异常。</p></li><li><p><strong>自动资源管理</strong>：concurrent.futures 支持上下文管理（with 语句），能够自动管理进程或线程池的生命周期，避免资源泄漏。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;Python  两种并发机制&lt;/p&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript异步机制浅析</title>
    <link href="https://atffang.github.io/2025/02/22/JavaScript%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/"/>
    <id>https://atffang.github.io/2025/02/22/JavaScript%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/</id>
    <published>2025-02-22T02:02:54.000Z</published>
    <updated>2025-02-22T02:02:54.948Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>asyncio浅析</title>
    <link href="https://atffang.github.io/2025/02/21/asyncio%E6%B5%85%E6%9E%90/"/>
    <id>https://atffang.github.io/2025/02/21/asyncio%E6%B5%85%E6%9E%90/</id>
    <published>2025-02-21T02:10:09.000Z</published>
    <updated>2025-05-09T02:35:09.879Z</updated>
    
    <content type="html"><![CDATA[<p>Python  asyncio机制</p><span id="more"></span><h4 id="event-loop"><a class="markdownIt-Anchor" href="#event-loop"></a> Event Loop</h4><p>Python 的事件循环（Event Loop）是异步编程中的核心概念，通常与 <code>asyncio</code> 库（Python3.5引入）一起使用。事件循环负责管理和调度异步任务，确保这些任务在适当的时机运行，而不会阻塞主线程。事件循环是基于“协程”的模型，它允许 Python 程序在进行 I/O 操作或等待某些事件时不会阻塞其他操作，从而提高程序的效率。<br /><strong>event loop</strong>的基本流程：</p><ul><li><strong>定义协程（coroutines）</strong>: 协程是 Python 中的异步函数（Asynchronous Functions），通常用 <code>async def</code> 定义，执行时不会立即执行，而是返回一个 “awaitable” 对象。</li><li><strong>创建事件循环</strong>: <code>asyncio.get_event_loop()</code> 创建一个事件循环，它负责管理和调度所有异步任务。</li><li><strong>运行事件循环</strong>: 使用 <code>loop.run_until_complete()</code> 来启动事件循环，直到指定的任务完成。</li><li><strong>任务调度</strong>: 事件循环会根据任务的状态（是否可以执行）决定哪个任务应该被调度执行。</li></ul><h4 id="asyncio-的基本使用规范"><a class="markdownIt-Anchor" href="#asyncio-的基本使用规范"></a> asyncio 的基本使用规范</h4><p>异步函数是使用 <code>async def</code> 语法定义的，它们返回一个协程对象，而不是直接执行函数体。当你调用这个函数时，实际上返回的是一个尚未完成的协程对象，需要通过事件循环来执行。<br />定义一个异步函数如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">my_coroutine</span>():</span><br><span class="line"><span class="keyword">await</span> asynico.sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><strong><code>await</code></strong> 用于挂起协程的执行，等待一个异步操作完成后再继续执行。</p><p><code>asyncio</code> 提供了事件循环来调度异步任务。事件循环负责执行异步任务，并管理任务的调度。</p><ul><li><strong><code>asyncio.run()</code></strong>：用于运行一个顶层的异步函数。它创建一个事件循环并运行直到协程执行完成，最后关闭事件循环。通常用于程序的入口。</li><li><strong><code>asyncio.run(main())</code></strong>：该方法会运行 <code>main()</code> 协程，并在执行完毕后关闭事件循环。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 asyncio.run() 启动事件循环</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">await</span> my_coroutine()</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><ul><li><strong><code>asyncio.gather()</code></strong>：用于并发执行多个协程，等到所有协程都完成后，才继续执行后面的代码。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">another_coroutine</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始执行另一个协程&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;另一个协程执行结束&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(my_coroutine(), another_coroutine())  <span class="comment"># 并发执行</span></span><br></pre></td></tr></table></figure><p>除了 <code>asyncio.run()</code>，还可以手动管理事件循环和任务，使用 <code>loop.create_task()</code> 和 <code>loop.run_until_complete()</code> 来调度任务。</p><ul><li><strong><code>loop.create_task()</code></strong>：用于创建一个协程任务，返回一个任务对象。</li><li><strong><code>loop.run_until_complete()</code></strong>：用于启动事件循环并直到某个任务完成。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">task1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务 1 开始&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务 1 完成&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">task2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务 2 开始&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务 2 完成&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动创建事件循环并执行任务</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">tasks = [loop.create_task(task1()), loop.create_task(task2())]</span><br><span class="line">loop.run_until_complete(asyncio.gather(*tasks))</span><br></pre></td></tr></table></figure><ul><li>在协程中使用 <code>try...except</code> 来捕获异常。</li><li>异常会在协程执行过程中抛出并传播，直到被捕获为止。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">my_coroutine</span>():</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;发生错误&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> my_coroutine()</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;捕获异常: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><ul><li>事件循环会在程序执行完毕后自动关闭，但如果需要提前停止，可以调用 <code>loop.stop()</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始任务&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;结束任务&quot;</span>)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(main())</span><br><span class="line">loop.stop()  <span class="comment"># 关闭事件循环</span></span><br></pre></td></tr></table></figure><h4 id="简单的上手"><a class="markdownIt-Anchor" href="#简单的上手"></a> 简单的上手</h4><p>以下代码请在python3.7及以上运行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#这是一个coroutine</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="comment">#await将asyncio.sleep(delay)这个coroutine转化为task</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="built_in">print</span>(what)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;start at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment">#await将say_after()这个coroutine转化为task，并告知Event Loop</span></span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">2</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finish at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start at 15:46:50</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">finish at 15:46:53</span><br></pre></td></tr></table></figure><p>花费三秒。整个事件过程为：<br />asyncio.run将main()包装为了一个task，然后加入Event Loop。Event Loop中此时只有一个task即main，随即运行main()，控制权交付于main。<br />随后，main将控制权交给say_after，运行say_after(1, “hello”)这个coroutine function得到一个coroutine object（代码并不会在这里阻塞），而await将coroutine object转化为task，放到Event Loop中，并告知需要等待这个sleep，控制权交给sleep。<br />1s后，sleep这个task完成，Event Loop将控制权交还给main，main运行下一个task，重复上述步骤。</p><p>但是这样并没有意义，运行的事件并没有缩短。因此，我们改变策略为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="built_in">print</span>(what)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">task1 = asyncio.create_task(say_after(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>))</span><br><span class="line">task2 = asyncio.create_task(say_after(<span class="number">2</span>, <span class="string">&quot;world&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;start at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finish at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start at 16:23:01</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">finish at 16:23:03</span><br></pre></td></tr></table></figure><p>这次，我们预先包装了两个task，在其放到Event Loop后，Event Loop并不会将控制权交由task，从而实现串行。</p><p>如何返回task的值？<br />最简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">await</span> task1</span><br></pre></td></tr></table></figure><p>使用gather:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">await</span> asyncio.gather(task1, taske)</span><br></pre></td></tr></table></figure><p>gather还有一个好处，可以不需要包装为task再输入，可以直接读取coroutine：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">say_after(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>), </span><br><span class="line">say_after(<span class="number">2</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Python  asyncio机制&lt;/p&gt;</summary>
    
    
    
    <category term="编程学习-Python" scheme="https://atffang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
    
  </entry>
  
  <entry>
    <title>2025年终总结</title>
    <link href="https://atffang.github.io/2024/12/13/2025%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://atffang.github.io/2024/12/13/2025%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</id>
    <published>2024-12-13T08:00:49.000Z</published>
    <updated>2025-01-12T05:56:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>2025年终总结</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">即使您达不到幸福的境地，您也应该永远记住，您走的路是正确的，千万不要从这条路上离开。</span><br><span class="line">（陀《卡拉马佐夫兄弟》）</span><br></pre></td></tr></table></figure><p>坐在周六早上的咖啡店里，呼啸的冷风使遮阳伞不停浮动。杂七杂八的事情使我突然意识到这一年真的要结束了，即使这一过渡的时刻仅仅具有象征意义，我也想挣扎着写下年终的总结，由此钉下一颗锲子。很抱歉我无法详细的捕捉过去一年发生的所有事情，组成流水账式的记录，也无法坦率的将自己一切想法开诚布公，似乎最能够接受的方法是记录下这一年里发生的一些事。<br><br />四月，度过了自己第二十二个生日。虽然很恬不知耻，但我真的一直以为自己还没有二十岁。印象深刻的是买了个巴斯克蛋糕，却没比巴掌大多少，五个人分着吃了，显的有点局促。<br><br />毕业前，和yu去日本玩了一周。没有跟团，只是自己瞎走，我英语一般，日本人则更差。不过加上些比比划划大概能交流，大体上没有出什么纰漏。在东京落地，坐火车到伊东，往北到镰仓，再继续向北回东京，一路上一直是令人微笑的风光和中学生男男女女，不得不感叹非常值得一去。<br><br />6月19日，在闷热的体育馆听完毕业典礼，又在学衡路上吃了药膳鸡，匆匆忙忙花完红跑车（一家很不错的面包店）储值卡里的钱。回到宿舍将海量的私人物品一半打包，一半丢掉，陆续得知同学离开或即将离开的消息。毕业是2024年最重要的时刻，似乎在重要的时刻总是在做次要的事情。但因为这些次要的时刻，我会永远怀念南京。<br><br />暑假刚开始，买了把吉他。断断续续练了几个月，虽然称不上勤恳但也算坚持下来了，总算能嗯嗯啊啊边弹边唱一点，虽然不好听。<br><br />9月5日我来到上海，对新学校的一切都感到陌生。学校位于闵行区的最南端，再往南就是长江…没有人会对这个选址满意，更何况四周都是叮叮哐哐漫天扬尘的工地。令人宽慰的是我工作的大楼是较新且明亮的，而厕所也值得单独拿出来赞扬。过去的四个月间我并没有做出什么成果，也几乎没有看文章学习，忙碌于一些断断续续的开发工作，代码能力的确提升了一些。唯二骄傲的是给朋友的论文提供了一些帮助，以及用一个通宵换来了数学建模二等奖，至少不用发愁毕业要求了。<br><br />国庆回家，去常熟的养老院看望了卧病在床的爷爷。实际上他已身体僵硬，几乎不能动弹，帮他翻身的时候感觉就像搬弄风干的肉块。我们告别时，眼泪滑落在他因疾病而蜷缩的脸上，衰老的具象表达使我意识到在一个家庭中，成长和衰老是并行的。圣诞节，爷爷的母亲去世了，2024年的最后一个晚上，久病的爷爷突然恶化，进了icu。<br><br />十月中旬，在回南京作报告的前一个礼拜，收到了期刊的拒稿。其实我对结果并没有太多意外，只是希望晚点收到消息，好让我抱有幻想。我在这篇文章上倾注了许多时间和精力，也从中受益匪浅，但其中存在问题之巨使我始终无法说服自己这是一篇正确的文章，拖延回避到现在。<br /><br><br />十一月底，去苏州听了张悬的演唱会。这一年听了好几场live，这是印象最深的一场。也买了不少唱片，自然是花了不少钱，有机会整理一下。<br><br />就写到这吧，总之2024年算是结束了。应该怎么形容？可以说在碌碌无为中度过了人生重要的节点，可以说是平凡中存在伟大的光芒。我不喜欢这些宏大的词汇，但没有具体的例子可以指向我思维中的挣扎和变化。长期以来我一直是一个缺乏驱动力的人，在生活上事业上还是情感上都缺乏驱动力。内驱力的缺乏和偶发的热情交替控制自己，我几乎陷入了永不休止的圆周性思考，回答然后又反驳关于未来的问题。不过这样也好，矛盾人的才是具体的人，只是希望在2025年，一条明晰的道路能够浮现。<br /><br><br />再见！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2025年终总结&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>基于三维网格码LAS点云网格化存储与可视化方案介绍</title>
    <link href="https://atffang.github.io/2024/12/12/%E5%9F%BA%E4%BA%8E%E4%B8%89%E7%BB%B4%E7%BD%91%E6%A0%BC%E7%A0%81LAS%E7%82%B9%E4%BA%91%E7%BD%91%E6%A0%BC%E5%8C%96%E5%AD%98%E5%82%A8%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%A1%88%E4%BB%8B%E7%BB%8D/"/>
    <id>https://atffang.github.io/2024/12/12/%E5%9F%BA%E4%BA%8E%E4%B8%89%E7%BB%B4%E7%BD%91%E6%A0%BC%E7%A0%81LAS%E7%82%B9%E4%BA%91%E7%BD%91%E6%A0%BC%E5%8C%96%E5%AD%98%E5%82%A8%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%A1%88%E4%BB%8B%E7%BB%8D/</id>
    <published>2024-12-12T07:54:35.000Z</published>
    <updated>2024-12-12T08:16:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>三维网格码计算思路分享02。</p><span id="more"></span><p>基于上一篇博文中网格码正反算的方法和代码，写了一些基础控件以完成基于LAS三维点云的网格化计算以及数据预览，具体内容请看下图。</p><img src="https://atffang.github.io/2024/12/12/基于三维网格码LAS点云网格化存储与可视化方案介绍/WorkFlow.png"/>]]></content>
    
    
    <summary type="html">&lt;p&gt;三维网格码计算思路分享02。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>地球空间网格编码正反算实现</title>
    <link href="https://atffang.github.io/2024/12/11/%E5%9C%B0%E7%90%83%E7%A9%BA%E9%97%B4%E7%BD%91%E6%A0%BC%E7%BC%96%E7%A0%81%E6%AD%A3%E5%8F%8D%E7%AE%97%E5%AE%9E%E7%8E%B0/"/>
    <id>https://atffang.github.io/2024/12/11/%E5%9C%B0%E7%90%83%E7%A9%BA%E9%97%B4%E7%BD%91%E6%A0%BC%E7%BC%96%E7%A0%81%E6%AD%A3%E5%8F%8D%E7%AE%97%E5%AE%9E%E7%8E%B0/</id>
    <published>2024-12-11T11:41:43.000Z</published>
    <updated>2024-12-12T08:12:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>三维网格码计算思路分享。</p><span id="more"></span><p>似乎这两年低空经济成为了潮流方向，多了一些政策倾斜。前阵子刚有公司来交流相关事宜，16日华师大又要新成立低空经济研究中心，这两天组里为了这些事情鞍前马后，竟然有些仿佛过年的热闹。我负责的工作是探索其中一小个部分，也是一个非常小众的应用方向：地球空间网格码，该工作目前的理论基础为国标<strong>GBT 40087-2021 地球空间网格编码规则</strong>。<br />地球空间网格基于 GeoSOT(Geographical coordinate global Subdivision based on One-dimensioninteger and Two ton&quot;power)地球剖分模型,将地球空间统一剖分成不同尺度的网格单元,并按统一编码规则进行标识和表达,构建了网格化的地球空间数据组织参考框架。该框架支持地球表面空间和地球立体空间与地理空间信息的聚合,可有效解决物联网、大数据、云计算中海量空间信息在标识和表达上的唯一性、可读性、尺度性、关联性的瓶颈,实现了多源,多尺度数据网格化高效组织、处理和应用,突破了地理空间信息跨行业应用的技术壁垒,推动地球系统科学的发展。<br />具体来说，网格剖分分为经纬度的水平面剖分和高程的垂直剖分。具体过程相对复杂，参见上述国家标准，本文仅分享一些实现步骤。</p><h4 id="1-经纬度网格剖分"><a class="markdownIt-Anchor" href="#1-经纬度网格剖分"></a> 1. 经纬度网格剖分</h4><p>根据国标，经纬度剖分的步骤如下所示：</p><ol><li>将该点经、纬度坐标表示成GB/T16831规定的形式,即A’B’C.D&quot;;</li><li>将该点的坐标按度、分、秒、秒小数部分分别转换为二进制数。即将度|A|由十进制数转换成8 bit 定长二进制数(A)2, 将分B由一进制数转换成6bit定长二进制数(B)2, 将秒C由十进制数转换成6bit定长二进制数©2, 将秒以下数D由一进制数转换成11bit定长二进制数(D)2;</li><li>分别将经、纬度坐标度、分、秒及秒以下二进制数(A)2、(B)2、©2、(D)2直接拼接成31 bit定长二进制数(E)2, 即(E)2=(A)2(B)2©2(D)2, 分别得到两个 31 bit定长数经度(EL)2, 和纬度(EB)2;</li><li>将纬度(EB)2,前置、经度(EL)2后置, 采用莫顿交叉的方式生成62bit的混合代码(F)2, 例如若(EB)2为100111 ,(EL)2为011010, 则(EB)2在前, (EL)2在后的莫顿交叉运算结果为(F)2为 100101101110;</li><li>将二进制混合代码(F)2转成四进制编码(F)4;</li><li>根据待求网格的级别m, 将(F)4中后32-m位四进制的码元去掉得到(F’)4;</li><li>根据经度和纬度,前加上G0、G1、G2或G3即可得到网格代码。</li></ol><p>代码实现步骤如下：<br />定义一个类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WGS84coordinate</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, latitude, longitude, elevation</span>):</span><br><span class="line">        self.latitude = latitude</span><br><span class="line">        self.longitude = longitude</span><br><span class="line">        self.elevation = elevation</span><br></pre></td></tr></table></figure><p>实现步骤1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 将该点经、纬度坐标表示成GB/T16831规定的形式,即A&#x27;B&#x27;C.D&quot;;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decimal2dms</span>(<span class="params">self, decimal</span>):</span><br><span class="line">        degrees = <span class="built_in">int</span>(decimal)</span><br><span class="line">        minutes = <span class="built_in">int</span>((<span class="built_in">abs</span>(decimal) - <span class="built_in">abs</span>(degrees)) * <span class="number">60</span>)</span><br><span class="line">        seconds = (<span class="built_in">abs</span>(decimal) - <span class="built_in">abs</span>(degrees)) * <span class="number">60</span></span><br><span class="line">        seconds = (seconds - minutes) * <span class="number">60</span></span><br><span class="line">        seconds_fractional, seconds_integer = math.modf(seconds)</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">int</span>(degrees), <span class="built_in">int</span>(minutes), <span class="built_in">int</span>(seconds_integer), seconds_fractional]</span><br></pre></td></tr></table></figure><p>实现步骤2,3：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 将该点的坐标按度、分、秒、秒小数部分分别转换为二进制数, 拼为31 bit定长数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dms2bit</span>(<span class="params">self, dms</span>):</span><br><span class="line">        <span class="comment"># dms = [degrees, seconds_fractional, seconds_integer]</span></span><br><span class="line">        degrees, minutes, seconds_integer, seconds_fractional = dms</span><br><span class="line">        <span class="comment"># print(f&quot;度：&#123;degrees&#125;, 分：&#123;minutes&#125;, 秒整数：&#123;seconds_integer&#125;，秒小数：&#123;seconds_fractional&#125;&quot;)</span></span><br><span class="line">        degrees_bin, minutes_bin, seconds_integer_bin = <span class="string">f&quot;<span class="subst">&#123;degrees:08b&#125;</span>&quot;</span>, <span class="string">f&quot;<span class="subst">&#123;minutes:06b&#125;</span>&quot;</span>, <span class="string">f&quot;<span class="subst">&#123;seconds_integer:06b&#125;</span>&quot;</span></span><br><span class="line">        seconds_fractional_scaled = <span class="built_in">int</span>(seconds_fractional * <span class="number">2048</span>)</span><br><span class="line">        seconds_fractional_bin = <span class="string">f&quot;<span class="subst">&#123;seconds_fractional_scaled:011b&#125;</span>&quot;</span></span><br><span class="line">        <span class="comment"># print(f&quot;度：&#123;degrees_bin&#125;, 分：&#123;minutes_bin&#125;, 秒整数：&#123;seconds_integer_bin&#125;，秒小数：&#123;seconds_fractional_bin&#125;&quot;)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([degrees_bin, minutes_bin, seconds_integer_bin, seconds_fractional_bin])</span><br></pre></td></tr></table></figure><p>实现步骤4,5：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3. 将经纬度的编码莫顿交叉,转为四进制编码</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mortoncross</span>(<span class="params">self</span>):</span><br><span class="line">        latbit = self.dms2bit(self.decimal2dms(self.latitude))</span><br><span class="line">        lonbit = self.dms2bit(self.decimal2dms(self.longitude))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(latbit) == <span class="number">31</span> <span class="keyword">and</span> <span class="built_in">len</span>(lonbit) == <span class="number">31</span>, <span class="string">&quot;Both binary strings must be 31 bits long.&quot;</span></span><br><span class="line">        interleaved_bits = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>):</span><br><span class="line">            interleaved_bits.append(latbit[i])</span><br><span class="line">            interleaved_bits.append(lonbit[i])</span><br><span class="line">        bit2 = <span class="string">&#x27;&#x27;</span>.join(interleaved_bits)</span><br><span class="line">        bit4 = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">str</span>(<span class="built_in">int</span>(bit2[i:i+<span class="number">2</span>], <span class="number">2</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(bit2), <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bit4</span><br></pre></td></tr></table></figure><p>实现步骤6,7：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. 根据待求网格的级别m,将(F)中后32-m位四进制的码元去掉得到(F);</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gridcode</span>(<span class="params">self, m</span>):</span><br><span class="line">        bit4 = self.mortoncross()</span><br><span class="line">        gridcode = bit4[:m-<span class="number">32</span>]</span><br><span class="line"></span><br><span class="line">        gridcode = <span class="string">&quot;G0&quot;</span> + gridcode</span><br><span class="line">        <span class="comment"># 高度码实现下面讲。</span></span><br><span class="line">        elevationcode = self.elevationcode(m)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [gridcode, elevationcode]</span><br></pre></td></tr></table></figure><h4 id="2-高程网格剖分"><a class="markdownIt-Anchor" href="#2-高程网格剖分"></a> 2. 高程网格剖分</h4><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>n</mi><mo>=</mo><mfrac><msub><mi>θ</mi><mn>0</mn></msub><mi>θ</mi></mfrac><msub><mo><mi>log</mi><mo>⁡</mo></mo><mrow><mn>1</mn><mo>+</mo><msub><mi>θ</mi><mn>0</mn></msub></mrow></msub><mrow><mo fence="true">(</mo><mfrac><mrow><mi>H</mi><mo>+</mo><msub><mi>r</mi><mn>0</mn></msub></mrow><msub><mi>r</mi><mn>0</mn></msub></mfrac><mo fence="true">)</mo></mrow></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(5)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">n = \frac{\theta_0}{\theta} \log_{1 + \theta_0} \left( \frac{H + r_0}{r_0} \right) \tag{5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.24196799999999996em;"><span style="top:-2.45586em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.02778em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34424em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span><span class="tag"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">5</span></span><span class="mord">)</span></span></span></span></span></span></p><p>其中：</p><ul><li>( n ) —— 从地面向上（或向下）数第n层立体网格，n为整数，地面以上n大于等于0，地面以下 n &lt; 0；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\theta_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>—— 初始划分范围定义的基础网格（1°网格）对应的经（纬）跨度差，单位为弧度（rad）<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>0</mn></msub><mo>=</mo><mfrac><mi>π</mi><mn>180</mn></mfrac></mrow><annotation encoding="application/x-tex">\theta_0 = \frac{\pi}{180}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">8</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> —— 该网格对应的经（纬）跨度差，单位为弧度（rad）；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">r_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> —— 地球长半轴，单位为米（m），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mn>0</mn></msub><mo>=</mo><mn>6</mn><mtext> </mtext><mn>378</mn><mtext> </mtext><mn>137</mn></mrow><annotation encoding="application/x-tex">r_0 = 6\,378\,137</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">7</span><span class="mord">8</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mord">7</span></span></span></span>；<br />去掉层数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 高位的 0 形成的编码即为高度域编码。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算高度的网格码</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">elevationcode</span>(<span class="params">self, m</span>):</span><br><span class="line">        theta_0 = math.pi / <span class="number">180</span></span><br><span class="line">        theta = GridSpanlist[m-<span class="number">1</span>] * math.pi / <span class="number">180</span></span><br><span class="line">        H = self.elevation</span><br><span class="line">        r_0 = <span class="number">6378137</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 计算公式</span></span><br><span class="line">        n = (theta_0 / theta) * math.log((H + r_0) / r_0, (<span class="number">1</span> + theta_0))</span><br><span class="line">        n = math.floor(n)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            n = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">str</span>(<span class="built_in">bin</span>(n)[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(n) &lt; m:</span><br><span class="line">            n = <span class="string">&#x27;0&#x27;</span> * (m - <span class="built_in">len</span>(n)) + n</span><br><span class="line">        n = <span class="string">&quot;H&quot;</span> + n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure><h4 id="3-网格码反算"><a class="markdownIt-Anchor" href="#3-网格码反算"></a> 3. 网格码反算</h4><p>这一部分的具体求解国标并没有提及，因此只能尝试自行求解，代码准确性为止，仅供参考：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GridCode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, grid_code, elevation_code, m</span>):</span><br><span class="line">        self.grid_code = grid_code</span><br><span class="line">        self.elevation_code = elevation_code</span><br><span class="line">        self.m = m</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;格网编码：<span class="subst">&#123;self.grid_code, self.elevation_code&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">degridcode_bit2dms</span>(<span class="params">self, binary_str</span>):</span><br><span class="line">        degrees_bin = binary_str[<span class="number">0</span>:<span class="number">8</span>]    <span class="comment"># 前8位是度</span></span><br><span class="line">        minutes_bin = binary_str[<span class="number">8</span>:<span class="number">14</span>]   <span class="comment"># 接下来的6位是分</span></span><br><span class="line">        seconds_integer_bin = binary_str[<span class="number">14</span>:<span class="number">20</span>]  <span class="comment"># 接下来的6位是秒的整数部分</span></span><br><span class="line">        seconds_fractional_bin = binary_str[<span class="number">20</span>:<span class="number">31</span>]  <span class="comment"># 最后的11位是秒的小数部分</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将每个二进制子串转换回整数</span></span><br><span class="line">        degrees = <span class="built_in">int</span>(degrees_bin, <span class="number">2</span>)</span><br><span class="line">        minutes = <span class="built_in">int</span>(minutes_bin, <span class="number">2</span>)</span><br><span class="line">        seconds_integer = <span class="built_in">int</span>(seconds_integer_bin, <span class="number">2</span>)</span><br><span class="line">        seconds_fractional_scaled = <span class="built_in">int</span>(seconds_fractional_bin, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将秒的小数部分恢复为原来的小数值</span></span><br><span class="line">        seconds_fractional = seconds_fractional_scaled / <span class="number">2048</span></span><br><span class="line">        total_seconds = seconds_integer + seconds_fractional</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将秒数转换为分的部分（秒/60）</span></span><br><span class="line">        total_minutes = minutes + total_seconds / <span class="number">60</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将分数转换为度的部分（分/60）</span></span><br><span class="line">        decimal = <span class="built_in">abs</span>(degrees) + total_minutes / <span class="number">60</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> decimal</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 编码反算</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">degridcode</span>(<span class="params">self</span>):</span><br><span class="line">        gridcode = self.grid_code</span><br><span class="line">        gridcode = gridcode[<span class="number">2</span>:]</span><br><span class="line">        gridcode = gridcode.ljust(<span class="number">31</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        bit2 = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">bin</span>(<span class="built_in">int</span>(c, <span class="number">4</span>))[<span class="number">2</span>:].zfill(<span class="number">2</span>) <span class="keyword">for</span> c <span class="keyword">in</span> gridcode)</span><br><span class="line"></span><br><span class="line">        latbit = []</span><br><span class="line">        lonbit = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">32</span>):</span><br><span class="line">            latbit.append(bit2[i * <span class="number">2</span> - <span class="number">2</span>])</span><br><span class="line">            lonbit.append(bit2[i * <span class="number">2</span> - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        latcode = <span class="string">&#x27;&#x27;</span>.join(latbit)</span><br><span class="line">        loncode = <span class="string">&#x27;&#x27;</span>.join(lonbit)</span><br><span class="line"></span><br><span class="line">        lat = self.degridcode_bit2dms(latcode)</span><br><span class="line">        lon = self.degridcode_bit2dms(loncode)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> lat, lon</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 高度码反算</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deelevationcode</span>(<span class="params">self</span>):</span><br><span class="line">        n_binary, m = self.elevation_code, self.m</span><br><span class="line"></span><br><span class="line">        theta_0 = math.pi / <span class="number">180</span></span><br><span class="line">        theta = GridSpanlist[m-<span class="number">1</span>] * math.pi / <span class="number">180</span></span><br><span class="line">        r_0 = <span class="number">6378137</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 高度码反算</span></span><br><span class="line">        n_binary = n_binary[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将二进制的 n 转换回整数</span></span><br><span class="line">        n = <span class="built_in">int</span>(n_binary, <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 根据公式反向解码，恢复 H</span></span><br><span class="line">        H = r_0 * (math.exp((n * theta) / theta_0 * math.log(<span class="number">1</span> + theta_0)) - <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> H</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 整体反算：</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params">self</span>):</span><br><span class="line">        lat, lon = self.degridcode()</span><br><span class="line">        H = self.deelevationcode()</span><br><span class="line">        <span class="keyword">return</span> lat, lon, H</span><br></pre></td></tr></table></figure><p>这样做的目的是为了得到网格码的代表性坐标，但是这个坐标到底具体代表了网格码六面体的哪个位置，不得而知。本文仅代表个人的一些探索，代码并不一定正确。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;三维网格码计算思路分享。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>DTDC2024</title>
    <link href="https://atffang.github.io/2024/11/28/DTDC2024/"/>
    <id>https://atffang.github.io/2024/11/28/DTDC2024/</id>
    <published>2024-11-28T14:42:00.000Z</published>
    <updated>2024-11-28T14:52:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>华东师范大学李响老师课题组参加DTDC2024会议。</p><span id="more"></span><p>感谢老师！<br /><img src="https://atffang.github.io/2024/11/28/DTDC2024/DTDC2024_1.jpg"/></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;华东师范大学李响老师课题组参加DTDC2024会议。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
